#!/usr/bin/env python
# encoding: utf-8

from __future__ import print_function, division
import subprocess
import os
import tempfile
import sys
import re
import glob
import math


class CommandError(Exception):
    """There was an error in calling the command."""
    
    def __init__(self, function=None, error=None, *hints):
        if function is None:
            function = "unknown function"
        if error is None:
            error = "unspecified"
        msg = "Error '%s' occured in %s" % (error, function)
        super(CommandError, self).__init__(msg)
        self.function = function
        self.error    = error
        self.hints    = hints
        self.report   = (error,) + hints


class CommandFailed(Exception):
    """A command has failed to carry out fully."""

    def __init__(self, function=None, error=None, *hints):
        if function is None:
            function = "unknown function"
        if error is None:
            error = "unspecified"
        msg = "Error '%s' occured in %s" % (error, function)
        super(CommandFailed, self).__init__(msg)
        self.function = function
        self.error    = error
        self.hints    = hints
        self.report   = (error,) + hints


def schedule(command=None, script=None, settings=None, replace=None, workdir=None, environment=None, output=None):
    '''
    qunexCommand scheduler 

    USE
    ===

    Schedules the provided command to be run by the specified scheduler (PBS, 
    LSF, SLURM are currently supported).

    INPUTS
    ======

    Required parameter
    ------------------

    --scheduler  A string specifying the scheduler to be used and the additional
                 settings for it.

    `scheduler` string should be a comma separated list of parameters. The first
    parameter has to be the scheduler name (PBS, LSF, SLURM), the rest of the
    parameters are key-value pairs that are to be passed as settings to the
    scheduler. Additional parameters common to all the schedulers can be
    specified:

    - jobname  ... the name of the job to run
    - comname  ... the name of the command the job runs
    - jobnum   ... the number of the job being run

    Example settings strings:

    "SLURM,jobname=bet1,time=03-24:00:00,ntasks=10,cpus-per-task=2,mem-per-cpu=2500,partition=pi_anticevic"
    "LSF,jobname=DWIproc,jobnum=1,cores=20,mem=250000,walltime=650:00,queue=anticevic"

    Optional parameter
    ------------------

    --output        A string specifying whether to return or redirect the
                    standard output and error. See "REDIRECTING OUTPUT" for
                    details

    If the optional parameter is not specified, it will not be used.


    REDIRECTING OUTPUT
    ==================

    If no output is specified, the job's standard output and error (stdout,
    stderr) are left as is and processed by the scheduler, and the result of
    submitting the job is printed to standard output. Output string can specify
    four different directives provided by "<key>:<value>" strings separated by
    pipe:

    stdout 
        specifies a path to a log file that should store standard output of the 
        submitted job
    stderr 
        specified a path to a log file that should store error output of the 
        submitted job
    both   
        specifies a path to a log file that should store joint standard and 
        error outputs of the submitted job

    Examples:

    . "stdout:processing.log"
    . "stdout:processing.output.log|stderr:processing.error.log"

    Do not specify error and standard outputs both using --output parameter and
    scheduler specific options within settings string.

    SCHEDULER SPECIFICS
    ===================

    Each of the supported scheduler systems has a somewhat different way of
    specifying job parameters. Please see documentation for each of the
    supported schedulers to provide the correct settings. Below are the
    information for each of the schedulers on how to specify --settings.

    PBS settings
    ------------

    PBS uses various flags to specify parameters. Be careful that the settings
    string includes only comma separated 'key=value' pairs. Scheduler will then
    do its best to use the right flags. Specifically:

    Keys: mem, walltime, software, file, procs, pmem, feature, host,
    naccesspolicy, epilogue, prologue will be submitted using::

        "#PBS -l <key>=<value>"

    Keys: j, m, o, S, a, A, M, q, t, e, N, l will be submitted using::
    
        "#PBS -<key> <value>"

    Key: depend will be submitted using::

        "#PBS -W depend=<value>"

    Key: umask will be submitted using::

        "#PBS -W umask=<value>"

    Key: nodes is a special case. It will be submitted as::

        "#PBS -l <value>"

    LSF settings
    ------------

    For LSF the following key/value parameters are parsed as:

    - queue    ... "#BSUB -q <queue>"
    - mem      ... "#BSUB -R 'span[hosts=1] rusage[mem=<mem>]"
    - walltime ... "#BSUB -W <walltime>"
    - cores    ... "#BSUB -n <cores>"

    Keys: g, G, i, L, cwd, outdir, p, s, S, sla, sp, T, U, u, v, e, eo, o, oo, 
    jobName will be submitted using::

        "#BSUB -<key> <value>"

    SLURM settings
    --------------

    For SLURM any provided key/value pair will be passed in the form:
    "#SBATCH --<key>=<value>"

    Some of the possible parameters to set are:

    - partition        ... The partition (queue) to use
    - nodes            ... Total number of nodes to run on
    - ntasks           ... Number of tasks
    - cpus-per-task    ... Number of cores per task
    - time             ... Maximum wall time DD-HH:MM:SS
    - constraint       ... Specific node architecture
    - mem-per-cpu      ... Memory requested per CPU in MB
    - mail-user        ... Email address to send notifications to
    - mail-type        ... On what events to send emails

    '''

    '''
    ~~~~~~~~~~~~~~~~~~

    Change log

    2017-06-17 Grega Repovs
               Initial version
    2017-09-30 Grega Repovs
               Added additional options to scheduling LSF jobs.
    2017-09-30 Grega Repovs
               Added options to redirect job output to log files.
    2018-10-03 Grega Repovs
               Added checking for validity of log file directories.
    2019-03-07 Jure Demsar
               Python3 support.
    2019-04-14 Grega Repovs
               Updated documentation
    2019-09-23 Grega Repovs
               UTF8 encoded input to stdin.
    2019-20-01 Jure Dem≈°ar
               Upgraded job naming and PBS scheduler
    '''

    # --- check inputs

    if command is None and script is None:
        raise CommandError("schedule", "Missing parameter", "Either command or script need to be specified to run scheduler!")

    if command is not None and script is not None:
        raise CommandError("schedule", "Parameter conflict", "Only command or script need to be provided to run scheduler!")

    if settings is None:
        raise CommandError("schedule", "Missing parameter", "Settings need to be provided to run scheduler!")

    # --- parse settings

    try:
        setList   = [e.strip() for e in settings.split(",")]
        scheduler = setList.pop(0)
        setDict = {}

        # split settings
        for s in setList:
            # parameters with values
            if "=" in s:
                sSplit = s.split("=", 1)
                setDict[sSplit[0].strip()] = sSplit[1].strip()
            # flags
            else:
                setDict[s.strip()] = "QX_FLAG"

        jobname   = setDict.pop('jobname', "schedule")
        comname   = setDict.pop('comname', "")
        jobnum    = setDict.pop('jobnum', "")
    except:
        raise CommandError("schedule", "Misspecified parameter", "Could not parse the settings string:", settings)

    if scheduler not in ['PBS', 'LSF', 'SLURM']:
        raise CommandError("schedule", "Misspecified parameter", "First value in the settings string has to specify one of PBS, LSF, SLURM!", "The settings string submitted was:", settings)

    # --- compile command to pass

    if command is None:
        if not os.path.exists(script):
            raise CommandFailed("schedule", "File not found", "The specified script does not exist! [%s]" % (script))
        command = open(script, "r")

    if workdir is not None:
        if not os.path.exists(workdir):
            raise CommandFailed("schedule", "Folder does not exist", "The specified working directory does not exist! [%s]" % (workdir))
        command = "cd %s\n" % (workdir) + command

    if environment is not None:
        if not os.path.exists(environment):
            raise CommandFailed("schedule", "File not found", "The specified environment script does not exist! [%s]" % (environment))
        command = open(environment, "r") + "\n" + command

    # --- do search replace

    if replace is not None:
        replace = [e.strip().split(":") for e in replace.split("|")]

        for key, value in replace:
            command.replace("{{%s}}" % (key), value)


    # --- parse output

    outputs = {'stdout': None, 'stderr': None, 'both': None, 'return': None}

    if output is not None:
        for k, v in [[f.strip() for f in e.split(":")] for e in output.split("|")]:
            if not os.path.exists(os.path.dirname(v)) and k != 'return':
                raise CommandFailed("schedule", "Folder does not exist", "The specified folder for the '%s' log file does not exist! [%s]" % (k, os.path.dirname(v)), "Please check your paths!")
            outputs[k] = v

    if outputs['both'] is not None:
        outputs['stderr'] = outputs['both']
        outputs['stdout'] = outputs['both']

    # --- build scheduler commands

    sCommand = ""

    if scheduler == "PBS":
        for k, v in setDict.items():
            if k in ('mem', 'walltime', 'software', 'file', 'procs', 'pmem', 'feature', 'host', 'naccesspolicy', 'epilogue', 'prologue'):
                sCommand += "#PBS -l %s=%s\n" % (k, v)
            elif k in ('j', 'm', 'o', 'S', 'a', 'A', 'M', 'q', 't', 'e', 'l'):
                sCommand += "#PBS -%s %s\n" % (k, v)
            elif k == 'depend':
                sCommand += "#PBS -W depend=%s\n" % (v)
            elif k == 'umask':
                sCommand += "#PBS -W umask=%s\n" % (v)
            elif k == 'N' and jobname == 'schedule':
                jobname = v
            elif k == 'nodes':
                sCommand += "#PBS -l nodes=%s\n" % v

        # job name
        if (comname != ""):
            jobname = "%s-%s" % (jobname, comname)
        if (jobnum != ""):
            jobname = "%s(%s)" % (jobname, jobnum)
        sCommand += "#PBS -N %s\n" % jobname

        if outputs['stdout'] is not None:
            sCommand += "#PBS -o %s\n" % (outputs['stdout'])
        if outputs['stderr'] is not None:
            sCommand += "#PBS -e %s\n" % (outputs['stderr'])
        if outputs['both']:
            sCommand += "#PBS -j oe\n"
        com = 'qsub'

    elif scheduler == "LSF":
        sCommand += "#BSUB -o %s-%s_#%s_%%J\n" % (jobname, comname, jobnum)
        for k, v in [('queue', '#BSUB -q %s\n'), ('mem', "#BSUB -R 'span[hosts=1] rusage[mem=%s]'\n"), ('walltime', '#BSUB -W %s\n'), ('cores', '#BSUB -n %s\n')]:
            if k in setDict:
                sCommand += v % (setDict[k])
        for k, v in setDict.items():
            if k in ('g', 'G', 'i', 'L', 'cwd', 'outdir', 'p', 's', 'S', 'sla', 'sp', 'T', 'U', 'u', 'v', 'e', 'eo', 'o', 'oo'):
                sCommand += "#BSUB -%s %s\n" % (k, v)
            elif k is 'jobName' and jobname == 'schedule':
                jobname = v

        # jobname
        if (comname != ""):
            jobname = "%s-%s" % (jobname, comname)
        sCommand += "#BSUB -P %s\n" % jobname
        if (jobnum != ""):
            jobname = "%s(%s)" % (jobname, jobnum)
        sCommand += "#BSUB -J %s\n" % jobname

        if outputs['stdout'] is not None:
            sCommand += "#BSUB -o %s\n" % (outputs['stdout'])
        if outputs['stderr'] is not None:
            sCommand += "#BSUB -e %s\n" % (outputs['stderr'])
        com = 'bsub'

    elif scheduler == "SLURM":
        sCommand += "#!/bin/sh\n"
        for key, value in setDict.items():
            if key in ('J', 'job-name') and jobname == 'schedule':
                jobname = v
            elif value == "QX_FLAG":
                sCommand += "#SBATCH --%s\n" % (key.replace('--', ''))
            else:
                sCommand += "#SBATCH --%s=%s\n" % (key.replace('--', ''), value)

        # jobname
        if (comname != ""):
            jobname = "%s-%s" % (jobname, comname)
        if (jobnum != ""):
            jobname = "%s(%s)" % (jobname, jobnum)
        sCommand += "#SBATCH --job-name=%s\n" % jobname

        if outputs['stdout'] is not None:
            sCommand += "#SBATCH -o %s\n" % (outputs['stdout'])
        if outputs['stderr'] is not None:
            sCommand += "#SBATCH -e %s\n" % (outputs['stderr'])
        com = 'sbatch'

    # --- run scheduler

    print("Submitting:\n------------------------------\n", sCommand + command)

    if outputs['return'] is None:
        serr = None
        sout = None
    elif outputs['return'] == 'both':
        serr = subprocess.STDOUT
        sout = subprocess.PIPE
    elif outputs['return'] == 'stderr':
        serr = subprocess.PIPE
        sout = None
    elif outputs['return'] == 'stdout':
        serr = None
        sout = subprocess.PIPE

    run = subprocess.Popen(com, shell=True, stdin=subprocess.PIPE, stdout=sout, stderr=serr, close_fds=True)
    run.stdin.write((sCommand + command).encode('utf-8'))
    run.stdin.close()

    # ---- returning results

    if outputs['return'] in ['both', 'stdout']:
        result = run.stdout.read()
        return result
    elif outputs['return'] in ['stderr']:
        result = run.stderr.read()
        return result


def getSesssionIDsFromBatchFile(filename):
    '''
    getSesssionIDsFromBatchFile(filename)

    An internal function for reading batch.txt files. It reads the file and
    returns a list of sessions with the information on images and the additional
    parameters specified in the header.

    '''

    '''
    ~~~~~~~~~~~~~~~~~~

    Change log

    Written by Grega Repovs and Jure Demsar.
    '''

    if not os.path.exists(filename):
        print("\n\n=====================================================\nERROR: Batch file does not exist [%s]", file=filename)
        raise ValueError("ERROR: Batch file not found: %s" % (filename))

    s = open(filename, "r").read()
    s = s.replace("\r", "\n")
    s = s.replace("\n\n", "\n")
    s = re.sub("^#.*?\n", "", s)

    s = s.split("\n---")
    s = [e for e in s if len(e) > 10]

    sessionids = []

    for sub in s:
        sub = sub.split('\n')
        sub = [e.strip() for e in sub]
        sub = [e.split("#")[0].strip() for e in sub]
        sub = [e for e in sub if len(e) > 0]

        for line in sub:
            line = [e.strip() for e in line.split(":")]

            # id line
            if len(line) == 2 and line[0] == "id":
                sessionids.append(line[1])
                break

    return sessionids


def getSesssionIDsFromList(filename):
    '''
    getSesssionIDsFromList(filename)

    An internal function for reading list files. It reads the file and
    returns a list of session ids.

    '''

    '''
    ~~~~~~~~~~~~~~~~~~

    Change log
    Written by Grega Repovs and Jure Demsar.
    '''

    if not os.path.exists(filename):
        print("\n\n=====================================================\nERROR: List file does not exist [%s]", file=filename)
        raise ValueError("ERROR: List file not found: %s" % (filename))

    sessionids  = []

    with open(filename) as f:
        for line in f:
            if line.strip()[:1] == "#":
                continue

            line = [e.strip() for e in line.split(":")]

            if len(line) == 2 and line[0] == "subject id":
                sessionids.append(line[1])

    return sessionids


def getSesssionIDs(listString, sessionsfolder=None):
    '''
    getSesssionIDs(listString)

    An internal function for getting a list of subject ids.

    The provided listString can be:

    - a comma, space or pipe separated list of subject id codes,
    - a path to a batch file (identified by .txt extension),
    - a path to a *.list file (identified by .list extension).

    '''

    '''
    ~~~~~~~~~~~~~~~~~~

    Change log
    Written by Grega Repovs and Jure Demsar.
    '''

    listString = listString.strip()

    if re.match(".*\.list$", listString):
        sessionids = getSesssionIDsFromList(listString)

    elif os.path.isfile(listString):
        sessionids = getSesssionIDsFromBatchFile(listString)

    elif re.match(".*\.txt$", listString) or '/' in listString:
        raise ValueError("ERROR: The specified subject file is not found! [%s]!" % listString)

    else:
        sessionids = [e.strip() for e in re.split(' +|,|\|', listString)]

        if sessionsfolder is not None:
            nlist = []
            for s in sessionids:
                nlist += glob.glob(os.path.join(sessionsfolder, s))
            sessionids = [os.path.basename(e) for e in nlist]

    return sessionids


def main(args=None):
    """
    qunex_container v0.1.0

    qunexContaiiner is a self-standing command that can run QuNex commands 
    against a Singularity or a Docker QuNex container. To run an QuNex command 
    against a container the basic call is::

        qunex_container <qunex command> [parameters] \
        --container="<a path to the Singularity image or a Docker container name>" [additional options]
    
    `qunex command` is any command supported by QuNex. `parameters` are any
    parameters that should be passed to the qunex command. This part is the same
    as running::

        qunex <qunex command> [parameters]

    from within a container or on a self-standing QuNex installation. For list 
    of commands and their parameters consult QuNex online or in-line 
    documentation.

    Additionally qunex_container accepts the following parameters:

    INPUTS
    ======

    --container     specifies either the path to the Singularity container image 
                    or the full specification of the Docker container to be used
                    (e.g. qunex/qunex_suite:0_45_07). This parameter can be 
                    omitted if the value is specified in the `QUNEXCONIMAGE` 
                    environmental variable.
    --bash_pre      If any additional commands have to be run in bash before the
                    execution of qunex_container command itself. Use a semicolon
                    separated list to chain multiple commands. ['']
    --bash_post     Used if any additional commands have to be run inside the
                    QuNex container before executing the desired QuNex command.
                    Use a semicolon separated list to chain multiple commands. 
                    ['']
    --bind          Used for binding external folder for execution via a 
                    singularity container, this is analog to the singularity's 
                    -B flag. ['']
    --nv            Required when using CUDA (GPU) inside singularity. If
                    provided then singularity exec --nv option will be used.
    --script        If a script is to be run against the Singularity container
                    rather than a single command, the path to the script to be
                    run is specified here. ['']
    --envars        If environment variables other than the default set by the
                    container are to be used, they can be specified in a pipe
                    separated string formatted as:
                    "<variable>=><value>|<variable>=><value>"
                    Note that only the variables recognized by the QuNex suite
                    will be appropriately parsed and used in the container.
    --dockeropt     A string that lists the additional options to be used when
                    running the Docker container. If the parameter is ommited, 
                    the content of `QUNEXDOCKEROPT` environment variable will
                    be used. If neither is specified, the container will be 
                    run in a detached mode with the current folder mounted as 
                    `/data` by specifying the following options::

                        '-d -v "$(pwd)":/data'                     
                    
                    The parameters are to be specified in a string exactly as 
                    they would be on a command line, e.g::

                        "-d -v /host/directory:/container/directory"

    --scheduler     A string that specifies the details to use to submit the 
                    container job to a scheduling system. 
    --output        A string specifying where to redirect the standard output 
                    and error when using the scheduler. See "Redirecting 
                    output" for details!
    
    RESULTS
    =======

    `qunex_container` will compile a temporary file with the relevant commands to 
    submit to the container. The file will be created in the users home folder
    and will be deleted as the last action completed by the container. In case 
    of a Docker container, to give access to the compiled script, the user's 
    home folder will be mounted as `/root` in the container, which is the home
    folder within the container.

    If a script parameter is specified, in case of a Singularity container, the 
    script will be executed using the `bash <script>` command. In case of a 
    Docker container, the content of the script will be appended to the 
    temporary script generated by the `qunex_container`. Do note that in the 
    case of the Singularity container the script can reference paths on the 
    host computer, whereas in the case of the Docker container, the script
    has to reference the paths and mounts as they are visible within the
    Docker container. 


    Scheduling containers
    ---------------------

    Container commands can be submitted to a scheduling system by specifying 
    the `--scheduler` parameter with a settings string. The settings string 
    should be a comma separated list of parameters. The first parameter has to 
    be the scheduler name (PBS, LSF, SLURM), the rest of the parameters are 
    key-value pairs that are to be passed as settings to the scheduler. 
    Additional parameters common to all the schedulers can be specified:

    - jobname ... the name of the job to run
    - comname ... the name of the command the job runs
    - jobnum  ... the number of the job being run

    Example settings strings::

        "SLURM,jobname=hcp2,time=03-24:00:00,ntasks=10,cpus-per-task=2,mem-per-cpu=2500,partition=pi_anticevic"
        "LSF,jobname=DWIproc,jobnum=1,cores=20,mem=250000,walltime=650:00,queue=pi_anticevic"


    Scheduling multiple containers in parallel
    ------------------------------------------
    
    If the parameters provided include --parsessions, --scheduler, and --sessions, 
    then qunex_container will spread the execution of the command by scheduling 
    multiple containers to run on separate nodes. Specifically, it will schedule
    each node to run a container with `parsessions` sessions. E.g. if 10 sessions are 
    specified and parsessions is set to 4, the command will schedule four containers 
    to run on four nodes. The first three containers will each run three 
    sessions in parallel, the fourth container will run the remaining session. 


    Passing --sessions parameter values cleanly
    -------------------------------------------

    In the case that --sessions parameter needs to be passed to a command, but
    not used to split up processing into multiple container calls (e.g. in 
    importDICOM or importBIDS commands), specify the sessions to pass to the
    call using the --csessions parameter. The value of that parameter will be
    passed on as --sessions parameter to the command.


    Redirecting output
    ------------------

    When running a container with a scheduler, the standard output and error
    will be saved in a folder where the command was run based on each scheduler
    system defauls. By specifying the `output` parameter the command output can
    be redirected. The parameter supports three different directives provided by
    "<key>:<value>" pairs in a pipe separated string:

    stdout
        specifies a path to a log file that should store standard output of the 
        submitted job
    stderr
        specified a path to a log file that should store error output of the 
        submitted job
    both
        specifies a path to a log file that should store joint standard and 
        error outputs of the submitted job

    Examples:

    - "stdout:processing.log"
    - "stdout:processing.output.log|stderr:processing.error.log"
    - "both:processing.log"

    Do not specify error and standard outputs both using --output parameter and
    scheduler specific options within settings string. It is best to provide 
    full absolute paths to the desired log.

    
    EXAMPLE USE
    ===========

    ::

        qunex_container hcp2 \\
        --sessionsfolder=/data/study/sessions \\
        --sessions=/data/study/processing/batch.txt \\
        --parsessions=4 \\
        --container=/singularity/qunex_suite-0_38_10.simg \\
        --scheduler="SLURM,time=2-00:00:00,ntasks=1,cpus-per-task=2,mem-per-cpu=15000,partition=pi_anticevic"

    """

    """
    ~~~~~~~~~~~~~~~~~~

    Change log

    2019-03-23 Grega Repovs
               First complete version with documentation.
    2019-04-15 Grega Repovs
               Updated Docker submission to enable script support.
               Changed image parameter to container
    2019-07-25 Grega Repovs
               Updated the call to use sessions rather than subjects
    2019-08-26 Grega Repovs
               Added the csessions parameter
    2019-09-28 Grega Repovs
               Fixed csession order bug
    2020-01-15 Jure Demsar
               Added the bash parameter
    2020-01-21 Jure Demsar
               Added the bind parameter
    2020-01-21 Jure Demsar
               Added the bash_post parameter
    2020-08-24 Jure Demsar
               Added the nv parameter
    """

    if args is None:
        args = sys.argv[1:]

    if not args:
        print(main.__doc__)
        exit()

    scheduler      = None
    conimage       = None
    command        = ""
    bash_pre       = None
    bash_post      = None
    bind           = None
    nv             = None
    script         = None
    parsessions    = 1
    sessions       = None
    sessionsfolder = None
    sessionids     = None
    envars         = None
    dockeropt      = None
    output         = None
    csessions      = None

    for arg in args:
        if "scheduler=" in arg:
            k, scheduler = arg.split("=", 1)
        elif "container=" in arg:
            k, conimage = arg.split("=", 1)
        elif "envars=" in arg:
            k, envars = arg.split("=", 1)
        elif "dockeropt=" in arg:
            k, dockeropt = arg.split("=", 1)
        elif "output=" in arg:
            k, output = arg.split("=", 1)
        elif "bash_pre=" in arg:
            k, bash_pre = arg.split("=", 1)
        elif "bash_post=" in arg:
            k, bash_post = arg.split("=", 1)
        elif "bind=" in arg:
            k, bind = arg.split("=", 1)
        elif arg == "--nv":
            nv = True
        elif "script=" in arg:
            k, script = arg.split("=", 1)
        elif "parsessions=" in arg:
            k, parsessions = arg.split("=", 1)
            command += '%s="%s" ' % (k, parsessions)
        elif "sessionsfolder=" in arg:
            k, sessionsfolder = arg.split("=", 1)
            command += '%s="%s" ' % (k, sessionsfolder)
        elif "csessions=" in arg:
            k, csessions = arg.split("=", 1)
            command += '--sessions="%s" ' % (csessions)
        elif "sessions=" in arg:            
            k, sessions = arg.split("=", 1)
            command += '%s="%s" ' % (k, sessions)        
        elif "sessionids=" in arg:
            k, sessionids = arg.split("=", 1)
        elif "=" in arg:
            k, v = arg.split('=', 1)
            command += '%s="%s" ' % (k, v)
        else:
            command += '%s ' % (arg)

    if csessions is not None and sessions is not None:
        print("ERROR: Please specify either sessions or csessions, but not both!")
        exit(1)

    parsessions = int(parsessions)

    if command.startswith('?scheduler'):
        print(schedule.__doc__)
        exit()

    if conimage is None:
        if "QUNEXCONIMAGE" in os.environ:
            conimage = os.environ['QUNEXCONIMAGE']
        else:
            print("ERROR: No Singularity image or Docker container name specified either in the command line or as a QUNEXCONIMAGE environment variable!")
            exit(1)

    # -- check for environment variables

    if envars:
        envars = [e for e in envars.split('|')]
        envars = [e.split('=>') for e in envars if '=>' in e]
    else:
        envars = []

    # -- check for docker options

    if dockeropt is None:
        if "QUNEXDOCKEROPT" in os.environ:
            dockeropt = os.environ['QUNEXDOCKEROPT']
        else:
            dockeropt = "-d -v \"$(pwd)\":/data"

    homedir = os.path.expanduser("~")
    dockeropt += " -v \"%s\":/root" % (homedir)

    # run in parallel if:
    # - parsessions is not None
    # - schedulers is not None
    # - sessions is not None
    sessionidsArray = []
    if parsessions is not None and sessions is not None and scheduler is not None:
                
        # split sessions via sessionids or split existing sessionids
        if sessionids is None:
            sessionids = getSesssionIDs(sessions, sessionsfolder=sessionsfolder)
        else:
            getsessionids = getSesssionIDs(sessions, sessionsfolder=sessionsfolder)
            sessionidsSplit = re.split(' +|,|\|', sessionids)
            print("sessionidsSplit:", sessionidsSplit, "\nsessionids",  sessionids, "\ngetsessionids", getsessionids)
            sessionids = [e for e in getsessionids if e in sessionidsSplit]

        if scheduler is None:
            containers = parsessions

            # split sessionids according to parsessions and add to array
            start = 0
            end = len(sessionids)
            chunks = int(math.ceil(end / float(parsessions)))
            for i in range(start, end, chunks):
                start = i
                sessionidsChunk = sessionids[start:start+chunks]
                sessionidsArray.append(','.join(sessionidsChunk))        
        
        else:
            containers = 0

            # split sessionids according to parsessions and add to array
            while sessionids:
                containers += 1
                sessionidsChunk = [sessionids.pop(0) for e in range(parsessions) if sessionids]
                sessionidsArray.append(','.join(sessionidsChunk))

    else:
        # do not run parallel
        containers = 1
        # add sessionids filter back if exists
        if sessionids is not None:
            sessionidsArray.append(sessionids)

    singularity = conimage.endswith(".simg") or conimage.endswith(".sif")

    for i in range(0, containers):
        scheduleCommand = command

        # add sessionids to command?
        if i < len(sessionidsArray):
            sessionids = sessionidsArray[i]
            scheduleCommand += 'sessionids="%s" ' % (sessionids)

        # setup script        
        fid, scriptPath = tempfile.mkstemp(dir=homedir)
        scriptName = os.path.basename(scriptPath)
        f = os.fdopen(fid, 'w')

        for k, v in envars:
            print("export con_%s=\"%s\"" % (k, v), file=f)
        print("source /opt/qunex/env/qunex_environment.sh", file=f)

        if bash_post:
            print(bash_post, file=f)

        if script:
            if singularity:
                print("bash " + script, file=f)
            else:
                with open(script, 'r') as sfile:
                    for line in sfile:
                        print(line, file=f)
        elif 'runTurnkey' in scheduleCommand:
            scheduleCommand = scheduleCommand.replace('runTurnkey', '')
            print("bash /opt/qunex/bash/qx_utilities/RunTurnkey.sh" + scheduleCommand, file=f)
            
        else:        
            print("bash /opt/qunex/bin/qunex.sh " + scheduleCommand, file=f)

        containerCommand = ""
        if bash_pre:
            containerCommand += bash_pre + ";"

        if singularity:
            print("rm " + scriptPath, file=f)
            f.close()

            containerCommand += "singularity exec "

            # nv
            if nv:
                containerCommand += "--nv "

            # bind
            if bind:
                containerCommand += "-B %s " % bind

            containerCommand +=  "%s bash %s" % (conimage, scriptPath)
        else:
            print("rm " + os.path.join(homedir, scriptName), file=f)
            f.close()

            containerCommand = "docker container run %s %s bash ~/%s" % (dockeropt, conimage, scriptName)

        if scheduler:
            schedule(command=containerCommand, settings=scheduler, output=output)
        else:
            subprocess.Popen(containerCommand, shell=True)

if __name__ == "__main__":
    main()
