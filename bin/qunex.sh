#!/bin/bash
#
# SPDX-FileCopyrightText: 2021 QuNex development team <https://qunex.yale.edu/>
#
# SPDX-License-Identifier: GPL-3.0-or-later
#
#~ND~FORMAT~MARKDOWN~
#~ND~START~
#
# ## PRODUCT
#
# qunex.sh is a front-end bash integration script for the QuNex Suite
#
#~ND~END~

# =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-==-=-=-=-=-=
# =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= CODE START =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
# =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-==-=-=-=-=-=

qunex_commands="show_version environment dwi_legacy_gpu dwi_eddy_qc dwi_parcellate dwi_seed_tractography_dense dwi_dtifit dwi_bedpostx_gpu dwi_pre_tractography dwi_probtrackx_dense_gpu auto_ptx compute_bold_fc fc_compute_wrapper parcellate_anat parcellate_bold extract_roi run_qc run_turnkey"

# version
QuNexVer=`cat ${TOOLS}/${QUNEXREPO}/VERSION.md`

# ------------------------------------------------------------------------------
# -- Splash call
# ------------------------------------------------------------------------------

show_splash() {
    echo ""
    echo "Generated by QuNex"
    echo "------------------------------------------------------------------------"
    echo "Version: $QuNexVer"
    echo "User: `whoami`"
    echo "System: `hostname`"
    echo "OS: $OSInfo $OperatingSystem"
    echo "------------------------------------------------------------------------"
    echo ""
    echo "                ____            _   _   _               "
    echo "               / __ \\          | | | \\ | |              "
    echo "              | |  | |  _   _  | | |  \\| |   ___  __  __"
    echo "              | |  | | | | | | | | | .   |  / _ \\ \\ \\/ /"
    echo "              | |__| | | |_| | | | | |\\  | |  __/  >  < "
    echo "               \\___\\_\\  \\____| | | |_| \\_|  \\___| /_/\\_\\"
    echo "                               |_|                      "
    echo ""
    echo "                              $QuNexVer"
    echo ""
    echo ""
    echo "                       DEVELOPED & MAINTAINED BY:"
    echo ""
    echo "               Mind & Brain Lab, University of Ljubljana"
    echo "                       Cho Lab, Yale University"
    echo ""
    echo "                      COPYRIGHT & LICENSE NOTICE:"
    echo ""
    echo "Use of this software is subject to the terms and conditions defined in"
    echo "QuNex LICENSES which can be found in the LICENSES folder of the QuNex"
    echo "repository or at https://qunex.yale.edu/qunex-registration"
    echo ""
}

# ------------------------------------------------------------------------------
# -- General help usage
# ------------------------------------------------------------------------------

show_usage() {

cat << EOF

 General QuNex usage syntax
============================

  qunex <command_name>
    --parameterA=<required-parameter-args>
    [--parameterB=<optional-parameter-args>]

  =>  --   Dashes or “flags” denote input parameters.
  =>  []   Square brackets denote optional parameters.
        Note: Arguments is shown inside [] denote default behavior of optional parameters.
  =>  <>   Angle brackets denote user-specified arguments for a given parameter.
  => Command names, parameters and arguments are shown in small or “camel” case.


 Specific command usage
=======================

  qunex <command_name>


 Display listing of all QuNex commands
======================================

  qunex -a

EOF

}

qunex_failed() {
    echo ""
    echo "QuNex FAILED!"
    echo ""
}

qunex_done() {
    echo ""
    echo "QuNex DONE!"
    echo ""
}

# =======================================================================================================
# =========================================== CODE STARTS HERE ==========================================
# =======================================================================================================

# ------------------------------------------------------------------------------------------------------
# -- Help calls for QuNex Functions
# ------------------------------------------------------------------------------------------------------

show_usage_qxutil() {
    echo ""
    gmri ${usage_input} --help
}

show_all_qunex_commands() {
    gmri --allcommands
}

# ---------------------------------------------------------------------------------------------------------------
# -- Master Execution and Logging -- https://qunex.readthedocs.io/en/latest/wiki/Overview-Logging.html
# ---------------------------------------------------------------------------------------------------------------

bash_call_execute() {

    # -- Set platform info
    Platform="Platform Information: `uname -a`"
    # -- Set the time stamp for given job
    TimeStamp=`date +%Y-%m-%d_%H.%M.%S.%6N`
    if [[ ${CommandToRun} == "run_turnkey" ]]; then
        unset qxutil_command_to_run
        if ( [[ ! -z `echo ${TURNKEY_STEPS} | grep -E 'create_study|createStudy'` ]] || [[ ${TURNKEY_TYPE} == 'xnat' ]] ) && [[ ! -f ${StudyFolder}/.qunexstudy ]]; then
            if [[ ! -d ${WORKDIR} ]]; then
                mkdir -p ${WORKDIR} &> /dev/null
            fi
            gmri create_study --studyfolder=${StudyFolder}
        fi
    fi

    # -- Check if Matlab command
    unset QuNexMatlabCall
    matlab_functions_check=`find $TOOLS/$QUNEXREPO/matlab/ -name "*.m" | grep -v "archive/"`

    if [[ ! -z $CommandToRun ]]; then
        if [[ ! -z `echo $matlab_functions_check | grep "$CommandToRun"` ]]; then
            QuNexMatlabCall="$CommandToRun"
            echo ""
            echo " ---> Note: $QuNexMatlabCall is part of the QuNex MATLAB."
            echo ""
        fi
    fi

    # -- Check if study folder is created
    if [[ ! -f ${StudyFolder}/.qunexstudy ]] && [[ -d ${StudyFolder} ]] && [[ -z ${QuNexMatlabCall} ]]; then
        echo ""
        echo "WARNING: QuNex study folder specification .qunexstudy in ${StudyFolder} not found."
        echo "         Check that ${StudyFolder} is a valid QuNex folder."
        echo "         Consider re-generating QuNex hierarchy..."; echo ""
        # gmri create_study --studyfolder=${StudyFolder}
    fi

    # -- Added checks for study folder generation
    if [[ -z ${QuNexMatlabCall} ]] && [[ -d ${StudyFolder}/sessions ]] && [[ ${SessionsFolder} != "sessions" ]] && [[ -f ${StudyFolder}/.qunexstudy ]]; then
        # -- Add check in case the sessions folder is distinct from the default name
        # -- Eventually use the template file to replace hard-coded values
        QuNexSessionsSubFolders=`cat $TOOLS/$QUNEXREPO/python/qx_utilities/templates/study_folders_default.txt | tr -d '\r'`
        QuNexSessionsFolders="${SessionsFolder}/inbox/MR ${SessionsFolder}/inbox/EEG ${SessionsFolder}/inbox/BIDS ${SessionsFolder}/inbox/HCPLS ${SessionsFolder}/inbox/behavior ${SessionsFolder}/inbox/concs ${SessionsFolder}/inbox/events ${SessionsFolder}/archive/MR ${SessionsFolder}/archive/EEG ${SessionsFolder}/archive/BIDS ${SessionsFolder}/archive/HCPLS ${SessionsFolder}/archive/behavior ${SessionsFolder}/specs ${SessionsFolder}/QC"
        for QuNexSessionsFolder in ${QuNexSessionsFolders}; do
            if [[ ! -d ${QuNexSessionsFolder} ]]; then
                echo "QuNex folder ${QuNexSessionsFolder} not found. Generating now..."; echo ""
                mkdir -p ${QuNexSessionsFolder} &> /dev/null
            fi
        done
    fi

    # -- If logfolder flag set then set it and set master log
    if [[ -z ${LogFolder} ]]; then
        MasterLogFolder="${StudyFolder}/processing/logs"
    else
        MasterLogFolder="$LogFolder"
    fi
    if [[ ! -d ${MasterLogFolder} ]]; then
        mkdir ${MasterLogFolder} &> /dev/null
    fi

    # -- Set and generate runlogs folder
    MasterRunLogFolder="${MasterLogFolder}/runlogs"
    if [[ ! -d ${MasterRunLogFolder} ]]; then
        mkdir ${MasterRunLogFolder} &> /dev/null
    fi

    # -- Set and generate comlogs folder
    MasterComlogFolder="${MasterLogFolder}/comlogs"
    if [[ ! -d ${MasterComlogFolder} ]]; then
        mkdir ${MasterComlogFolder} &> /dev/null
    fi

    # -- Set and generate runchecks folder
    RunChecksFolder="${StudyFolder}/processing/runchecks"
    if [[ ! -d ${RunChecksFolder} ]]; then
        mkdir ${RunChecksFolder} &> /dev/null
    fi

    # -- Set and generate temp run_turnkey unit tests folder
    ComRunFolder="${StudyFolder}/processing/scripts/run_turnkey"
    if [[ ! -d ${ComRunFolder} ]]; then
        mkdir ${ComRunFolder} &> /dev/null
    fi

    # -- Specific call for python qx_utilities functions
    if [[ ${qxutil_command_to_run} ]]; then
        echo ""
        echo "--- Full QuNex call for command: ${qxutil_command_to_run}"
        echo ""
        echo "qunex ${gmriinput}"
        echo ""
        echo "---------------------------------------------------------"
        echo ""
        echo ""
        eval "gmri ${gmriinput}"
    else
        # log tag
        if [[ ${CommandToRun} != "run_qc" ]]; then
            logtag="${CommandToRun}_${CASE}_${TimeStamp}"
        else
            if [[ -z ${Modality} ]]; then
                logtag="${CommandToRun}_${CASE}_${TimeStamp}"
            else
                modality_lower=$(echo "${Modality}" | tr '[:upper:]' '[:lower:]')

                # add bold number if only one BOLD in BOLDLIST
                if [[ -n ${BOLDLIST} ]]; then
                    if [[ ! "${BOLDLIST}" =~ [,\ |] ]]; then
                        modality_lower=${modality_lower}_${BOLDLIST}
                    fi
                fi

                logtag="${CommandToRun}_${modality_lower}_${CASE}_${TimeStamp}"
            fi
        fi

        # runlog
        Runlog="${MasterRunLogFolder}/Log-${logtag}.log"

        # comlog
        ComlogTmp="${MasterComlogFolder}/tmp_${logtag}.log"; touch ${ComlogTmp}; chmod 777 ${ComlogTmp}
        ComRun="${ComRunFolder}/Run_${logtag}.sh"; touch ${ComRun}; chmod 777 ${ComRun}
        ComlogDone="${MasterComlogFolder}/done_${logtag}.log"
        CompletionCheckPass="${RunChecksFolder}/CompletionCheck_${CommandToRun}_${TimeStamp}.Pass"
        ComlogError="${MasterComlogFolder}/error_${logtag}.log"
        CompletionCheckFail="${RunChecksFolder}/CompletionCheck_${CommandToRun}_${TimeStamp}.Fail"

        # -- Batchlog
        # --   <batch system>_<command name>_job<job number>.<date>_<hour>.<minute>.<microsecond>.log
        echo ""
        echo "--- Full QuNex call for command: ${CommandToRun}"
        echo ""
        echo "${QuNexCallToRun}"
        echo ""
        echo "--------------------------------------------------------------"
        echo ""
        echo ""

        # -- Declare commands
        echo "# Generated by QuNex ${QuNexVer} on ${TimeStamp}" >> ${Runlog}
        echo "#" >> ${Runlog}
        echo "${QuNexCallToRun}" >> ${Runlog}
        echo "#!/bin/bash" >> ${ComRun}
        echo "# Generated by QuNex ${QuNexVer} on ${TimeStamp}" >> ${ComRun}
        echo "#" >> ${ComRun}
        echo "export PYTHONUNBUFFERED=1" >> ${ComRun}
        echo "${QuNexCallToRun}" >> ${ComRun}
        chmod 777 ${ComRun}

        # -- Check that $ComRun is set properly
        echo ""; if [ ! -f "${ComRun}" ]; then echo "ERROR: ${ComRun} file not found. Check your inputs"; echo ""; return 1; fi
        ComRunSize=`wc -c < ${ComRun}` > /dev/null 2>&1
        echo ""; if [[ "${ComRunSize}" == 0 ]]; then > /dev/null 2>&1; echo "ERROR: ${ComRun} file found but has no content. Check your inputs"; echo ""; return 1; fi

        # -- Define command to execute
        echo "# Generated by QuNex ${QuNexVer} on ${TimeStamp}" >> ${ComlogTmp}
        echo "#" >> ${ComlogTmp}
        ComRunExec=". ${ComRun} 2>&1 | tee -a ${ComlogTmp}"

        # -- Acceptance tests
        ComComplete="cat ${ComlogTmp} | grep 'Successful completion' > ${CompletionCheckPass}"
        ComError="cat ${ComlogTmp} | grep 'ERROR' > ${CompletionCheckFail}"

        # -- Garbage collection
        ComGarbageCollect="if [[ -f 0 && ! -s 0 ]]; then echo 'delete' >> qunex_garbage0; fi; if [[ -s 1 ]]; then cat 1 | grep 'qunex' > qunex_garbage1; fi; if [[ -s 2 ]]; then cat 2 | grep 'FSL_FIX_MCRROOT' >> qunex_garbage2; fi"
        ComGarbageRemove="if [[ -s qunex_garbage0 ]]; then rm 0; rm qunex_garbage0; fi; if [[ -s qunex_garbage1 ]]; then rm 1; rm qunex_garbage1; fi; if [[ -s qunex_garbage2 ]]; then rm 2; rm qunex_garbage2; fi"
        ComRunGarbage="${ComGarbageCollect}; ${ComGarbageRemove}"

        # -- Run the commands locally
        if [[ ${Cluster} == 1 ]]; then
            # -- Command to perform acceptance test
            ComRunCheck="if [[ -s ${CompletionCheckPass} && ! -s ${CompletionCheckFail} ]]; then mv ${ComlogTmp} ${ComlogDone}; rm -rf ${ComRunFolder}; echo ''; echo ' ---> Successful completion of ${CommandToRun}. Check final QuNex log output:'; echo ''; echo '    ${ComlogDone}'; qunex_done; echo ''; else mv ${ComlogTmp} ${ComlogError}; echo ''; echo ' ---> ERROR during ${CommandToRun}. Check final QuNex error log output:'; echo ''; echo '    ${ComlogError}'; echo ''; qunex_failed; fi"
            # -- Combine final string of commands
            ComRunAll="${ComRunExec}; ${ComComplete}; ${ComError}; ${ComRunCheck}; ${ComRunGarbage}"
            echo "--------------------------------------------------------------"
            echo ""
            echo "   Running ${CommandToRun} locally on `hostname`"
            echo "   Command log:     ${Runlog}  "
            echo "   Command output: ${ComlogTmp} "
            echo ""
            echo "--------------------------------------------------------------"
            echo ""
            eval "${ComRunAll}"
        fi

        # -- Run the commands via scheduler
        if [[ ${Cluster} == 2 ]]; then
            # -- Command to perform acceptance test
            ComRunCheck="if [[ -s ${CompletionCheckPass} && ! -s ${CompletionCheckFail} ]]; then mv ${ComlogTmp} ${ComlogDone}; rm -rf ${ComRunFolder}; echo ''; echo ' ---> Successful completion of ${CommandToRun}. Check final QuNex log output:'; echo ''; echo '    ${ComlogDone}'; echo ''; echo 'QUNEX PASSED!'; echo ''; else mv ${ComlogTmp} ${ComlogError}; echo ''; echo ' ---> ERROR during ${CommandToRun}. Check final QuNex error log output:'; echo ''; echo '    ${ComlogError}'; echo ''; echo ''; echo 'QUNEX FAILED!'; fi"
            # -- Combine final string of commands
            ComRunAll="${ComRunExec}; ${ComComplete}; ${ComError}; ${ComRunCheck}; ${ComRunGarbage}"
            cd ${MasterRunLogFolder}
            gmri schedule command="${ComRunAll}" settings="${Scheduler}" bash="${Bash}"
            echo "--------------------------------------------------------------"
            echo ""
            echo "   Data successfully submitted to scheduler"
            echo "   Scheduler details: ${Scheduler}"
            echo "   Command log: ${Runlog}"
            echo "   Command output: ${ComlogTmp} "
            echo ""
            echo "--------------------------------------------------------------"
            echo ""
        fi
    fi

}

# ---------------------------------------------------------------------------------------------------------------
# -- run_turnkey - Turnkey execution of QuNex workflow via the XNAT docker engine
# ---------------------------------------------------------------------------------------------------------------

run_turnkey() {
    # -- Specify command variable
    unset QuNexCallToRun
    unset qxutil_command_to_run
    QuNexCallToRun="${TOOLS}/${QUNEXREPO}/bash/qx_utilities/run_turnkey.sh --bolds=\"${BOLDS// /,}\" ${runTurnkeyArguments} --sessions=\"${CASE}\" --turnkeysteps=\"${TURNKEY_STEPS// /,}\" --sessionids=\"${CASE}\""
    bash_call_execute
}

show_usage_run_turnkey() {
    ${TOOLS}/${QUNEXREPO}/bash/qx_utilities/run_turnkey.sh
}

# -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
# -- dwi_legacy_gpu - Executes the Diffusion Processing Script via FUGUE implementation for legacy data - (needed for legacy DWI data that is non-HCP compliant without counterbalanced phase encoding directions needed for topup)
# -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

dwi_legacy_gpu() {
    # -- Specify command variable
    QuNexCallToRun="${TOOLS}/${QUNEXREPO}/bash/qx_utilities/dwi_legacy_gpu.sh \
    --sessionsfolder=${SessionsFolder} \
    --session=${CASE} \
    --usefieldmap=${UseFieldmap} \
    --pedir=${pedir} \
    --echospacing=${EchoSpacing} \
    --te=${te} \
    --unwarpdir=${UnwarpDir} \
    --diffdatasuffix=${diffdatasuffix} \
    --overwrite=${Overwrite} \
    --nogpu=${nogpu}"

    # -- QuNex bash execute function
    bash_call_execute
}

show_usage_dwi_legacy_gpu() {
    echo ""; echo "qunex ${usage_input}"
    ${TOOLS}/${QUNEXREPO}/bash/qx_utilities/dwi_legacy_gpu.sh
}

# -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
# -- dwi_eddy_qc - Executes the DWI EddyQ C (dwi_eddy_qc.sh) via the QuNex bash wrapper
# -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

dwi_eddy_qc() {
    # -- Check if eddy_squad and eddy_quad exist in user path
    EddySquadCheck=`which eddy_squad`
    EddyQuadCheck=`which eddy_quad`
    if [[ -z ${EddySquadCheck} ]] || [[ -z ${EddySquadCheck} ]]; then
        echo ""
        echo "ERROR: EDDY QC does not seem to be installed on this system."
        echo ""
        exit 1
    fi
    # -- Specify command variable
    QuNexCallToRun=". ${TOOLS}/${QUNEXREPO}/bash/qx_utilities/dwi_eddy_qc.sh \
    --sessionsfolder=${SessionsFolder} \
    --session=${CASE} \
    --eddybase=${EddyBase} \
    --eddypath=${EddyPath} \
    --report=${Report} \
    --bvalsfile=${BvalsFile} \
    --mask=${Mask} \
    --eddyidx=${EddyIdx} \
    --eddyparams=${EddyParams} \
    --bvecsfile=${BvecsFile} \
    --overwrite=${Overwrite}"
    # -- QuNex bash execute function
    bash_call_execute
}

show_usage_dwi_eddy_qc() {
    echo ""; echo "qunex ${usage_input}"
    ${TOOLS}/${QUNEXREPO}/bash/qx_utilities/dwi_eddy_qc.sh
}

# -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
# -- dwi_parcellate - Executes the Diffusion Parcellation Script (dwi_parcellate.sh) via the QuNex bash wrapper
# -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

dwi_parcellate() {
    # -- Specify command variable
    QuNexCallToRun=". ${TOOLS}/${QUNEXREPO}/bash/qx_utilities/dwi_parcellate.sh \
    --sessionsfolder=${SessionsFolder} \
    --session=${CASE} \
    --matrixversion=${MatrixVersion} \
    --parcellationfile=${ParcellationFile} \
    --waytotal=${WayTotal} \
    --lengths=${Lengths} \
    --outname=${OutName} \
    --overwrite=${Overwrite}"
    # -- QuNex bash execute function
    bash_call_execute
}

show_usage_dwi_parcellate() {
    echo ""
    echo "qunex ${usage_input}"
    ${TOOLS}/${QUNEXREPO}/bash/qx_utilities/dwi_parcellate.sh
}

# -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
# -- dwi_seed_tractography_dense - Executes the Diffusion Seed Tractography Script (dwi_seed_tractography_dense.sh) via the QuNex bash wrapper
# -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

dwi_seed_tractography_dense() {
    # -- Specify command variable
    QuNexCallToRun="dwi_seed_tractography_dense.sh \
    --sessionsfolder="${SessionsFolder}" \
    --sessions="${CASE}" \
    --matrixversion="${MatrixVersion}" \
    --seedfile="${SeedFile}" \
    --waytotal="${WayTotal}" \
    --outname="${OutName}" \
    --overwrite="${Overwrite}""
    # -- QuNex bash execute function
    bash_call_execute
}

show_usage_dwi_seed_tractography_dense() {
    echo "qunex ${usage_input}"
    ${TOOLS}/${QUNEXREPO}/bash/qx_utilities/dwi_seed_tractography_dense.sh
}

# -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
# -- compute_bold_fc - Executes Global Brain Connectivity (GBC) or seed-based functional connectivity (fc_compute_wrapper.sh) via the QuNex bash wrapper
# -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

compute_bold_fc() {
    # -- Check type of run
    OutPath="$OutPathFC"
    if [[ ${RunType} == "individual" ]]; then
        OutPath="${SessionsFolder}/${CASE}/${InputPath}"
        # -- Make sure individual runs default to the original input path location (/images/functional)
        if [[ ${InputPath} == "" ]]; then
            InputPath="${SessionsFolder}/${CASE}/images/functional"
        fi
        # -- Make sure individual runs default to the original input path location (/images/functional)
        if [[ ${OutPath} == "" ]]; then
            OutPath="${SessionsFolder}/${CASE}/${InputPath}"
        fi
    fi
    # -- Check type of connectivity calculation is seed
    if [[ ${Calculation} == "seed" ]]; then
        echo ""
        # -- Specify command variable
        QuNexCallToRun="${TOOLS}/${QUNEXREPO}/bash/qx_utilities/fc_compute_wrapper.sh \
        --sessionsfolder=${SessionsFolder} \
        --calculation=${Calculation} \
        --runtype=${RunType} \
        --sessions=${CASE} \
        --inputfiles=${InputFiles} \
        --inputpath=${InputPath} \
        --extractdata=${ExtractData} \
        --outname=${OutName} \
        --flist=${FileList} \
        --overwrite=${Overwrite} \
        --ignore=${IgnoreFrames} \
        --roinfo=${ROIInfo} \
        --options=${FCCommand} \
        --method=${Method} \
        --targetf=${OutPath} \
        --mask='${MaskFrames}' \
        --covariance=${Covariance}"
        # -- QuNex bash execute function
        bash_call_execute
    fi
    # -- Check type of connectivity calculation is gbc
    if [[ ${Calculation} == "gbc" ]]; then
        echo ""
        # -- Specify command variable
        QuNexCallToRun="${TOOLS}/${QUNEXREPO}/bash/qx_utilities/fc_compute_wrapper.sh \
        --sessionsfolder=${SessionsFolder} \
        --calculation=${Calculation} \
        --runtype=${RunType} \
        --sessions=${CASE} \
        --inputfiles=${InputFiles} \
        --inputpath=${InputPath} \
        --extractdata=${ExtractData} \
        --outname=${OutName} \
        --flist=${FileList} \
        --overwrite=${Overwrite} \
        --ignore=${IgnoreFrames} \
        --target=${TargetROI} \
        --gbc-command=${GBCCommand} \
        --targetf=${OutPath} \
        --mask=${MaskFrames} \
        --rsmooth=${RadiusSmooth} \
        --rdilate=${RadiusDilate} \
        --verbose=${Verbose} \
        --time=${ComputeTime} \
        --vstep=${VoxelStep} \
        --covariance=${Covariance}"
        # -- QuNex bash execute function
        bash_call_execute
    fi
    # -- Check type of connectivity calculation is seed
    if [[ ${Calculation} == "dense" ]]; then
        echo ""
        # -- Specify command variable
        QuNexCallToRun="${TOOLS}/${QUNEXREPO}/bash/qx_utilities/fc_compute_wrapper.sh \
        --sessionsfolder=${SessionsFolder} \
        --calculation=${Calculation} \
        --runtype=${RunType} \
        --sessions=${CASE} \
        --inputfiles=${InputFiles} \
        --inputpath=${InputPath} \
        --outname=${OutName} \
        --overwrite=${Overwrite} \
        --targetf=${OutPath} \
        --covariance=${Covariance} \
        --mem-limit=${MemLimit} "
        # -- QuNex bash execute function
        bash_call_execute
    fi
}

show_usage_compute_bold_fc() {
    echo ""; echo "qunex ${usage_input}"
    ${TOOLS}/${QUNEXREPO}/bash/qx_utilities/fc_compute_wrapper.sh
}

# -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
# -- parcellate_anat - Executes the Structural Parcellation Script (StructuralParcellation.sh) via the QuNex bash wrapper
# -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

parcellate_anat() {
    # -- Parse general parameters
    QUEUE="$QUEUE"
    SessionsFolder="$SessionsFolder"
    CASE=${CASE}
    InputDataType="$InputDataType"
    OutName="$OutName"
    ParcellationFile="$ParcellationFile"
    ExtractData="$ExtractData"
    Overwrite="$Overwrite"
    # -- Specify command variable
    QuNexCallToRun=". ${TOOLS}/${QUNEXREPO}/bash/qx_utilities/parcellate_anat.sh \
    --sessionsfolder=${SessionsFolder} \
    --session=${CASE} \
    --inputdatatype=${InputDataType} \
    --parcellationfile=${ParcellationFile} \
    --overwrite=${Overwrite} \
    --outname=${OutName} \
    --extractdata=${ExtractData}"
    # -- QuNex bash execute function
    bash_call_execute
}

show_usage_parcellate_anat() {
    echo ""; echo "qunex ${usage_input}"
    ${TOOLS}/${QUNEXREPO}/bash/qx_utilities/parcellate_anat.sh
}

# -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
# -- parcellate_bold - Executes the BOLD Parcellation Script (parcellate_bold.sh) via the QuNex bash wrapper
# -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

parcellate_bold() {
    # -- Parse general parameters
    if [[ -z ${SingleInputFile} ]]; then
        BOLDOutput="${SessionsFolder}/${CASE}/${OutPath}"
    else
        BOLDOutput="${OutPath}"
    fi
    # -- Specify command variable
    QuNexCallToRun=". ${TOOLS}/${QUNEXREPO}/bash/qx_utilities/parcellate_bold.sh \
    --sessionsfolder='${SessionsFolder}' \
    --sessions='${CASE}' \
    --inputfile='${InputFile}' \
    --singleinputfile='${SingleInputFile}' \
    --inputpath='${InputPath}' \
    --inputdatatype='${InputDataType}' \
    --parcellationfile='${ParcellationFile}' \
    --overwrite='${Overwrite}' \
    --outname='${OutName}' \
    --outpath='${OutPath}' \
    --computepconn='${ComputePConn}' \
    --extractdata='${ExtractData}' \
    --useweights='${UseWeights}' \
    --weightsfile='${WeightsFile}'"
    # -- QuNex bash execute function
    bash_call_execute
}

show_usage_parcellate_bold() {
    echo ""; echo "qunex ${usage_input}"
    ${TOOLS}/${QUNEXREPO}/bash/qx_utilities/parcellate_bold.sh
}

# -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
# -- extract_roi - Executes the ROI Extraction Script (extract_roi.sh) via the QuNex bash wrapper
# -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

extract_roi() {
    # -- Specify command variable
    QuNexCallToRun=". ${TOOLS}/${QUNEXREPO}/bash/qx_utilities/extract_roi.sh \
    --roifile='${ROIFile}' \
    --inputfile='${InputFile}' \
    --outpath='${OutPath}' \
    --outname='${OutName}'"

    # -- QuNex bash execute function
    bash_call_execute
}

show_usage_extract_roi() {
    echo ""
    echo "qunex ${usage_input}"
    ${TOOLS}/${QUNEXREPO}/bash/qx_utilities/extract_roi.sh
}

# ------------------------------------------------------------------------------------------------------
# -- dwi_dtifit - Executes the dtifit script from FSL (needed for probabilistic tractography)
# ------------------------------------------------------------------------------------------------------

dwi_dtifit() {
    # -- Parse optional parameters
    optional_parameters=""

    # mask
    if [[ -n ${mask} ]]; then
        optional_parameters="    --mask='${mask}'"
    fi

    # bvecs
    if [[ -n ${bvecs} ]]; then
        optional_parameters="${optional_parameters}    --bvecs='${bvecs}'"
    fi

    # bvals
    if [[ -n ${bvals} ]]; then
        optional_parameters="${optional_parameters}     --bvals='${bvals}'"
    fi

    # cni
    if [[ -n ${cni} ]]; then
        optional_parameters="${optional_parameters}    --cni='${cni}'"
    fi

    # sse
    if [[ -n ${sse} ]]; then
        optional_parameters="${optional_parameters}    --sse"
    fi

    # wls
    if [[ -n ${wls} ]]; then
        optional_parameters="${optional_parameters}    --wls"
    fi

    # kurt
    if [[ -n ${kurt} ]]; then
        optional_parameters="${optional_parameters}    --kurt"
    fi

    # kurtdir
    if [[ -n ${kurtdir} ]]; then
        optional_parameters="${optional_parameters}    --kurtdir"
    fi

    # littlebit
    if [[ -n ${littlebit} ]]; then
        optional_parameters="${optional_parameters}    --littlebit"
    fi

    # save_tensor
    if [[ -n ${save_tensor} ]]; then
        optional_parameters="${optional_parameters}    --save_tensor"
    fi

    # zmin
    if [[ -n ${zmin} ]]; then
        optional_parameters="${optional_parameters}    --zmin='${zmin}'"
    fi

    # zmax
    if [[ -n ${zmax} ]]; then
        optional_parameters="${optional_parameters}    --zmax='${zmax}'"
    fi

    # ymin
    if [[ -n ${ymin} ]]; then
        optional_parameters="${optional_parameters}    --ymin='${ymin}'"
    fi

    # ymax
    if [[ -n ${ymax} ]]; then
        optional_parameters="${optional_parameters}    --ymax='${ymax}'"
    fi

    # xmin
    if [[ -n ${xmin} ]]; then
        optional_parameters="${optional_parameters}    --xmin='${xmin}'"
    fi

    # xmax
    if [[ -n ${xmax} ]]; then
        optional_parameters="${optional_parameters}    --xmax='${xmax}'"
    fi

    # gradnonlin
    if [[ -n ${gradnonlin} ]]; then
        optional_parameters="${optional_parameters}    --gradnonlin='${gradnonlin}'"
    fi

    # diffdata
    if [[ -n ${diffdata} ]]; then
        optional_parameters="${optional_parameters}    --diffdata='${diffdata}'"
    fi

    # -- Specify command variable
    QuNexCallToRun=". ${TOOLS}/${QUNEXREPO}/bash/qx_utilities/dwi_dtifit.sh \
    --sessionsfolder='${SessionsFolder}' \
    --session='${CASE}' \
    --overwrite='${Overwrite}' \
    --species='${Species}' ${optional_parameters}"

    # -- QuNex bash execute function
    bash_call_execute
}

show_usage_dwi_dtifit() {
    echo ""; echo "qunex ${usage_input}"
    ${TOOLS}/${QUNEXREPO}/bash/qx_utilities/dwi_dtifit.sh
}

# ------------------------------------------------------------------------------------------------------
# -- dwi_bedpostx_gpu - Executes the bedpostx_gpu code from FSL (needed for probabilistic tractography)
# ------------------------------------------------------------------------------------------------------

dwi_bedpostx_gpu() {
    # -- Specify command variable
    QuNexCallToRun=". ${TOOLS}/${QUNEXREPO}/bash/qx_utilities/dwi_bedpostx_gpu.sh \
    --sessionsfolder='${SessionsFolder}' \
    --session='${CASE}' \
    --fibers='${Fibers}' \
    --weight='${Weight}' \
    --burnin='${Burnin}' \
    --jumps='${Jumps}' \
    --sample='${Sample}' \
    --model='${Model}' \
    --rician='${Rician}' \
    --gradnonlin='${Gradnonlin}' \
    --overwrite='${Overwrite}' \
    --species='${Species}' \
    --nogpu='${nogpu}'"

    # -- QuNex bash execute function
    bash_call_execute
}

show_usage_dwi_bedpostx_gpu() {
    echo ""; echo "qunex ${usage_input}"
    ${TOOLS}/${QUNEXREPO}/bash/qx_utilities/dwi_bedpostx_gpu.sh
}

# ------------------------------------------------------------------------------------------------------------------------------
# -- auto_ptx - Executes the auto_ptx script from FSL (needed for probabilistic estimation of large-scale fiber bundles / tracts)
# -------------------------------------------------------------------------------------------------------------------------------

auto_ptx() {
    echo "WARNING: auto_ptx is deprecated, you should probably use dwi_xtract instead!"

    # -- Check inputs
    if [[ -d ${BedPostXFolder} ]]; then
        echo "ERROR: Prior BedpostX run not found or incomplete for $CASE. Check work and re-run."
        exit 1
    fi
    if [[ -z ${AutoPtxFolder} ]]; then
        echo "ERROR: AutoPtxFolder environment variable not. Set it correctly and re-run."
        exit 1
    fi
    # -- Set commands
    Com1="${AutoPtxFolder}/autoptx ${SessionsFolder} ${CASE} ${BedPostXFolder}"
    Com2="${AutoPtxFolder}/prepare_for_display.sh ${StudyFolder}/${CASE}/MNINonLinear/Results/autoptx 0.005 1"
    Com3="${AutoPtxFolder}/prepare_for_display.sh ${StudyFolder}/${CASE}/MNINonLinear/Results/autoptx 0.005 0"
    # -- Specify command variable
    QuNexCallToRun="${Com1}; ${Com2}; ${Com3}"
    # -- QuNex bash execute function
    bash_call_execute
}

show_usage_auto_ptx() {
    echo ""
    echo "qunex ${usage_input} "
    echo ""
    echo "This command runs the auto_ptx script in ${AutoPtxFolder}."
    echo ""
    echo "For full details on auto_ptx functionality see: https://fsl.fmrib.ox.ac.uk/fsl/fslwiki/AutoPtx"
    echo ""
}

# -------------------------------------------------------------------------------------------------------------------
# -- Executes the HCP Pretractography (dwi_pre_tractography) [ Stam's implementation for all grayordinates ]
# ------------------------------------------------------------------------------------------------------------------

dwi_pre_tractography() {
    # -- Parse general parameters
    RunFolder="${SessionsFolder}/${CASE}/hcp/"
    # -- Specify command variable
    QuNexCallToRun="${TOOLS}/${QUNEXREPO}/bash/qx_utilities/dwi_pre_tractography.sh ${RunFolder} ${CASE} 0"
    # -- QuNex bash execute function
    bash_call_execute
}

show_usage_dwi_pre_tractography() {
    echo ""; echo "qunex ${usage_input}"
    ${TOOLS}/${QUNEXREPO}/bash/qx_utilities/dwi_pre_tractography.sh
}

# --------------------------------------------------------------------------------------------------------------------------------------------------
# -- dwi_probtrackx_dense_gpu - Executes the HCP Matrix1 and / or 3 code and generates WB dense connectomes (Stam's implementation for all grayordinates)
# --------------------------------------------------------------------------------------------------------------------------------------------------

dwi_probtrackx_dense_gpu() {
    # -- Specify command variable
    QuNexCallToRun=". ${TOOLS}/${QUNEXREPO}/bash/qx_utilities/dwi_probtrackx_dense_gpu.sh \
    --sessionsfolder='${SessionsFolder}' \
    --session='${CASE}' \
    --scriptsfolder='${ScriptsFolder}' \
    --omatrix1='${MatrixOne}' \
    --omatrix3='${MatrixThree}' \
    --nsamplesmatrix1='${NsamplesMatrixOne}' \
    --nsamplesmatrix3='${NsamplesMatrixThree}' \
    --distancecorrection='${distance_correction}' \
    --storestreamlineslength='${store_streamlines_length}' \
    --forcematrix1='${force_matrix1}' \
    --overwrite='${Overwrite}' \
    --nogpu='${nogpu}'"
    # -- QuNex bash execute function
    bash_call_execute
}
show_usage_dwi_probtrackx_dense_gpu() {
    echo ""; echo "qunex ${usage_input}"
    ${TOOLS}/${QUNEXREPO}/bash/qx_utilities/dwi_probtrackx_dense_gpu.sh
}

# ------------------------------------------------------------------------------------------------------------------------------
# -- run_qc - Performs various QC operations across modalities
# -------------------------------------------------------------------------------------------------------------------------------

run_qc() {
    # -- Check general output folders for QC
    if [ ! -d ${SessionsFolder}/QC ]; then
        mkdir -p ${SessionsFolder}/QC &> /dev/null
    fi
    # -- Check T1w output folders for QC
    if [ ! -d ${OutPath} ]; then
        mkdir -p ${OutPath} &> /dev/null
    fi
    # -- Specify command variable
    QuNexCallToRun=". ${TOOLS}/${QUNEXREPO}/bash/qx_utilities/run_qc.sh \
    --sessionsfolder='${SessionsFolder}' \
    --sessions='${CASE}' \
    --outpath='${OutPath}' \
    --overwrite='${Overwrite}' \
    --scenetemplatefolder='${scenetemplatefolder}' \
    --modality='${Modality}' \
    --datapath='${GeneralSceneDataPath}' \
    --datafile='${GeneralSceneDataFile}' \
    --customqc=${runQC_Custom} \
    --omitdefaults=${OmitDefaults} \
    --dwipath='${DWIPath}' \
    --dwidata='${DWIData}' \
    --dtifitqc='${DtiFitQC}' \
    --bedpostxqc='${BedpostXQC}' \
    --eddyqcstats='${EddyQCStats}' \
    --bolddata='${BOLDLIST}' \
    --boldprefix='${BOLDPrefix}' \
    --boldsuffix='${BOLDSuffix}' \
    --skipframes='${SkipFrames}' \
    --snronly='${SNROnly}' \
    --timestamp='${TimeStamp}' \
    --scenezip='${SceneZip}' \
    --boldfc='${BOLDfc}' \
    --boldfcinput='${BOLDfcInput}' \
    --boldfcpath='${BOLDfcPath}' \
    --suffix='${Suffix}' \
    --hcp_suffix='${HCPSuffix}' \
    --batchfile='${BATCH_FILE}' \
    --sourcefile='${sourcefile}' \
    --hcp_filename='${hcp_filename}'"
    # -- QuNex bash execute function
    bash_call_execute
}

show_usage_run_qc() {
    echo ""; echo "qunex ${usage_input}"
    ${TOOLS}/${QUNEXREPO}/bash/qx_utilities/run_qc.sh
}

# =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-==-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-==-=-
# =-=-=-=-=-==-=-=-= Establish general QuNex functions and variables =-=-=-=-=-=
# =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-==-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-==-=-

# ------------------------------------------------------------------------------
# -- Capture current working directory
# ------------------------------------------------------------------------------
dirs -c  > /dev/null
pushd `pwd` > /dev/null

# ------------------------------------------------------------------------------
# -- Load relevant libraries for logging and parsing options
# ------------------------------------------------------------------------------
if [[ ! -z $HCPPIPEDIR ]]; then
    source $HCPPIPEDIR/global/scripts/log.shlib  # -- Logging related functions
    source $HCPPIPEDIR/global/scripts/opts.shlib # -- Command line option functions
fi

# ------------------------------------------------------------------------------
# -- Load Core Functions
# ------------------------------------------------------------------------------

# -- Parses the input command line for a specified command line option
# -- The first parameter is the command line option to look for.
# -- The remaining parameters are the full list of flagged command line arguments
get_parameters() {
    sopt="$1"
    shift 1
    for fn in "$@" ; do
        if [ `echo $fn | grep -- "^${sopt}=" | wc -w` -gt 0 ]; then
            echo $fn | sed "s/^${sopt}=//"
            return 0
        fi
    done
}

# -- Same as above except this works on flags
get_flags() {
    sopt="$1"
    shift 1
    for fn in "$@" ; do
        if [ `echo $fn | grep -- "^${sopt}" | wc -w` -gt 0 ]; then
            echo "yes"
            return 0
        fi
    done
}

# -- Checks for version
show_version() {
    QuNexVer=`cat ${TOOLS}/${QUNEXREPO}/VERSION.md`
    echo "Quantitative Neuroimaging Environment & Toolbox (QuNex) Suite Version: ${QuNexVer}"
}

# ------------------------------------------------------------------------------
# -- Parse Command Line Options
# ------------------------------------------------------------------------------

# -- Check if version was requested
if [ "$1" == "-version" ] || [ "$1" == "version" ] || [ "$1" == "--version" ] || [ "$1" == "--v" ] || [ "$1" == "-v" ]; then
    show_version
    echo ""
    exit 0
fi

# -- Check if splash was requested
if [ "$1" == "-splash" ] || [ "$1" == "splash" ] || [ "$1" == "--splash" ] || [ "$1" == "--s" ] || [ "$1" == "-s" ]; then
    show_splash
    echo ""
    exit 0
fi

if [[ -z ${1} ]]; then
    show_splash
    show_usage
    exit 0
fi

if [[ ${1} == "help" ]]; then
    show_splash
    show_usage
    exit 0
fi

if [[ ${1} == "--envsetup" ]] || [[ ${1} == "-envsetup" ]] || [[ ${1} == "envsetup" ]]; then
    show_version
    echo ""
    echo "Printing help call for $TOOLS/$QUNEXREPO/env/qunex_environment.sh"
    echo ""
    bash ${TOOLS}/$QUNEXREPO/env/qunex_environment.sh --help
    exit 0
fi

# -- Set and report version
QuNexVer=`cat ${TOOLS}/${QUNEXREPO}/VERSION.md`
echo ""
echo ".......................... Running QuNex v${QuNexVer} .........................."
echo ""

# ------------------------------------------------------------------------------
# -- gmri outside local commands to bypass checking
# ------------------------------------------------------------------------------

# -- Get list of all supported gmri commands
gmri_commands=`gmri -available`
# -- Check if command-line input matches any of the gmri commands
unset qxutil_command_to_run
is_gmri_command=0
for gmri_command in $gmri_commands; do
    if [[ $gmri_command == $1 ]]; then
        is_gmri_command=1
    fi
done

if [[ $is_gmri_command == 1 ]]; then
    # -- If yes then set the gmri function variable
    qxutil_command_to_run="$1"

    # -- Handle input parameters
    unset gmriinput

    for inputarg in "$@"; do
        #  parameters
        if [[ ${inputarg} =~ '=' ]]; then
            if [[ $inputarg =~ "\"" ]]; then
                inputarg=${inputarg/=/=\'}\'
            else
                inputarg=${inputarg/=/=\"}\"
            fi
        fi

        # flags
        if [[ -z $gmriinput ]]; then
            gmriinput="${inputarg}"
        else
            gmriinput="${gmriinput} ${inputarg}"
        fi
    done

    # execute
    bash_call_execute

    exit 0
else
    unset qxutil_command_to_run
fi

# ------------------------------------------------------------------------------
# -- Map deprecated commands
# ------------------------------------------------------------------------------

# -- Use the check_deprecated_commands from niutilities to remap
if [[ $1 != --* ]]; then
    # grep the command
    deprecation=`gmri check_deprecated_commands --command="$1"`
    # print and set new command if something was deprecated
    if [[ -n $deprecation ]]; then
        echo ""
        echo $deprecation
        command_name=`echo $deprecation | grep "is now known as" | sed 's/^.*is now known as //g'`
        if [[ -n $command_name ]]; then
            set -- ${command_name} "${@:2}"
        fi
    fi
fi

# ------------------------------------------------------------------------------
# -- Check if specific command help requested
# ------------------------------------------------------------------------------

# -- Check if command is supported
is_qunex_command() {
    # check if qunex bash command
    is_qunex_command=0
    for qunex_command in $qunex_commands; do
        if [[ $qunex_command == $1 ]]; then
            is_qunex_command=1
            break
        fi
    done
    if [[ $is_qunex_command == 0 ]]; then
        echo ""
        echo "ERROR: $1 ---> Requested command is not supported. Refer to general QuNex usage."
        echo ""
        exit 0
    fi
}

# -- Check for input with double flags
if [[ ${1} =~ .*--.* ]] && [[ -z ${2} ]] || [[ ${1} =~ .*-.* ]] && [[ -z ${2} ]]; then
    Usage="$1"
    if [[ ${Usage} == "--a" ]] || [[ ${Usage} == "--all" ]] || [[ ${Usage} == "--allcommands" ]]; then
        show_all_qunex_commands
        exit 0
    fi
fi

# -- Check for input with single flags
if [[ ${1} =~ .*-.* ]] && [[ -z ${2} ]]; then
    Usage="$1"
    if [[ ${Usage} == "-a" ]] || [[ ${Usage} == "-all" ]] || [[ ${Usage} == "-allcommands" ]]; then
        show_all_qunex_commands
        exit 0
    fi
fi

# -- Check if there is no command or parameters
if [[ "$#" -lt 2 ]]; then
    echo "--------------------------------- QuNex failed ---------------------------------"
    echo ""
    echo "ERROR: No input parameters found! You can use the --help flag to request help for a specific command."
    echo ""
    exit 1
fi

# -- Check if one of the flags is h, H or help
for fn in "$@" ; do
    if [[ ${fn} == "-h" ]] || [[ ${fn} == "--h" ]] || [[ ${fn} == "-H" ]] || [[ ${fn} == "--H" ]] || [[ ${fn} == "--help" ]] || [[ ${fn} == "-help" ]]; then
        # -- Check if input part of function list
        is_qunex_command ${1}
        show_version
        echo ""
        show_usage_"${1}"
        exit 0
    fi
done

# -- check if it is a valid qunex command
is_qunex_command ${1}

# ------------------------------------------------------------------------------
# -- Check if running script interactively or using flag arguments
# ------------------------------------------------------------------------------

# -- Clear variables for new run
unset CommandToRun
unset sessions
unset StudyFolder
unset CASES
unset Overwrite
unset Scheduler
unset ClusterName
unset setflag
unset doubleflag
unset singleflag
unset SESSIONIDS
unset SESSIONS
unset SESSION_LABELS

# -- Check if first parameter is missing flags and parse it as CommandToRun
if [ -z `echo "$1" | grep '-'` ]; then
    CommandToRun="$1"
    # -- Check if single or double flags are set
    doubleflagparameter=`echo $2 | cut -c1-2`
    singleflagparameter=`echo $2 | cut -c1`
    if [[ ${doubleflagparameter} == "--" ]]; then
        setflag="$doubleflagparameter"
    else
        if [[ ${singleflagparameter} == "-" ]]; then
            setflag="$singleflagparameter"
        fi
    fi
else
    # -- Check if single or double flags are set
    doubleflag=`echo $1 | cut -c1-2`
    singleflag=`echo $1 | cut -c1`
    if [[ ${doubleflag} == "--" ]]; then
        setflag="$doubleflag"
    else
        if [[ ${singleflag} == "-" ]]; then
            setflag="$singleflag"
        fi
    fi
fi

# -- Check if command is run_turnkey and set arguments
if [[ ${CommandToRun} == "run_turnkey" ]]; then
    runTurnkeyArguments="$@"
    runTurnkeyArguments=`printf '%s\n' "${runTurnkeyArguments//run_turnkey/}"`
fi

# -- Next check if any additional flags are set
if [[ ${setflag} =~ .*-.* ]]; then
    echo ""
    # -- First get function / command input (to harmonize input with gmri)
    if [[ -z ${CommandToRun} ]]; then
        FunctionInput=`get_parameters "${setflag}function" "$@"` # function to execute
        CommandInput=`get_parameters "${setflag}command" "$@"`   # command to execute
        # -- If input name uses 'command' instead of function set that to $CommandToRun
        if [[ -z ${FunctionInput} ]]; then
            CommandToRun="$CommandInput"
        else
            CommandToRun="$FunctionInput"
        fi
    fi
    # -- StudyFolder & SessionsFolder input flags
    StudyFolder=`get_parameters "${setflag}studyfolder" $@`                      # study folder to work on
    if [[ -z ${StudyFolder} ]]; then
        StudyFolder=`get_parameters "${setflag}path" $@`                         # local folder to work on
    fi
    StudyFolderPath="${StudyFolder}"
    STUDY_PATH="${StudyFolder}"

    SessionsFolder=`get_parameters "${setflag}sessionsfolder" $@`                # sessions folder path to work on
    if [[ -z ${SessionsFolder} ]]; then
       SessionsFolder=`get_parameters "${setflag}sessionfolder"  $@`                # sessions folder path to work on
    fi
    # -- backwards compatibility -- sessionsfolder used to be supported by --subjectsfolder or --subjectfolder
    if [[ -z ${SessionsFolder} ]]; then
        SubjectFolder=`get_parameters "${setflag}subjectsfolder" $@`
        SessionsFolder="${SubjectFolder}"
        if [[ ! -z ${SubjectFolder} ]]; then
            echo "WARNING: The --subjectsfolder parameter is now renamed to --sessionsfolder"
        fi
    fi
    if [[ -z ${SessionsFolder} ]]; then
        SubjectFolder=`get_parameters "${setflag}subjectfolder" $@`
        SessionsFolder="${SubjectFolder}"
        if [[ ! -z ${SubjectFolder} ]]; then
            echo "WARNING: The --subjectfolder parameter is now renamed to --sessionsfolder"
        fi
    fi

    # -- Check StudyFolder and set
    if [[ -z ${StudyFolder} ]] && [[ ! -z ${StudyFolderPath} ]]; then
        StudyFolder="$StudyFolderPath"
        STUDY_PATH="${StudyFolderPath}"
    fi
    if [[ ! -z ${StudyFolder} ]] && [[ -z ${StudyFolderPath} ]]; then
        StudyFolderPath="$StudyFolder"
        STUDY_PATH="${StudyFolder}"
    fi

    # -- If study folder is missing but sessions folder is defined assume standard QuNex folder structure
    if [[ -z ${StudyFolder} ]]; then
        if [[ ! -z ${SessionsFolder} ]] && [[ -d ${SessionsFolder} ]]; then
            StudyFolder="$(dirname "$SessionsFolder")"

            StudyFolderPath="${StudyFolder}"
            STUDY_PATH="${StudyFolder}"
        else
            StudyFolder=`echo ${SessionsFolder%/*}`
            if [[ -d ${StudyFolder} ]]; then
                SessionsFolderName=`basename ${SessionsFolder}`
                echo ""
                echo "WARNING: ${StudyFolder}/${SessionsFolderName} is not present."
                echo ""
                echo "    ---> Found: ${StudyFolder}"
                SessionsFolderName="sessions"
                SessionsFolder="${StudyFolder}/${SessionsFolderName}"
            fi
            if [ ! -d ${SessionsFolder} ]; then
                echo ""
                echo ""
                echo "ERROR: Study folder or sessions folder is not defined or missing."
                echo "       Check your inputs and re-run QuNex."
                echo ""
                exit 1
            fi
        fi
    fi

    # -- Check if SessionsFolderName and SessionsFolder match
    if [[ ! -z ${SessionsFolder} ]] && [[ ! -z ${SessionsFolderName} ]]; then
        SessionsFolderBase=`basename ${SessionsFolder}`
        if [[ ${SessionsFolderBase} != ${SessionsFolderName} ]]; then
            echo "WARNING: Sessions folder base is mismatching the --sessionsfoldername input."
            echo ""
            echo "    ---> Aligning variables to match ${SessionsFolder}"
            SessionsFolderName=`basename ${SessionsFolder}`
            echo "    ---> Session folder name set to: ${SessionsFolderName}"
            echo ""
        fi
    fi

    # -- If sessions folder is missing but study folder is defined assume standard QuNex folder structure
    if [[ -z ${SessionsFolder} ]]; then
       if [[ -z ${SessionsFolderName} ]]; then
           SessionsFolderName="sessions"
           if [[ ! -z ${SubjectFolder} ]]; then
               SessionsFolder="${SubjectFolder}"
           fi
           if [[ -z ${StudyFolder} ]]; then
               echo "" &> /dev/null
           else
               SessionsFolder="$StudyFolder/$SessionsFolderName"
           fi
       fi
    fi

    # -- If session folder name is missing but absolute path sessions folder is defined assume standard QuNex folder structure or check basename
    if [[ -z ${SessionsFolderName} ]]; then
        if [[ -z ${SessionsFolder} ]]; then
            SessionsFolderName="sessions"
            if [[ ! -z ${StudyFolder} ]]; then
                SessionsFolder="${StudyFolder}/${SessionsFolderName}"
            else
                echo "" &> /dev/null
            fi
        else
            SessionsFolderName=`basename ${SessionsFolder}`
        fi
    fi

    # -- Set study path
    if [[ -z ${STUDY_PATH} ]]; then
         STUDY_PATH=${StudyFolder}
    fi
    if [[ -z ${StudyFolderPath} ]]; then
         StudyFolderPath=${StudyFolder}
    fi

    # -- If logfolder flag set then set it and set master log
    if [[ -z ${LogFolder} ]]; then
        LogFolder="${StudyFolder}/processing/logs"
    fi

    # -- Set additional RunTurnkey flags
    TURNKEY_TYPE=`get_parameters "${setflag}turnkeytype" $@`
    TURNKEY_STEPS=`get_parameters "${setflag}turnkeysteps" $@`
    WORKDIR=`get_parameters "${setflag}workingdir" $@`
    PROJECT_NAME=`get_parameters "${setflag}projectname" $@`
    CleanupSession=`get_parameters "${setflag}cleanupsession" $@`
    CleanupProject=`get_parameters "${setflag}cleanupproject" $@`
    RawDataInputPath=`get_parameters "${setflag}rawdatainput" $@`
    OVERWRITE_SESSION=`get_parameters "${setflag}overwritesession" $@`
    OVERWRITE_STEP=`get_parameters "${setflag}overwritestep" $@`
    OVERWRITE_PROJECT=`get_parameters "${setflag}overwriteproject" $@`
    OVERWRITE_PROJECT_FORCE=`get_parameters "${setflag}overwriteprojectforce" $@`
    OVERWRITE_PROJECT_XNAT=`get_parameters "${setflag}overwriteprojectxnat" $@`
    LOCAL_BATCH_FILE=`get_parameters "${setflag}local_batchfile" $@`
    BATCH_FILE=`get_parameters "${setflag}batchfile" $@`
    SCAN_MAPPING_FILENAME=`get_parameters "${setflag}mappingfile" $@`
    XNAT_ACCSESSION_ID=`get_parameters "${setflag}xnataccsessionid" $@`
    XNAT_SESSION_LABELS=`get_parameters "${setflag}xnatsessionlabels" "$@" | sed 's/,/ /g;s/|/ /g'`; XNAT_SESSION_LABELS=`echo "${XNAT_SESSION_LABELS}" | sed 's/,/ /g;s/|/ /g'`
    XNAT_PROJECT_ID=`get_parameters "${setflag}xnatprojectid" $@`
    XNAT_SUBJECT_ID=`get_parameters "${setflag}xnatsubjectid" $@`
    XNAT_HOST_NAME=`get_parameters "${setflag}xnathost" $@`
    XNAT_USER_NAME=`get_parameters "${setflag}xnatuser" $@`
    XNAT_PASSWORD=`get_parameters "${setflag}xnatpass" $@`
    XNAT_STUDY_INPUT_PATH=`get_parameters "${setflag}xnatstudyinputpath" $@`

    # -- Get sessions from batchfile?
    if [[ -n ${BATCH_FILE} ]]; then
        CASES=${BATCH_FILE}
    fi

    # -- General sessions and sessionids flags
    SESSIONS=`get_parameters "${setflag}sessions" "$@" | sed 's/,/ /g;s/|/ /g'`; CASES=`echo "$CASES" | sed 's/,/ /g;s/|/ /g'`
    if [[ -z ${CASES} ]]; then
        if [[ ! -z ${SESSIONS} ]]; then
            CASES="$SESSIONS"
            SESSIONS="$SESSIONS"
        fi
    fi

    # list of input cases; removing comma or pipes
    SESSIONIDS=`get_parameters "${setflag}sessionids" "$@" | sed 's/,/ /g;s/|/ /g'`; SESSIONIDS=`echo "$SESSIONIDS" | sed 's/,/ /g;s/|/ /g'` # list of input cases; removing comma or pipes
    if [[ -z ${CASES} ]]; then
        if [[ ! -z ${SESSIONIDS} ]]; then
            CASES="$SESSIONIDS"
            SESSIONS="$SESSIONIDS"
        fi
    fi

    # -- Backwards compatibility, sessionids* used to be subjid*
    if [[ -z ${CASES} ]]; then
        if [[ -z ${SESSIONIDS} ]]; then
            SESSIONIDS=`get_parameters "${setflag}subjid" "$@" | sed 's/,/ /g;s/|/ /g'`; SESSIONIDS=`echo "$SESSIONIDS" | sed 's/,/ /g;s/|/ /g'` # list of input cases; removing comma or pipes
            SESSIONS="$SESSIONIDS"
            CASES="$SESSIONS"
            if [[ ! -z ${SESSIONIDS} ]]; then
                echo "WARNING: The --subjid parameter is now renamed to  --sessionids"
            fi
        fi
    fi

    # -- Backwards compatibility for session labels
    if [[ -z ${CASES} ]]; then
        if [[ -z ${SESSION_LABELS} ]]; then
            SESSION_LABELS=`get_parameters "--session" "$@" | sed 's/,/ /g;s/|/ /g'`; SESSION_LABELS=`echo "$SESSION_LABELS" | sed 's/,/ /g;s/|/ /g'`
            SESSIONS="$SESSION_LABELS"
            CASES="$SESSION_LABELS"
            SESSIONIDS="$SESSION_LABELS"
        fi
    fi

    # -- Backwards compatibility for session labels
    if [[ -z ${CASES} ]]; then
        if [[ -z ${SESSION_LABELS} ]]; then
            SESSION_LABELS=`get_parameters "--sessionlabels" "$@" | sed 's/,/ /g;s/|/ /g'`; SESSION_LABELS=`echo "$SESSION_LABELS" | sed 's/,/ /g;s/|/ /g'`
            SESSIONS="$SESSION_LABELS"
            CASES="$SESSION_LABELS"
            SESSIONIDS="$SESSION_LABELS"
        fi
    fi

    # -- Backwards compatibility for session labels
    if [[ -z ${CASES} ]]; then
        if [[ -z ${SESSION_LABELS} ]]; then
            SESSION_LABELS=`get_parameters "--sessions" "$@" | sed 's/,/ /g;s/|/ /g'`; SESSION_LABELS=`echo "$SESSION_LABELS" | sed 's/,/ /g;s/|/ /g'`
            SESSIONS="$SESSION_LABELS"
            CASES="$SESSION_LABELS"
            SESSIONIDS="$SESSION_LABELS"
        fi
    fi

    # -- Filter sessions if we are inside a SLURM array
    if [[ -n ${SLURM_ARRAY_TASK_ID} ]]; then
        SESSION_LABELS=`gmri get_sessions_for_slurm_array --sessions="${CASES}" --sessionids="${SESSIONIDS}"`
        echo "---> SLURM array ${SLURM_ARRAY_TASK_ID}, running over sessions: ${SESSION_LABELS}"
        echo ""
        SESSIONS="${SESSION_LABELS}"
        CASES="${SESSION_LABELS}"
        SESSIONIDS="${SESSION_LABELS}"
    fi

    # -- General operational flags
    Overwrite=`get_parameters "${setflag}overwrite" $@`  # Clean prior run and starr fresh [yes/no]
    if [[ -z ${Overwrite} ]]; then
        Overwrite=`get_flags "${setflag}overwrite" $@`  # Clean prior run and starr fresh [yes/no]
    fi
    PRINTCOM=`get_parameters "${setflag}printcom" $@`    # Option for printing the entire command
    Scheduler=`get_parameters "${setflag}scheduler" $@`  # Specify the type of scheduler to use
    Bash=`get_parameters "${setflag}bash" "$@"`          # Specify bash commands to run on the compute node
    LogFolder=`get_parameters "${setflag}logfolder" $@`  # Log location
    LogSave=`get_parameters "${setflag}log" $@`          # Log save

    # -- If log flag set then set it
    if [[ -z ${LogSave} ]] || [[ ${LogSave} == "yes" ]]; then
        LogSave="keep"
    fi

    # -- If log flag set to no then remove it
    if [[ ${LogSave} == "no" ]]; then
        LogSave="remove"
    fi

    # omp threads
    omp_threads=`get_parameters "${setflag}omp_threads" $@`
    if [[ -n ${omp_threads} ]]; then
        export OMP_NUM_THREADS=${omp_threads}
    fi

    # -- If scheduler flag set then set RunMethod variable
    if [[ ! -z ${Scheduler} ]]; then
        RunMethod="2"
    else
        RunMethod="1"
    fi

    # -- Input flags for general_plot_bold_timeseries
    QCPlotElements=`get_parameters "${setflag}qcplotelements" $@`
    QCPlotImages=`get_parameters "${setflag}qcplotimages" $@`
    QCPlotMasks=`get_parameters "${setflag}qcplotmasks" $@`

    # -- Path options for FreeSurfer or QuNex
    FreeSurferHome=`get_parameters "${setflag}hcp_freesurfer_home" $@`
    QuNexVersion=`get_parameters "${setflag}version" $@`

    # -- Input flags for create_list
    ListGenerate=`get_parameters "${setflag}listtocreate" $@`
    Append=`get_parameters "${setflag}append" $@`
    ListName=`get_parameters "${setflag}listname" $@`
    HeaderBatch=`get_parameters "${setflag}headerbatch" $@`
    ListFunction=`get_parameters "${setflag}listfunction" $@`
    ParcellationFile=`get_parameters "${setflag}parcellationfile" $@`
    FileType=`get_parameters "${setflag}filetype" $@`
    BoldSuffix=`get_parameters "${setflag}boldsuffix" $@`
    SessionHCPFile=`get_parameters "${setflag}sessionhcpfile" $@`
    ListPath=`get_parameters "${setflag}listpath" $@`

    # -- Input flags for extract_roi
    ROIFile=`get_parameters "${setflag}roifile" $@`

    # -- Input flags for compute_bold_fc
    InputFiles=`get_parameters "${setflag}inputfiles" $@`
    OutPathFC=`get_parameters "${setflag}targetf" $@`
    Calculation=`get_parameters "${setflag}calculation" $@`
    RunType=`get_parameters "${setflag}runtype" $@`
    FileList=`get_parameters "${setflag}flist" $@`
    IgnoreFrames=`get_parameters "${setflag}ignore" $@`
    MaskFrames=`get_parameters "${setflag}mask" "$@"`
    Covariance=`get_parameters "${setflag}covariance" $@`
    TargetROI=`get_parameters "${setflag}target" $@`
    RadiusSmooth=`get_parameters "${setflag}rsmooth" $@`
    RadiusDilate=`get_parameters "${setflag}rdilate" $@`
    GBCCommand=`get_parameters "${setflag}command" $@`
    Verbose=`get_parameters "${setflag}verbose" $@`
    ComputeTime=`get_parameters "${setflag}-time" $@`
    VoxelStep=`get_parameters "${setflag}vstep" $@`
    ROIInfo=`get_parameters "${setflag}roinfo" $@`
    FCCommand=`get_parameters "${setflag}options" $@`
    Method=`get_parameters "${setflag}method" $@`
    MemLimit=`get_parameters "${setflag}mem-limit" $@`

    # -- Input flags for parcellate_bold
    InputFile=`get_parameters "${setflag}inputfile" $@`
    InputPath=`get_parameters "${setflag}inputpath" $@`
    InputDataType=`get_parameters "${setflag}inputdatatype" $@`
    SingleInputFile=`get_parameters "${setflag}singleinputfile" $@`
    OutPath=`get_parameters "${setflag}outpath" $@`
    OutName=`get_parameters "${setflag}outname" $@`
    ExtractData=`get_parameters "${setflag}extractdata" $@`
    ComputePConn=`get_parameters "${setflag}computepconn" $@`
    UseWeights=`get_parameters "${setflag}useweights" $@`
    WeightsFile=`get_parameters "${setflag}weightsfile" $@`
    ParcellationFile=`get_parameters "${setflag}parcellationfile" $@`

    # -- diffusion commands
    nogpu=`get_parameters "${setflag}nogpu" $@`
    if [[ -z ${nogpu} ]]; then
        nogpu="no"
    fi

    # -- Input flags for dwi_legacy_gpu
    EchoSpacing=`get_parameters "${setflag}echospacing" $@`
    pedir=`get_parameters "${setflag}pedir" $@`
    if [[ -z ${pedir} ]]; then
        pedir=`get_parameters "${setflag}PEdir" $@`
    fi
    te=`get_parameters "${setflag}te" $@`
    UnwarpDir=`get_parameters "${setflag}unwarpdir" $@`
    UseFieldmap=`get_parameters "${setflag}usefieldmap" $@`
    diffdatasuffix=`get_parameters "${setflag}diffdatasuffix" $@`

    # -- Input flags for dwi_bedpostx_gpu
    Fibers=`get_parameters "${setflag}fibers" $@`
    Weight=`get_parameters "${setflag}weight" $@`
    Burnin=`get_parameters "${setflag}burnin" $@`
    Jumps=`get_parameters "${setflag}jumps" $@`
    Sample=`get_parameters "${setflag}sample" $@`
    Model=`get_parameters "${setflag}model" $@`
    Rician=`get_parameters "${setflag}rician" $@`
    Gradnonlin=`get_parameters "${setflag}gradnonlin" $@`

    # -- Input flags for dwi_dtifit
    bvecs=`get_parameters "${setflag}bvecs" $@`
    bvals=`get_parameters "${setflag}bvals" $@`
    cni=`get_parameters "${setflag}cni" $@`
    sse=`get_flags "${setflag}sse" $@`
    wls=`get_flags "${setflag}wls" $@`
    kurt=`get_flags "${setflag}kurt" $@`
    kurtdir=`get_flags "${setflag}kurtdir" $@`
    littlebit=`get_flags "${setflag}littlebit" $@`
    save_tensor=`get_flags "${setflag}save_tensor" $@`
    zmin=`get_parameters "${setflag}zmin" $@`
    zmax=`get_parameters "${setflag}zmax" $@`
    ymin=`get_parameters "${setflag}ymin" $@`
    ymax=`get_parameters "${setflag}ymax" $@`
    xmin=`get_parameters "${setflag}xmin" $@`
    xmax=`get_parameters "${setflag}xmax" $@`
    diffdata=`get_parameters "${setflag}diffdata" $@`
    gradnonlin=`get_parameters "${setflag}gradnonlin" $@`

    # -- Input flags for dwi_parcellate
    MatrixVersion=`get_parameters "${setflag}matrixversion" $@`
    ParcellationFile=`get_parameters "${setflag}parcellationfile" $@`
    OutName=`get_parameters "${setflag}outname" $@`
    WayTotal=`get_parameters "${setflag}waytotal" $@`

    # -- Input flags for  dwi_seed_tractography_dense
    SeedFile=`get_parameters "${setflag}seedfile" $@`

    # -- Input flags for dwi_eddy_qc
    EddyBase=`get_parameters "${setflag}eddybase" $@`
    EddyPath=`get_parameters "${setflag}eddypath" $@`
    Report=`get_parameters "${setflag}report" $@`
    BvalsFile=`get_parameters "${setflag}bvalsfile" $@`
    BvecsFile=`get_parameters "${setflag}bvecsfile" $@`
    EddyIdx=`get_parameters "${setflag}eddyidx" $@`
    EddyParams=`get_parameters "${setflag}eddyparams" $@`
    List=`get_parameters "${setflag}list" $@`
    Mask=`get_parameters "${setflag}mask" $@`
    GroupBar=`get_parameters "${setflag}groupvar" $@`
    OutputDir=`get_parameters "${setflag}outputdir" $@`
    Update=`get_parameters "${setflag}update" $@`

    # -- Input flags for dwi_probtrackx_dense_gpu
    MatrixOne=`get_parameters "${setflag}omatrix1" $@`
    MatrixThree=`get_parameters "${setflag}omatrix3" $@`
    NsamplesMatrixOne=`get_parameters "${setflag}nsamplesmatrix1" $@`
    NsamplesMatrixThree=`get_parameters "${setflag}nsamplesmatrix3" $@`
    distance_correction=`get_parameters "--distancecorrection" $@`
    store_streamlines_length=`get_parameters "--storestreamlineslength" $@`
    force_matrix1=`get_parameters "--forcematrix1" $@`
    ScriptsFolder=`get_parameters "${setflag}scriptsfolder" $@`

    # -- Input flags for run_qc
    OutPath=`get_parameters "${setflag}outpath" $@`
    scenetemplatefolder=`get_parameters "${setflag}scenetemplatefolder" $@`
    UserSceneFile=`get_parameters "${setflag}userscenefile" $@`
    UserScenePath=`get_parameters "${setflag}userscenepath" $@`
    Modality=`get_parameters "${setflag}modality" $@`
    runQC_Custom=`get_parameters "${setflag}customqc" $@`
    OmitDefaults=`get_parameters "${setflag}omitdefaults" $@`
    HCPSuffix=`get_parameters "${setflag}hcp_suffix" $@`
    DWIPath=`get_parameters "${setflag}dwipath" $@`
    DWIData=`get_parameters "${setflag}dwidata" $@`
    DtiFitQC=`get_parameters "${setflag}dtifitqc" $@`
    BedpostXQC=`get_parameters "${setflag}bedpostxqc" $@`
    EddyQCStats=`get_parameters "${setflag}eddyqcstats" $@`
    GeneralSceneDataFile=`get_parameters "${setflag}datafile" $@`
    GeneralSceneDataPath=`get_parameters "${setflag}datapath" $@`
    ICAFIXFunction=`get_parameters "${setflag}icafixfunction" $@`
    HPFilter=`get_parameters "${setflag}hpfilter" $@`
    MovCorr=`get_parameters "${setflag}movcorr" $@`
    sourcefile=`get_parameters "${setflag}sourcefile" $@`
    hcp_filename=`get_parameters "${setflag}hcp_filename" $@`

    # -- Code block for BOLDs
    BOLDS=`get_parameters "${setflag}bolds" "$@" | sed 's/,/ /g;s/|/ /g'`; BOLDS=`echo "${BOLDS}" | sed 's/,/ /g;s/|/ /g'`

    if [[ -z ${BOLDS} ]]; then
        BOLDS=`get_parameters "${setflag}boldruns" "$@" | sed 's/,/ /g;s/|/ /g'`; BOLDS=`echo "${BOLDS}" | sed 's/,/ /g;s/|/ /g'`
    fi
    if [[ -z ${BOLDS} ]]; then
        BOLDS=`get_parameters "${setflag}bolddata" "$@" | sed 's/,/ /g;s/|/ /g'`; BOLDS=`echo "${BOLDS}" | sed 's/,/ /g;s/|/ /g'`
    fi
    BOLDRUNS="${BOLDS}"
    BOLDDATA="${BOLDS}"
    BOLDfc=`get_parameters "${setflag}boldfc" $@`
    BOLDfcInput=`get_parameters "${setflag}boldfcinput" $@`
    BOLDfcPath=`get_parameters "${setflag}boldfcpath" $@`
    if [[ -z ${BOLDLIST} ]]; then BOLDLIST=`get_parameters "${setflag}bolddata" "$@"`; fi
    if [[ -z ${BOLDLIST} ]]; then BOLDLIST=`get_parameters "${setflag}bolds" "$@"`; fi
    if [[ -z ${BOLDLIST} ]]; then BOLDLIST=`get_parameters "${setflag}boldruns" "$@"`; fi
    BOLDLIST=`echo "${BOLDLIST}" | sed 's/ /,/g;s/|/ /g'`
    BOLDSuffix=`get_parameters "${setflag}boldsuffix" $@`
    BOLDPrefix=`get_parameters "${setflag}boldprefix" $@`
    SkipFrames=`get_parameters "${setflag}skipframes" $@`
    SNROnly=`get_parameters "${setflag}snronly" $@`
    TimeStamp=`get_parameters "${setflag}timestamp" $@`
    Suffix=`get_parameters "${setflag}suffix" $@`
    SceneZip=`get_parameters "${setflag}scenezip" $@`

    # -- Check if session input is a parameter file instead of list of cases
    if [[ ${CASES} == *.txt ]]; then
        echo ""
        echo "Using $BATCH_FILE for input."
        echo ""
        CASES=`cat ${BATCH_FILE} | grep "id:" | cut -d ':' -f 2 | sed 's/[[:space:]]\+//g'`
        if [[ -z $CASES ]]; then
            CASES=`cat ${BATCH_FILE} | grep "session:" | cut -d ':' -f 2 | sed 's/[[:space:]]\+//g'`
        fi
        # convert to space separated insted of new line
        CASES=`echo $CASES | sed 's/\n/ /g'`
    fi

    # -- Filter sessions with sessions and sessionids
    if [[ ! -z ${SESSIONS} ]]; then
        # loop over cases if case is in sessions keep it
        NEW_CASES=""
        for CASE in ${CASES}; do
            if [[ ${SESSIONS} =~ ${CASE} ]]; then
                NEW_CASES="${NEW_CASES}${CASE} "
            fi
        done
        CASES=$(echo "${NEW_CASES}" | xargs)
    fi
    if [[ ! -z ${SESSIONIDS} ]]; then
        # loop over cases if case is in sessionids keep it
        NEW_CASES=""
        for CASE in ${CASES}; do
            if [[ ${SESSIONIDS} =~ ${CASE} ]]; then
                NEW_CASES="${NEW_CASES} ${CASE}"
            fi
        done
        CASES=$(echo "${NEW_CASES}" | xargs)
    fi

    # -- Get species flag for NHP pipelines
    Species=`get_parameters "${setflag}species" $@`
fi

# -- Set sessions folder variable
if [[ -z "${QuNexSessionsFolder}" ]] && [[ -n "${StudyFolder}" ]]; then
    QuNexSessionsFolder="${StudyFolder}/sessions"
    SessionsFolderName="sessions"
fi

# -- return to stored folder
popd > /dev/null

# =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-==-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-==-=-=-=-=-=-=-
# =-=-=-=-=-=-=-=-=-=-=-= Execute specific commands =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
# =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-==-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-==-=-=-=-=-=-=-

# ------------------------------------------------------------------------------
# -- run_turnkey
# ------------------------------------------------------------------------------

if [[ ${CommandToRun} == "run_turnkey" ]]; then
    # -- Check for cases
    if [[ -z ${CASES} ]]; then
        if [[ ! -z ${XNAT_SESSION_LABELS} ]]; then
            CASES="$XNAT_SESSION_LABELS"
        fi
    fi

    if [[ -z ${CASES} ]]; then echo "ERROR: List of sessions missing"; exit 1; fi

    # -- Check for WORKDIR and StudyFolder for an XNAT run
    if [[ -z ${WORKDIR} ]]; then
        if [[ ! -z ${XNAT_PROJECT_ID} ]]; then
            WORKDIR="/output"; echo "NOTE: Working directory where study is located is missing. Setting defaults: ${WORKDIR}"; echo ''
        fi
    fi

    if [[ -z ${WORKDIR} ]]; then echo "ERROR: Working folder for $CommandToRun missing."; exit 1; fi

    if [[ -z ${StudyFolder} ]]; then
        if [[ ! -z ${XNAT_PROJECT_ID} ]]; then
            StudyFolder="${WORKDIR}/${XNAT_PROJECT_ID}"
        fi
    fi

    if [[ -z ${StudyFolder} ]]; then echo "ERROR: Study folder missing."; exit 1; fi

    # -- Check if cluster options are set
    Cluster="$RunMethod"
    if [[ ${Cluster} == "2" ]]; then
            if [[ -z ${Scheduler} ]]; then echo "ERROR: Scheduler specification and options missing."; exit 1; fi
    fi

    # -- Clean up argument flags
    runTurnkeyArgumentsInput="${runTurnkeyArguments}"
    runTurnkeyArguments=`echo "${runTurnkeyArguments}" | sed 's|--sessions=.[^-]*||g'`
    runTurnkeyArguments=`echo "${runTurnkeyArguments}" | sed 's|--turnkeysteps=.[^-]*||g'`
    runTurnkeyArguments=`echo "${runTurnkeyArguments}" | sed 's|--sessionids=.[^-]*||g'`
    runTurnkeyArguments=`echo "${runTurnkeyArguments}" | sed 's|--bolds=.[^-]*||g'`
    runTurnkeyArguments=`echo "${runTurnkeyArguments}" | sed 's|--bolddata=.[^-]*||g'`
    runTurnkeyArguments=`echo "${runTurnkeyArguments}" | sed 's|--boldruns=.[^-]*||g'`

    echo ""
    echo "Running $CommandToRun with the following parameters:"
    echo "--------------------------------------------------------------"
    echo ""
    echo " Turnkey steps: ${TURNKEY_STEPS} "
    echo " Turnkey arguments:"
    echo "${runTurnkeyArguments} " | sed -e $'s/ /\\\n/g'

    # -- Loop through all the cases
    for CASE in ${CASES}; do ${CommandToRun}; done
fi

# ------------------------------------------------------------------------------
# -- run_qc
# ------------------------------------------------------------------------------

if [ "$CommandToRun" == "qc_preproc" ] || [ "$CommandToRun" == "run_qc" ]; then
    if [ "$CommandToRun" == "qc_preproc" ]; then
       echo ""
       echo "---> NOTE: qc_preproc is deprecated. New function name ---> ${CommandToRun}"
       echo ""
    fi
    CommandToRun="run_qc"

    # -- Check all the user-defined parameters:
    if [[ -z ${CommandToRun} ]]; then echo "ERROR: Explicitly specify name of command in flag or use function name as first argument (e.g. qunex<command_name> followed by flags) to run missing"; exit 1; fi
    if [[ -z ${StudyFolder} ]]; then echo "ERROR: Study folder missing."; exit 1; fi
    if [[ -z ${SessionsFolder} ]]; then echo "ERROR: Sessions folder missing."; exit 1; fi
    if [[ -z ${CASES} ]]; then echo "ERROR: List of sessions missing."; exit 1; fi
    if [[ -z ${Modality} ]]; then echo "ERROR: Modality to perform QC on missing."; exit 1; fi
    if [[ -z ${runQC_Custom} ]]; then runQC_Custom="no"; fi
    if [[ ${runQC_Custom} == "yes" ]]; then scenetemplatefolder="${StudyFolder}/processing/scenes/QC/${Modality}"; fi
    if [[ -z ${OmitDefaults} ]]; then OmitDefaults="no"; fi
    Cluster="$RunMethod"
    if [[ ${Cluster} == "2" ]]; then
        if [[ -z ${Scheduler} ]]; then echo "ERROR: Scheduler specification and options missing."; exit 1; fi
    fi

    # -- Perform some careful scene checks
    if [[ -z ${UserSceneFile} ]]; then
        if [ ! -z "$UserScenePath" ]; then
            echo "---> Provided --userscenepath but --userscenefile not specified."; echo "";
            echo "     Check your inputs and re-run."; echo "";
            scenetemplatefolder="${TOOLS}/${QUNEXREPO}/qx_library/data/scenes/qc"
            echo "---> Reverting to QuNex defaults: ${scenetemplatefolder}"; echo ""
        fi

        if [ -z "$scenetemplatefolder" ]; then
            scenetemplatefolder="${TOOLS}/${QUNEXREPO}/qx_library/data/scenes/qc"
            echo "---> Template folder path value not explicitly specified."; echo ""
            echo "---> Using QuNex defaults: ${scenetemplatefolder}"; echo ""
        fi

        if ls ${scenetemplatefolder}/*${Modality}*.scene 1> /dev/null 2>&1; then
            echo "---> Scene files found in:"; echo "`ls ${scenetemplatefolder}/*${Modality}*.scene`"; echo ""
        else
            echo "---> Specified folder contains no scenes: ${scenetemplatefolder}"; echo ""
            scenetemplatefolder="${TOOLS}/${QUNEXREPO}/qx_library/data/scenes/qc"
            echo "---> Reverting to defaults: ${scenetemplatefolder} "; echo ""
        fi
    else
        if [[ -f ${UserSceneFile} ]]; then
            echo "---> User scene file found: ${UserSceneFile}"; echo ""
            UserScenePath=`echo ${UserSceneFile} | awk -F'/' '{print $1}'`
            UserSceneFile=`echo ${UserSceneFile} | awk -F'/' '{print $2}'`
            scenetemplatefolder=${UserScenePath}
        else
            if [ -z "$UserScenePath" ] && [ -z "$scenetemplatefolder" ]; then
                echo "---> ERROR: Path for user scene file not specified."
                echo "     Specify --scenetemplatefolder or --userscenepath with correct path and re-run."; echo ""; exit 1
            fi

            if [ ! -z "$UserScenePath" ] && [ -z "$scenetemplatefolder" ]; then
                scenetemplatefolder=${UserScenePath}
            fi

            if ls ${scenetemplatefolder}/${UserSceneFile} 1> /dev/null 2>&1; then
                echo "---> User specified scene files found in: ${scenetemplatefolder}/${UserSceneFile} "; echo ""
            else
                echo "---> ERROR: User specified scene ${scenetemplatefolder}/${UserSceneFile} not found."
                echo "     Check your inputs and re-run."; echo ""; exit 1
            fi
        fi
    fi

    if [ -z "$OutPath" ]; then OutPath="${SessionsFolder}/QC/${Modality}"; echo "Output folder path value not explicitly specified. Using default: ${OutPath}"; fi

    if [ -z "$SceneZip" ]; then SceneZip="yes"; echo "Generation of scene zip file not explicitly provided. Using default: ${SceneZip}"; fi

    # -- DWI modality-specific settings:
    if [ "$Modality" = "DWI" ]; then
        if [ -z "$DWIPath" ]; then DWIPath="Diffusion"; echo "DWI input path not explicitly specified. Using default: ${DWIPath}"; fi
        if [ -z "$DWIData" ]; then DWIData="data"; echo "DWI data name not explicitly specified. Using default: ${DWIData}"; fi
        if [ -z "$DtiFitQC" ]; then DtiFitQC="no"; echo "DWI dtifit QC not specified. Using default: ${DtiFitQC}"; fi
        if [ -z "$BedpostXQC" ]; then BedpostXQC="no"; echo "DWI BedpostX not specified. Using default: ${BedpostXQC}"; fi
        if [ -z "$EddyQCStats" ]; then EddyQCStats="no"; echo "DWI EDDY QC Stats not specified. Using default: ${EddyQCStats}"; fi
    fi

    # -- BOLD modality-specific settings:
    if [[ ${Modality} = "BOLD" ]]; then
        # - Check if BOLDS parameter is empty:
        if [ -z "$BOLDS" ]; then
            echo ""
            echo "WARNING: BOLD input list not specified. Relying on session_hcp.txt individual information files."
            BOLDS="session_hcp.txt"
            echo ""
        fi

        if [ -z "$BOLDPrefix" ]; then BOLDPrefix=""; echo "Input BOLD Prefix not specified. Assuming no BOLD name prefix."; fi

        if [ -z "$BOLDSuffix" ]; then BOLDSuffix=""; echo "Processed BOLD Suffix not specified. Assuming no BOLD output suffix."; fi
    fi

    # -- General modality settings:
    if [ "$Modality" = "general" ] || [ "$Modality" = "General" ] || [ "$Modality" = "GENERAL" ] ; then
        if [ -z "$GeneralSceneDataFile" ]; then echo "ERROR: Data input not specified"; echo ""; exit 1; fi
        if [ -z "$GeneralSceneDataPath" ]; then echo "ERROR: Data input path not specified"; echo ""; exit 1; fi
    fi

    # -- Report parameters
    echo ""
    echo "Running $CommandToRun with the following parameters:"
    echo "--------------------------------------------------------------"
    echo "   Study Folder: ${StudyFolder}"
    echo "   Sessions Folder: ${SessionsFolder}"
    echo "   Sessions: ${CASES}"
    echo "   QC Modality: ${Modality}"
    echo "   QC Output Path: ${OutPath}"
    echo "   Study Log Folder: ${LogFolder}"
    echo "   Custom QC requested: ${runQC_Custom}"
    echo "   HCP folder suffix: ${HCPSuffix}"

    if [ "$runQC_Custom" == "yes" ]; then
        echo "   Custom QC modalities: ${Modality}"
    fi

    if [ "$Modality" == "BOLD" ] || [ "$Modality" == "bold" ]; then
        if [[ ! -z ${BATCH_FILE} ]]; then
            if [[ ! -f ${BATCH_FILE} ]]; then
                echo "ERROR: Requested BOLD modality with a batch file. Batch file not found."
                exit 1
            else
                echo "   Session batch file requested: ${BATCH_FILE}"
                BOLDSBATCH="${BOLDRUNS}"
            fi
        fi
        if [[ ! -z ${BOLDRUNS} ]]; then
            echo "   BOLD runs requested: ${BOLDRUNS}"
        else
            echo "   BOLD runs requested: all"
        fi
    fi

    echo "   Omit default QC: ${OmitDefaults}"
    echo "   QC Scene Template Folder: ${scenetemplatefolder}"
    echo "   QC User-defined Scene: ${UserSceneFile}"
    echo "   Overwrite prior run: ${Overwrite}"
    echo "   Zip Scene File: ${SceneZip}"

    if [ "   $Modality" = "DWI" ]; then
        echo "   DWI input path: ${DWIPath}"
        echo "   DWI input name: ${DWIData}"
        echo "   DWI dtifit QC requested: ${DtiFitQC}"
        echo "   DWI bedpostX QC requested: ${BedpostXQC}"
        echo "   DWI EDDY QC Stats requested: ${EddyQCStats}"
    fi

    if [ "$Modality" = "BOLD" ]; then
        echo "   BOLD data input: ${BOLDS}"
        echo "   BOLD Prefix: ${BOLDPrefix}"
        echo "   BOLD Suffix: ${BOLDSuffix}"
        echo "   Skip Initial Frames: ${SkipFrames}"
        echo "   Compute SNR Only: ${SNROnly}"

        if [ "$SNROnly" == "yes" ]; then echo ""; echo "   BOLD SNR only specified. Will skip QC images"; echo ""; fi

        if [[ ! -z ${BOLDfc} ]]; then
            echo "   BOLD FC requested: ${BOLDfc}"
            echo "   BOLD FC input: ${BOLDfcInput}"
            echo "   BOLD FC path: ${BOLDfcPath}"
        fi
    fi

    if [ "$Modality" = "general" ]; then
        echo "  Data input path: ${GeneralSceneDataPath}"
        echo "  Data input: ${GeneralSceneDataFile}"
    fi

    if [ -n ${sourcefile} ]; then
        echo "  Source file: ${sourcefile}"
    fi

    echo ""

    # -- Loop through all the cases
    for CASE in ${CASES}; do ${CommandToRun} ${CASE}; done
fi

# ------------------------------------------------------------------------------
# -- dwi_eddy_qc - eddyqc - uses EDDY QC by Matteo Bastiani, FMRIB
# ------------------------------------------------------------------------------

if [ "$CommandToRun" == "dwi_eddy_qc" ]; then
    # -- Check all the user-defined parameters:
    if [[ -z ${CommandToRun} ]]; then echo "ERROR: Explicitly specify name of command in flag or use function name as first argument (e.g. qunex<command_name> followed by flags) to run missing"; exit 1; fi
    if [[ -z ${StudyFolder} ]]; then echo "ERROR: Study folder missing"; exit 1; fi
    if [[ -z ${SessionsFolder} ]]; then echo "ERROR: Sessions folder missing"; exit 1; fi
    if [ -z "$Report" ]; then echo "ERROR: Report type missing"; exit 1; fi

    # -- Perform checks for individual run
    if [ "$Report" == "individual" ]; then
        if [[ -z ${CASES} ]]; then echo "ERROR: List of sessions missing"; exit 1; fi
        if [ -z "$EddyBase" ]; then echo "Eddy base input name missing"; exit 1; fi
        if [ -z "$BvalsFile" ]; then echo "BVALS file missing"; exit 1; fi
        if [ -z "$EddyIdx" ]; then echo "Eddy index missing"; exit 1; fi
        if [ -z "$EddyParams" ]; then echo "Eddy parameters missing"; exit 1; fi
        if [ -z "$Mask" ]; then echo "ERROR: Mask missing"; exit 1; fi
        if [ -z "$BvecsFile" ]; then BvecsFile=""; fi
    fi

    # -- Perform checks for group run
    if [ "$Report" == "group" ]; then
        if [ -z "$List" ]; then echo "ERROR: List of sessions missing"; exit 1; fi
        if [ -z "$Update" ]; then Update="false"; fi
        if [ -z "$GroupVar" ]; then GroupVar=""; fi
    fi

    # -- Check if cluster options are set
    Cluster="$RunMethod"
    if [[ ${Cluster} == "2" ]]; then
            if [[ -z ${Scheduler} ]]; then echo "ERROR: Scheduler specification and options missing."; exit 1; fi
    fi

    # -- Loop through cases for an individual run call
    if [ ${Report} == "individual" ]; then
        for CASE in ${CASES}; do
            # -- Check in/out paths
            if [ -z ${EddyPath} ]; then
                echo "Eddy path not set. Assuming defaults."
                EddyPath="${SessionsFolder}/${CASE}/hcp/${CASE}/Diffusion/eddy"
            else
                EddyPath="${SessionsFolder}/${CASE}/hcp/${CASE}/$EddyPath"
                echo $EddyPath
            fi

            if [ -z ${OutputDir} ]; then
                echo "Output folder not set. Assuming defaults."
                OutputDir="${EddyPath}/${EddyBase}.qc"
            fi

            # -- Report individual parameters
            echo ""
            echo "Running $CommandToRun with the following parameters:"
            echo "--------------------------------------------------------------"
            echo "   StudyFolder: ${StudyFolder}"
            echo "   Sessions Folder: ${SessionsFolder}"
            echo "   Session: ${CASE}"
            echo "   Study Log Folder: ${LogFolder}"
            echo "   Report Type: ${Report}"
            echo "   Eddy QC Input Path: ${EddyPath}"
            echo "   Eddy QC Output Path: ${OutputDir}"
            echo "   Eddy Inputs Base Name: ${EddyBase}"
            echo "   Mask: ${EddyPath}/${Mask}"
            echo "   BVALS file: ${EddyPath}/${BvalsFile}"
            echo "   Eddy Index file: ${EddyPath}/${EddyIdx}"
            echo "   Eddy parameter file: ${EddyPath}/${EddyParams}"

            # Report optional parameters
            echo "   BvecsFile: ${EddyPath}/${BvecsFile}"
            echo "   Overwrite: ${EddyPath}/${Overwrite}"
            echo ""

            # -- Execute function
            ${CommandToRun} ${CASE}
        done
    fi

    # -- Check if group call specified
    if [ ${Report} == "group" ]; then
        # -- Report group parameters
        echo ""
        echo "Running $CommandToRun with the following parameters:"
        echo "--------------------------------------------------------------"
        echo "   Study Folder: ${StudyFolder}"
        echo "   Sessions Folder: ${SessionsFolder}"
        echo "   Study Log Folder: ${LogFolder}"
        echo "   Report Type: ${Report}"
        echo "   Eddy QC Input Path: ${EddyPath}"
        echo "   Eddy QC Output Path: ${OutputDir}"
        echo "   List: ${List}"
        echo "   Grouping Variable: ${GroupVar}"
        echo "   Update single sessions: ${Update}"
        echo "   Overwrite: ${EddyPath}/${Overwrite}"
        echo ""
    fi
fi

# ------------------------------------------------------------------------------
# -- parcellate_anat
# ------------------------------------------------------------------------------

if [ "$CommandToRun" == "parcellate_anat" ]; then
    # -- Check all the user-defined parameters:
    if [[ -z ${CommandToRun} ]]; then echo "ERROR: Explicitly specify name of command in flag or use function name as first argument (e.g. qunex<command_name> followed by flags) to run missing"; exit 1; fi
    if [[ -z ${StudyFolder} ]]; then echo "ERROR: Study folder missing"; exit 1; fi
    if [[ -z ${SessionsFolder} ]]; then echo "ERROR: Sessions folder missing"; exit 1; fi
    if [[ -z ${CASES} ]]; then echo "ERROR: List of sessions missing"; exit 1; fi
    if [ -z "$InputDataType" ]; then echo "ERROR: Input data type value missing"; exit 1; fi
    if [[ -z ${OutName} ]]; then echo "ERROR: Output file name value missing"; exit 1; fi
    if [ -z "$ParcellationFile" ]; then echo "ERROR: File to use for parcellation missing"; exit 1; fi
    Cluster="$RunMethod"

    if [[ ${Cluster} == "2" ]]; then
            if [[ -z ${Scheduler} ]]; then echo "ERROR: Scheduler specification and options missing."; exit 1; fi
    fi

    # -- Check optional parameters if not specified
    if [ -z "$ExtractData" ]; then ExtractData="no"; fi
    if [ -z "$Overwrite" ]; then Overwrite="no"; fi

    # -- Report parameters
    echo ""
    echo "Running $CommandToRun with the following parameters:"
    echo "--------------------------------------------------------------"
    echo "   Study Folder: ${StudyFolder}"
    echo "   Sessions Folder: ${SessionsFolder}"
    echo "   Sessions: ${CASES}"
    echo "   Study Log Folder: ${LogFolder}"
    echo "   ParcellationFile: ${ParcellationFile}"
    echo "   Parcellated Data Output Name: ${OutName}"
    echo "   Input Data Type: ${InputDataType}"
    echo "   Extract data in CSV format: ${ExtractData}"
    echo "   Overwrite prior run: ${Overwrite}"
    echo ""

    # -- Loop through all the cases
    for CASE in ${CASES}; do ${CommandToRun} ${CASE}; done
fi

# ------------------------------------------------------------------------------
# -- dwi_dtifit
# ------------------------------------------------------------------------------

if [ "$CommandToRun" == "dwi_dtifit" ]; then
    # -- Check all the user-defined parameters:
    if [[ -z ${CommandToRun} ]]; then echo "ERROR: Explicitly specify name of command in flag or use function name as first argument (e.g. qunex<command_name> followed by flags) to run missing"; exit 1; fi
    if [[ -z ${StudyFolder} ]]; then echo "ERROR: Study folder missing"; exit 1; fi
    if [[ -z ${SessionsFolder} ]]; then echo "ERROR: Sessions folder missing"; exit 1; fi
    if [[ -z ${CASES} ]]; then echo "ERROR: List of sessions missing"; exit 1; fi
    Cluster="$RunMethod"

    if [[ ${Cluster} == "2" ]]; then
        if [[ -z ${Scheduler} ]]; then echo "ERROR: Scheduler specification and options missing."; exit 1; fi
    fi

    # -- Loop through all the cases
    for CASE in ${CASES}; do ${CommandToRun} ${CASE}; done
fi

# ------------------------------------------------------------------------------
# -- dwi_bedpostx_gpu
# ------------------------------------------------------------------------------

if [ "$CommandToRun" == "dwi_bedpostx_gpu" ]; then
    # -- Check required parameters
    if [[ -z ${StudyFolder} ]]; then echo "ERROR: Study Folder missing"; exit 1; fi
    if [[ -z ${CASES} ]]; then echo "ERROR: List of sessions missing"; exit 1; fi
    Cluster=${RunMethod}

    # -- Loop through all the cases
    for CASE in ${CASES}; do ${CommandToRun} ${CASE}; done
fi

# ------------------------------------------------------------------------------
# -- dwi_legacy_gpu
# ------------------------------------------------------------------------------

if [ "$CommandToRun" == "dwi_legacy_gpu" ]; then
    # -- Check all the user-defined parameters:
    if [[ -z ${CommandToRun} ]]; then echo "ERROR: Explicitly specify name of command in flag or use function name as first argument (e.g. qunex<command_name> followed by flags) to run missing"; exit 1; fi
    if [ -z "$UseFieldmap" ]; then echo "ERROR: UseFieldmap yes/no specification missing"; exit 1; fi
    if [[ -z ${StudyFolder} ]]; then echo "ERROR: Study folder missing"; exit 1; fi
    if [[ -z ${SessionsFolder} ]]; then echo "ERROR: Sessions folder missing"; exit 1; fi
    if [[ -z ${CASES} ]]; then echo "ERROR: List of sessions missing"; exit 1; fi
    if [ -z "$diffdatasuffix" ]; then echo "ERROR: Diffusion Data Suffix Name missing"; exit 1; fi

    if [ ${UseFieldmap} == "yes" ]; then
        if [ -z "$te" ]; then echo "ERROR: TE (--te) value for Fieldmap missing"; exit 1; fi
    elif [ ${UseFieldmap} == "no" ]; then
        echo "NOTE: Processing without FieldMap (TE option not needed)"
    fi

    Cluster="$RunMethod"
    if [[ ${Cluster} == "2" ]]; then
            if [[ -z ${Scheduler} ]]; then echo "ERROR: Scheduler specification and options missing."; exit 1; fi
    fi

    # -- Report parameters
    echo ""
    echo "Running $CommandToRun with the following parameters:"
    echo "--------------------------------------------------------------"
    echo "   Study Folder: ${StudyFolder}"
    echo "   Sessions Folder: ${SessionsFolder}"
    echo "   Sessions: ${CASES}"
    echo "   Study Log Folder: ${LogFolder}"
    echo "   Using FieldMap: ${UseFieldmap}"
    echo "   Echo Spacing: ${EchoSpacing}"
    echo "   Phase Encoding Direction: ${pedir}"
    echo "   TE value for Fieldmap: ${TE}"
    echo "   EPI Unwarp Direction: ${UnwarpDir}"
    echo "   Diffusion Data Suffix Name: ${diffdatasuffix}"
    echo "   Overwrite prior run: ${Overwrite}"
    echo "   No GPU: ${nogpu}"
    echo ""

    # -- Loop through all the cases
    for CASE in ${CASES}; do ${CommandToRun} ${CASE}; done
fi

# ------------------------------------------------------------------------------
# -- parcellate_anat
# ------------------------------------------------------------------------------

if [ "$CommandToRun" == "parcellate_anat" ]; then

    # -- Check all the user-defined parameters:
    if [[ -z ${CommandToRun} ]]; then echo "ERROR: Explicitly specify name of command in flag or use function name as first argument (e.g. qunex<command_name> followed by flags) to run missing"; exit 1; fi
    if [[ -z ${StudyFolder} ]]; then echo "ERROR: Study folder missing"; exit 1; fi
    if [[ -z ${SessionsFolder} ]]; then echo "ERROR: Sessions folder missing"; exit 1; fi
    if [[ -z ${CASES} ]]; then echo "ERROR: List of sessions missing"; exit 1; fi
    if [ -z "$InputDataType" ]; then echo "ERROR: Input data type value missing"; exit 1; fi
    if [[ -z ${OutName} ]]; then echo "ERROR: Output file name value missing"; exit 1; fi
    if [ -z "$ParcellationFile" ]; then echo "ERROR: File to use for parcellation missing"; exit 1; fi

    Cluster="$RunMethod"
    if [[ ${Cluster} == "2" ]]; then
            if [[ -z ${Scheduler} ]]; then echo "ERROR: Scheduler specification and options missing."; exit 1; fi
    fi

    # -- Check optional parameters if not specified
    if [ -z "$ExtractData" ]; then ExtractData="no"; fi
    if [ -z "$Overwrite" ]; then Overwrite="no"; fi

    # -- Report parameters
    echo ""
    echo "Running $CommandToRun with the following parameters:"
    echo "--------------------------------------------------------------"
    echo "   Study Folder: ${StudyFolder}"
    echo "   Sessions Folder: ${SessionsFolder}"
    echo "   Sessions: ${CASES}"
    echo "   Study Log Folder: ${LogFolder}"
    echo "   ParcellationFile: ${ParcellationFile}"
    echo "   Parcellated Data Output Name: ${OutName}"
    echo "   Input Data Type: ${InputDataType}"
    echo "   Extract data in CSV format: ${ExtractData}"
    echo "   Overwrite prior run: ${Overwrite}"
    echo ""

    # -- Loop through all the cases
    for CASE in ${CASES}; do ${CommandToRun} ${CASE}; done
fi

# ------------------------------------------------------------------------------
# -- fc_compute_wrapper
# ------------------------------------------------------------------------------

if [ "$CommandToRun" == "compute_bold_fc" ] || [ "$CommandToRun" == "fc_compute_wrapper" ]; then
    CommandToRun="compute_bold_fc"

    # -- Check all the user-defined parameters:
    if [[ -z ${CommandToRun} ]]; then echo "ERROR: Explicitly specify name of command in flag or use function name as first argument (e.g. qunex<command_name> followed by flags) to run missing"; exit 1; fi
    if [[ -z ${Calculation} ]]; then echo "ERROR: Type of calculation to run (gbc or seed) missing"; exit 1; fi
    if [[ -z ${RunType} ]] && [[ ${Calculation} != "dense" ]]; then echo "ERROR: Type of run (group or individual) missing"; exit 1; fi

    if [[ ${RunType} == "list" ]]; then
        if [ -z "$FileList" ]; then echo "ERROR: Group file list missing"; exit 1; fi
    fi

    if [[ ${RunType} == "individual" ]] || [[ ${RunType} == "group" ]]; then
        if [[ -z ${StudyFolder} ]]; then echo "ERROR: Study folder missing"; exit 1; fi
        if [[ -z ${SessionsFolder} ]]; then echo "ERROR: Sessions folder missing"; exit 1; fi
        if [[ -z ${CASES} ]]; then echo "ERROR: List of sessions missing"; exit 1; fi
        if [ -z "$InputFiles" ]; then echo "ERROR: Input file(s) value missing"; exit 1; fi
        if [[ -z ${OutName} ]]; then echo "ERROR: Output file name value missing"; exit 1; fi

        if [[ ${RunType} == "individual" ]]; then
            if [ -z "$InputPath" ]; then echo ""; echo "WARNING: Input path value missing. Assuming individual folder structure for output"; fi
            if [ -z "$OutPathFC" ]; then echo ""; echo "WARNING: Output path value missing. Assuming individual folder structure for output"; fi
        fi

        if [[ ${RunType} == "group" ]]; then
            if [ -z "$OutPathFC" ]; then echo "ERROR: Output path value missing and is needed for a group run."; exit 1; fi
        fi
    fi

    if [[ ${Calculation} == "gbc" ]]; then
        if [ -z "$TargetROI" ]; then TargetROI="[]"; fi
        if [ -z "$RadiusSmooth" ]; then RadiusSmooth="0"; fi
        if [ -z "$RadiusDilate" ]; then RadiusDilate="0"; fi
        if [ -z "$GBCCommand" ]; then GBCCommand="mFz:"; fi
        if [ -z "$Verbose" ]; then Verbose="true"; fi
        if [ -z "$ComputeTime" ]; then ComputeTime="true"; fi
        if [ -z "$VoxelStep" ]; then VoxelStep="1200"; fi
    fi

    if [[ ${Calculation} == "seed" ]]; then
        if [ -z "$ROIInfo" ]; then echo "ERROR: ROI seed file not specified"; exit 1; fi
        if [ -z "$FCCommand" ]; then FCCommand=""; fi
        if [ -z "$Method" ]; then Method="mean"; fi
    fi

    Cluster="$RunMethod"
    if [[ ${Cluster} == "2" ]]; then
            if [[ -z ${Scheduler} ]]; then echo "ERROR: Scheduler specification and options missing."; exit 1; fi
    fi

    # -- Check optional parameters if not specified
    if [ -z "$IgnoreFrames" ]; then IgnoreFrames=""; fi
    if [ -z "$MaskFrames" ]; then MaskFrames=""; fi
    if [ -z "$Covariance" ]; then Covariance=""; fi
    if [ -z "$ExtractData" ]; then ExtractData="no"; fi

    if [[ ${Calculation} == "dense" ]]; then
        RunType="individual";
        if [ -z ${MemLimit} ]; then MemLimit="4"; echo "WARNING: MemLimit value missing. Setting to $MemLimit"; fi
    fi

    # -- Report parameters
    echo ""
    echo "Running $CommandToRun with the following parameters:"
    echo "--------------------------------------------------------------"
    echo "   Study Log Folder: ${LogFolder}"
    echo "   Output Path: ${OutPathFC}"
    echo "   Extract data in CSV format: ${ExtractData}"
    echo "   Type of fc calculation: ${Calculation}"
    echo "   Type of run: ${RunType}"
    echo "   Calculate Covariance: ${Covariance}"

    if [[ ${Calculation} != "dense" ]]; then
        echo "   Ignore frames: ${IgnoreFrames}"
        echo "   Mask out frames: ${MaskFrames}"
    else
        echo "   Memory Limit: ${MemLimit}"
    fi

    if [[ ${RunType} == "list" ]]; then
        echo "   FileList: ${FileList}"
    fi

    if [[ ${RunType} == "individual" ]] || [[ ${RunType} == "group" ]]; then
        echo "   Study Folder: ${StudyFolder}"
        echo "   Sessions Folder: ${SessionsFolder}"
        echo "   Sessions: ${CASES}"
        echo "   Input Files: ${InputFiles}"
        echo "   Input Path for Data: ${SessionsFolder}/<session_id>/${InputPath}"
        echo "   Output Name: ${OutName}"
    fi

    if [[ ${Calculation} == "gbc" ]]; then
        echo "   Target ROI for GBC: ${TargetROI}"
        echo "   Radius Smooth for GBC: ${RadiusSmooth}"
        echo "   Radius Dilate for GBC: ${RadiusDilate}"
        echo "   GBC Commands to run: ${GBCCommand}"
        echo "   Verbose outout: ${Verbose}"
        echo "   Print Compute Time: ${ComputeTime}"
        echo "   Voxel Steps to use: ${VoxelStep}"
    fi

    if [[ ${Calculation} == "seed" ]]; then
        echo "   ROI Information for seed fc: ${ROIInfo}"
        echo "   FC Commands to run: ${FCCommand}"
        echo "   Method to compute fc: ${Method}"
    fi

    echo ""

    if [[ ${RunType} == "individual" ]]; then
        for CASE in ${CASES}; do
            ${CommandToRun} ${CASE}
        done
    fi

    if [[ ${RunType} == "group" ]]; then
        CASE=`echo "$CASES" | sed 's/ /,/g'`
        echo $CASE
        ${CommandToRun} ${CASE}
    fi

    if [[ ${RunType} == "list" ]]; then
        ${CommandToRun}
    fi
fi

# ------------------------------------------------------------------------------
# -- parcellate_bold
# ------------------------------------------------------------------------------

if [ "$CommandToRun" == "bold_parcellation" ] || [ "$CommandToRun" == "parcellate_bold" ]; then
    CommandToRun="parcellate_bold"

    # -- Check all the user-defined parameters:
    if [[ -z ${CommandToRun} ]]; then echo "ERROR: Explicitly specify name of command in flag or use function name as first argument (e.g. qunex<command_name> followed by flags) to run missing"; exit 1; fi
    if [ -z "$InputPath" ]; then echo "ERROR: Input path value missing"; exit 1; fi
    if [ -z "$InputDataType" ]; then echo "ERROR: Input data type value missing"; exit 1; fi
    if [ -z "$OutPath" ]; then echo "ERROR: Output path value missing"; exit 1; fi
    if [[ -z ${OutName} ]]; then echo "ERROR: Output file name value missing"; exit 1; fi
    if [ -z "$ParcellationFile" ]; then echo "ERROR: File to use for parcellation missing"; exit 1; fi

    Cluster="$RunMethod"
    if [[ ${Cluster} == "2" ]]; then
            if [[ -z ${Scheduler} ]]; then echo "ERROR: Scheduler specification and options missing."; exit 1; fi
    fi

    # -- Check optional parameters if not specified
    if [ -z ${UseWeights} ]; then
        UseWeights="no"
        WeightsFile="no"
        echo "NOTE: Weights file not used."
    fi

    if [ -z ${WeightsFile} ]; then
        UseWeights="no"
        WeightsFile="no"
        echo "NOTE: Weights file not used."
    fi

    if [ -z "$ComputePConn" ]; then ComputePConn="no"; fi
    if [ -z "$WeightsFile" ]; then WeightsFile="no"; fi
    if [ -z "$ExtractData" ]; then ExtractData="no"; fi

    if [[ -z ${SingleInputFile} ]]; then SingleInputFile="";
        if [[ -z ${StudyFolder} ]]; then echo "ERROR: Study folder missing"; exit 1; fi
        if [[ -z ${SessionsFolder} ]]; then echo "ERROR: Sessions folder missing"; exit 1; fi
        if [[ -z ${CASES} ]]; then echo "ERROR: List of sessions missing"; exit 1; fi
        if [ -z "$InputFile" ]; then echo "ERROR: Input file value missing"; exit 1; fi
    fi

    # -- Report parameters
    echo ""
    echo "Running $CommandToRun with the following parameters:"
    echo "--------------------------------------------------------------"
    echo "   Study Folder: ${StudyFolder}"
    echo "   Sessions Folder: ${SessionsFolder}"
    echo "   Sessions: ${CASES}"
    echo "   Study Log Folder: ${LogFolder}"
    echo "   Input File: ${InputFile}"
    echo "   Input Path: ${InputPath}"
    echo "   Single Input File: ${SingleInputFile}"
    echo "   ParcellationFile: ${ParcellationFile}"
    echo "   BOLD Parcellated Connectome Output Name: ${OutName}"
    echo "   BOLD Parcellated Connectome Output Path: ${OutPath}"
    echo "   Input Data Type: ${InputDataType}"
    echo "   Compute PConn File: ${ComputePConn}"
    echo "   Weights file specified to omit certain frames: ${UseWeights}"
    echo "   Weights file name: ${WeightsFile}"
    echo "   Extract data in CSV format: ${ExtractData}"
    echo "   Overwrite prior run: ${Overwrite}"
    echo ""

    if [[ -z ${SingleInputFile} ]]; then SingleInputFile="";
        # -- Loop through all the cases
        for CASE in ${CASES}; do ${CommandToRun} ${CASE}; done
    else
        # -- Execute on single case
        ${CommandToRun} ${CASE}
    fi
fi

# ------------------------------------------------------------------------------
# -- dwi_parcellate
# ------------------------------------------------------------------------------

if [ "$CommandToRun" == "dwi_parcellate" ]; then
    # -- Check all the user-defined parameters:
    if [[ -z ${CommandToRun} ]]; then echo "ERROR: Explicitly specify name of command in flag or use function name as first argument (e.g. qunex<command_name> followed by flags) to run missing"; exit 1; fi
    if [[ -z ${StudyFolder} ]]; then echo "ERROR: Study folder missing"; exit 1; fi
    if [[ -z ${SessionsFolder} ]]; then echo "ERROR: Sessions folder missing"; exit 1; fi
    if [[ -z ${CASES} ]]; then echo "ERROR: List of sessions missing"; exit 1; fi
    if [ -z "$MatrixVersion" ]; then echo "ERROR: Matrix version value missing"; exit 1; fi
    if [ -z "$ParcellationFile" ]; then echo "ERROR: File to use for parcellation missing"; exit 1; fi
    if [[ -z ${OutName} ]]; then echo "ERROR: Name of output pconn file missing"; exit 1; fi

    Cluster="$RunMethod"
    if [[ ${Cluster} == "2" ]]; then
            if [[ -z ${Scheduler} ]]; then echo "ERROR: Scheduler specification and options missing."; exit 1; fi
    fi

    if [ -z "$WayTotal" ]; then WayTotal="no"; echo "NOTE: --waytotal normalized data not specified. Assuming default [no]"; fi

    if [ -z "$Lengths" ]; then Lengths="no"; echo "NOTE --lengths not specified. Assuming default [no]"; fi

    # -- Report parameters
    echo ""
    echo "Running $CommandToRun with the following parameters:"
    echo "--------------------------------------------------------------"
    echo "   Study Folder: ${StudyFolder}"
    echo "   Sessions Folder: ${SessionsFolder}"
    echo "   Sessions: ${CASES}"
    echo "   Study Log Folder: ${LogFolder}"
    echo "   Matrix version used for input: ${MatrixVersion}"
    echo "   File to use for parcellation: ${ParcellationFile}"
    echo "   Dense DWI Parcellated Connectome Output Name: ${OutName}"
    echo "   Waytotal normalization: ${WayTotal}"
    echo "   Streamline Lengths: ${Lengths}"
    echo "   Overwrite prior run: ${Overwrite}"
    echo ""

    # -- Loop through all the cases
    for CASE in ${CASES}; do ${CommandToRun} ${CASE}; done
fi

# ------------------------------------------------------------------------------
# -- extract_roi
# ------------------------------------------------------------------------------

if [ "$CommandToRun" == "extract_roi" ]; then
    # -- Check all the user-defined parameters
    if [ -z "$ROIFile" ]; then echo "ERROR: File to use for ROI extraction missing"; exit 1; fi
    if [ -z "$InputFile" ]; then echo "ERROR: Input file path value missing"; exit 1; fi
    if [ -z "$OutPath" ]; then echo "ERROR: Output path value missing"; exit 1; fi
    if [[ -z $OutName ]]; then echo "ERROR: Output file name value missing"; exit 1; fi
    Cluster="$RunMethod"
    if [[ ${Cluster} == "2" ]]; then
        if [[ -z ${Scheduler} ]]; then echo "ERROR: Scheduler specification and options missing."; exit 1; fi
    fi

    # -- Report parameters
    echo ""
    echo "Running $CommandToRun with the following parameters:"
    echo "--------------------------------------------------------------"
    echo "   ROI file: ${roifile}"
    echo "   Input file: ${inputfile}"
    echo "   Output path: ${outpath}"
    echo "   Output name: ${outname}"
    echo ""

    if [[ -z ${CASES} ]]; then
        # -- Execute on a single session
        ${CommandToRun}
    else
        if [ -z "$SessionsFolder" ]; then echo "ERROR: --sessionsfolder needs to be provided so we can loop over the sessions in there!"; exit 1; fi
        # -- Loop through all the cases
        CASE_ROIFile="${ROIFile}"
        for CASE in ${CASES}; do
            ROIFile="${SessionsFolder}/${CASE}/${CASE_ROIFile}"
            ${CommandToRun} ${CASE}
        done
    fi
fi

# ------------------------------------------------------------------------------
# -- dwi_seed_tractography_dense
# ------------------------------------------------------------------------------

if [ "$CommandToRun" == "dwi_seed_tractography_dense" ]; then
    # -- Check all the user-defined parameters:
    if [[ -z ${CommandToRun} ]]; then echo "ERROR: Explicitly specify name of command in flag or use function name as first argument (e.g. qunex<command_name> followed by flags) to run missing"; exit 1; fi
    if [[ -z ${StudyFolder} ]]; then echo "ERROR: Study folder missing"; exit 1; fi
    if [[ -z ${SessionsFolder} ]]; then echo "ERROR: Sessions folder missing"; exit 1; fi
    if [[ -z ${CASES} ]]; then echo "ERROR: List of sessions missing"; exit 1; fi
    if [ -z "$MatrixVersion" ]; then echo "ERROR: Matrix version value missing"; exit 1; fi
    if [ -z "$SeedFile" ]; then echo "ERROR: File to use for seed reduction missing"; exit 1; fi
    if [[ -z ${OutName} ]]; then echo "ERROR: Name of output pconn file missing"; exit 1; fi

    Cluster="$RunMethod"
    if [[ ${Cluster} == "2" ]]; then
            if [[ -z ${Scheduler} ]]; then echo "ERROR: Scheduler specification and options missing."; exit 1; fi
    fi
    if [ -z "$WayTotal" ]; then WayTotal="no"; echo "NOTE: --waytotal normalized data not specified. Assuming default [no]"; fi

    # -- Report parameters
    echo ""
    echo "Running $CommandToRun with the following parameters:"
    echo "--------------------------------------------------------------"
    echo "   Study Folder: ${StudyFolder}"
    echo "   Sessions Folder: ${SessionsFolder}"
    echo "   Sessions: ${CASES}"
    echo "   Study Log Folder: ${LogFolder}"
    echo "   Matrix version used for input: ${MatrixVersion}"
    echo "   Dense dconn seed reduction: ${SeedFile}"
    echo "   Dense DWI Parcellated Connectome Output Name: ${OutName}"
    echo "   Waytotal normalization: ${WayTotal}"
    echo "   Overwrite prior run: ${Overwrite}"
    echo ""

    # -- Loop through all the cases
    for CASE in ${CASES}; do ${CommandToRun} ${CASE}; done
fi

# ------------------------------------------------------------------------------
# -- auto_ptx
# ------------------------------------------------------------------------------

if [ "$CommandToRun" == "auto_ptx" ]; then
    # -- Check all the user-defined parameters:
    if [[ -z ${CommandToRun} ]]; then echo "ERROR: Explicitly specify name of command in flag or use function name as first argument (e.g. qunex<command_name> followed by flags) to run missing"; exit 1; fi
    if [[ -z ${StudyFolder} ]]; then echo "ERROR: Study folder missing"; exit 1; fi
    if [[ -z ${SessionsFolder} ]]; then echo "ERROR: Sessions folder missing"; exit 1; fi
    if [[ -z ${CASES} ]]; then echo "ERROR: List of sessions missing"; exit 1; fi

    Cluster="$RunMethod"
    if [[ ${Cluster} == "2" ]]; then
        if [[ -z ${Scheduler} ]]; then echo "ERROR: Scheduler specification and options missing."; exit 1; fi
    fi

    if [[ -z ${BedPostXFolder} ]]; then BedPostXFolder=${SessionsFolder}/${CASE}/hcp/${CASE}/T1w/Diffusion.bedpostX; fi

    # -- Report parameters
    echo ""
    echo "Running $CommandToRun with the following parameters:"
    echo "--------------------------------------------------------------"
    echo "   Study Folder: ${StudyFolder}"
    echo "   Sessions Folder: ${SessionsFolder}"
    echo "   Sessions: ${CASES}"
    echo "   Study Log Folder: ${LogFolder}"
    echo "   BedpostX Folder: ${BedPostXFolder} "
    echo ""

    for CASE in ${CASES}; do ${CommandToRun} ${CASE}; done
fi

# ------------------------------------------------------------------------------
# -- dwi_pre_tractography
# ------------------------------------------------------------------------------

if [ "$CommandToRun" == "dwi_pre_tractography" ]; then
    # -- Check all the user-defined parameters:
    if [[ -z ${CommandToRun} ]]; then echo "ERROR: Explicitly specify name of command in flag or use function name as first argument (e.g. qunex<command_name> followed by flags) to run missing"; exit 1; fi
    if [[ -z ${StudyFolder} ]]; then echo "ERROR: Study folder missing"; exit 1; fi
    if [[ -z ${SessionsFolder} ]]; then echo "ERROR: Sessions folder missing"; exit 1; fi
    if [[ -z ${CASES} ]]; then echo "ERROR: List of sessions missing"; exit 1; fi

    Cluster="$RunMethod"
    if [[ ${Cluster} == "2" ]]; then
        if [[ -z ${Scheduler} ]]; then echo "ERROR: Scheduler specification and options missing."; exit 1; fi
    fi

    # -- Report parameters
    echo ""
    echo "Running $CommandToRun with the following parameters:"
    echo "--------------------------------------------------------------"
    echo "   Study Folder: ${StudyFolder}"
    echo "   Sessions Folder: ${SessionsFolder}"
    echo "   Sessions: ${CASES}"
    echo "   Study Log Folder: ${LogFolder}"
    echo ""

    for CASE in ${CASES}; do ${CommandToRun} ${CASE}; done
fi

# ------------------------------------------------------------------------------
# -- dwi_probtrackx_dense_gpu
# ------------------------------------------------------------------------------

if [ "$CommandToRun" == "dwi_probtrackx_dense_gpu" ]; then

    # Check all the user-defined parameters: 1.QUEUE, 2. Scheduler, 3. Matrix1, 4. Matrix3
    if [[ -z ${CommandToRun} ]]; then echo "ERROR: Explicitly specify name of command in flag or use function name as first argument (e.g. qunex<command_name> followed by flags) to run missing"; exit 1; fi
    if [[ -z ${StudyFolder} ]]; then echo "ERROR: Study folder missing"; exit 1; fi
    if [[ -z ${SessionsFolder} ]]; then echo "ERROR: Sessions folder missing"; exit 1; fi
    if [[ -z ${CASES} ]]; then echo "ERROR: List of sessions missing"; exit 1; fi
    if [ -z "$MatrixOne" ] && [ -z "$MatrixThree" ]; then
        MatrixOne="yes"
        MatrixThree="yes"
    fi
    if [ -z "$MatrixOne" ]; then MatrixOne="no"; fi
    if [ -z "$MatrixThree" ]; then MatrixThree="no"; fi
    if [ -z "$NsamplesMatrixOne" ]; then NsamplesMatrixOne=10000; fi
    if [ -z "$NsamplesMatrixThree" ]; then NsamplesMatrixThree=3000; fi
    Cluster="$RunMethod"
    if [[ ${Cluster} == "2" ]]; then
        if [[ -z ${Scheduler} ]]; then echo "ERROR: Scheduler specification and options missing."; exit 1; fi
    fi

    # -- Optional parameters
    if [ -z ${ScriptsFolder} ]; then ScriptsFolder="${HCPPIPEDIR_dMRITractFull}/tractography_gpu_scripts"; fi
    minimumfilesize="100000000"

    # -- In and out folders for reporting
    if [[ -z ${OutFolder} ]]; then
        OutFolderReport="${SessionsFolder}/<session>/hcp/<session>/MNINonLinear/Results/Tractography";
    else
        OutFolderReport=${OutFolder}
    fi

    # -- distance correction flag
    if [ "$distance_correction" == "yes" ] || [ "$distance_correction" == "YES" ]; then
        distance_correction="yes"
    else
        distance_correction="no"
    fi

    # -- store streamlines length flag
    if [ "$store_streamlines_length" == "yes" ] || [ "$store_streamlines_length" == "YES" ]; then
        store_streamlines_length="yes"
    else
        store_streamlines_length="no"
    fi

    # -- force matrix1 flag
    if [ "$force_matrix1" == "yes" ] || [ "$force_matrix1" == "YES" ]; then
        force_matrix1="yes"
    else
        force_matrix1="no"
    fi

    # -- Report parameters
    echo ""
    echo "Running $CommandToRun with the following parameters:"
    echo "--------------------------------------------------------------"
    echo "   Study Folder: ${StudyFolder}"
    echo "   Sessions Folder: ${SessionsFolder}"
    echo "   Sessions: ${CASES}"
    echo "   Study Log Folder: ${LogFolder}"
    echo "   Scheduler: ${Scheduler}"
    echo "   probtraxkX GPU scripts Folder: ${ScriptsFolder}"
    echo "   Compute Matrix1: ${MatrixOne}"
    echo "   Compute Matrix3: ${MatrixThree}"
    echo "   Number of samples for Matrix1: ${NsamplesMatrixOne}"
    echo "   Number of samples for Matrix3: ${NsamplesMatrixThree}"
    echo "   Distance correction: ${distance_correction}"
    echo "   Store streamlines length: ${store_streamlines_length}"
    echo "   Force Matrix1: ${force_matrix1}"
    echo "   Overwrite prior run: ${Overwrite}"
    echo "   No GPU: ${nogpu}"
    echo ""

    # -- Execute
    for CASE in ${CASES}; do ${CommandToRun} ${CASE}; done
fi
