#!/bin/bash
#
# SPDX-FileCopyrightText: 2021 QuNex development team <https://qunex.yale.edu/>
#
# SPDX-License-Identifier: GPL-3.0-or-later
#
#~ND~FORMAT~MARKDOWN~
#~ND~START~
#
# ## PRODUCT
#
# qunex.sh is a front-end bash integration script for the QuNex Suite
#
#~ND~END~

# =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-==-=-=-=-=-=
# =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= CODE START =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
# =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-==-=-=-=-=-=

qunex_commands="show_version environment qxutil_command_exec dwi_legacy dwi_eddy_qc dwi_parcellate dwi_seed_tractography_dense dwi_dtifit dwi_bedpostx_gpu dwi_pre_tractography dwi_probtrackx_dense_gpu auto_ptx compute_bold_fc fc_compute_wrapper parcellate_anat bold_parcellation parcellate_bold extract_roi run_qc run_turnkey"

# ------------------------------------------------------------------------------
# -- Setup color outputs
# ------------------------------------------------------------------------------

BLACK_F="\033[30m"; BLACK_B="\033[40m"
RED_F="\033[31m"; RED_B="\033[41m"
GREEN_F="\033[32m"; GREEN_B="\033[42m"
YELLOW_F="\033[33m"; YELLOW_B="\033[43m"
BLUE_F="\033[34m"; BLUE_B="\033[44m"
MAGENTA_F="\033[35m"; MAGENTA_B="\033[45m"
CYAN_F="\033[36m"; CYAN_B="\033[46m"
WHITE_F="\033[37m"; WHITE_B="\033[47m"

reho() {
    echo -e "$RED_F$1 \033[0m"
}

geho() {
    echo -e "$GREEN_F$1 \033[0m"
}

yeho() {
    echo -e "$YELLOW_F$1 \033[0m"
}

beho() {
    echo -e "$BLUE_F$1 \033[0m"
}

mageho() {
    echo -e "$MAGENTA_F$1 \033[0m"
}

cyaneho() {
    echo -e "$CYAN_F$1 \033[0m"
}

weho() {
    echo -e "$WHITE_F$1 \033[0m"
}

# version
QuNexVer=`cat ${TOOLS}/${QUNEXREPO}/VERSION.md`

# ------------------------------------------------------------------------------
# -- Splash call
# ------------------------------------------------------------------------------

show_splash() {
    geho ""
    geho "Generated by QuNex"
    geho "------------------------------------------------------------------------"
    geho "Version: $QuNexVer"
    geho "User: `whoami`"
    geho "System: `hostname`"
    geho "OS: $OSInfo $OperatingSystem"
    geho "------------------------------------------------------------------------"
    geho ""
    geho "        ██████\                  ║      ██\   ██\                       "
    geho "       ██  __██\                 ║      ███\  ██ |                      "
    geho "       ██ /  ██ |██\   ██\       ║      ████\ ██ | ██████\ ██\   ██\    "
    geho "       ██ |  ██ |██ |  ██ |      ║      ██ ██\██ |██  __██\\\\\██\ ██  |"
    geho "       ██ |  ██ |██ |  ██ |      ║      ██ \████ |████████ |\████  /    "
    geho "       ██ ██\██ |██ |  ██ |      ║      ██ |\███ |██   ____|██  ██\     "
    geho "       \██████ / \██████  |      ║      ██ | \██ |\███████\██  /\██\    "
    geho "        \___███\  \______/       ║      \__|  \__| \_______\__/  \__|   "
    geho "            \___|                ║                                      "
    geho ""
    geho "                       DEVELOPED & MAINTAINED BY:"
    geho ""
    geho "                    Anticevic Lab, Yale University"
    geho "               Mind & Brain Lab, University of Ljubljana"
    geho "                     Murray Lab, Yale University"
    geho ""
    geho "                      COPYRIGHT & LICENSE NOTICE:"
    geho ""
    geho "Use of this software is subject to the terms and conditions defined in"
    geho "'LICENSE.md' which is a part of the QuNex Suite source code package:"
    geho "https://bitbucket.org/oriadev/qunex/src/master/LICENSE.md"
    geho ""
}

# ------------------------------------------------------------------------------
# -- General help usage
# ------------------------------------------------------------------------------

show_usage() {

cat << EOF

 General QuNex usage syntax
============================
 
  qunex <command_name>
    --parameterA=<required-parameter-args>
    [--parameterB=<optional-parameter-args>]

  =>  --   Dashes or “flags” denote input parameters.
  =>  []   Square brackets denote optional parameters. 
        Note: Arguments is shown inside [] denote default behavior of optional parameters. 
  =>  <>   Angle brackets denote user-specified arguments for a given parameter.
  => Command names, parameters and arguments are shown in small or “camel” case.


 Specific command usage
=======================
  
  qunex <command_name> 


 Display listing of all QuNex commands 
======================================

  qunex -a

EOF

}

qunex_failed() {
    reho ''
    reho ' ▄▄▄▄▄▄▄         ||  ▄▄   ▄▄                                                 '
    reho ' ▓▓    ▓         ||  ▓▓▓▄ ▓▓                ▓▓▓▓▓ ▄▓▓▓▓  ▓ ▄▓    ▄▓▓▓ ▓▓▓▄   '
    reho ' ▓▓  ▓ ▓  ▓   ▓  ||  ▓▓ ▐▓▓▓ ▄▄▄▄ ▀▓▓ ▓▓▀   ▓▓    ▓  ▓▓ ▓▓ ▓▓   ▄▓▓▄  ▓  ▓▓  '
    reho ' ▓▓▄▄▓▄▓  ▓▓  ▓  ||  ▓▓   ▓▓ ▓▄▄▓    ▓▄     ▓▓▀▀  ▓▓▓▓▓ ▓▌ ▓▓   ▀▓▓   ▓  ▓▓  '
    reho '     ▓▄▄  ▓▓▄▄▓  ||  ▓▓    ▓ ▓▄▄  ▄▓▓ ▓▓▄   ▓     ▓▀ ▓  ▓  ▓▓▓▀▀ ▓▓▓▓ ▓▓▓▀   ' 
    reho '                 ||                                                          '
    reho ''
}
 
qunex_passed() {
    geho ''
    geho '    ______         ║   _   _               ____                        _  '
    geho '   / ___  \_   _   ║  | \ | | _____  __   |  _ \ __ _ ___ ___  ___  __| | '
    geho '  | |   | | | | |  ║  |  \| |/ _ \ \/ /   | |_) / _` / __/ __|/ _ \/ _` | '
    geho '  | |_/\| | |_| |  ║  | |\  |  __/>  <    |  __| (_| \__ \__ |  __| (_| | '
    geho '   \__\ \ /\__,_|  ║  |_| \_|\___/_/\_\   |_|   \__,_|___|___/\___|\__,_| '
    geho '       \_\         ║                                                      '
    geho ''
}

# =======================================================================================================
# =========================================== CODE STARTS HERE ==========================================
# =======================================================================================================

# ------------------------------------------------------------------------------------------------------
# -- Help calls for QuNex Functions
# ------------------------------------------------------------------------------------------------------

qxutil_command_exec() {
    eval gmri ${gmriinput}
}

show_usage_qxutil() {
    echo ""
    gmri ?${usage_input}
}

show_all_qunex_commands() {
    gmri --allcommands
}

# ---------------------------------------------------------------------------------------------------------------
# -- Master Execution and Logging -- https://bitbucket.org/oriadev/qunex/wiki/Overview/Logging.md
# ---------------------------------------------------------------------------------------------------------------

bash_call_execute() {
    # -- Set platform info
    Platform="Platform Information: `uname -a`"
    # -- Set the time stamp for given job
    TimeStamp=`date +%Y-%m-%d_%H.%M.%10N`
    if [[ ${CommandToRun} == "run_turnkey" ]]; then
        unset qxutil_command_to_run
        if [[ ! -z `echo ${TURNKEY_STEPS} | grep -E 'create_study|createStudy'` ]] && [[ ! -f ${StudyFolder}/.qunexstudy ]]; then
            if [[ ! -d ${WORKDIR} ]]; then 
                mkdir -p ${WORKDIR} &> /dev/null
            fi
            gmri create_study ${StudyFolder}
        fi
    fi

    # -- Check if Matlab command
    unset QuNexMatlabCall
    matlab_functions_check=`find $TOOLS/$QUNEXREPO/matlab/ -name "*.m" | grep -v "archive/"`
    if [[ ! -z `echo $matlab_functions_check | grep "$CommandToRun"` ]]; then
        QuNexMatlabCall="$CommandToRun"
        echo ""
        echo " ==> Note: $QuNexMatlabCall is part of the QuNex MATLAB."
        echo ""
    fi 

    # -- Check if study folder is created
    if [[ ! -f ${StudyFolder}/.qunexstudy ]] && [[ -d ${StudyFolder} ]] && [[ -z ${QuNexMatlabCall} ]]; then 
        echo ""
        mageho "WARNING: QuNex study folder specification .qunexstudy in ${StudyFolder} not found."
        mageho "         Check that ${StudyFolder} is a valid QuNex folder."
        mageho "         Consider re-generating QuNex hierarchy..."; echo ""
        # gmri create_study ${StudyFolder}
    fi

    # -- Added checks for study folder generation
    if [[ -z ${QuNexMatlabCall} ]] && [[ -d ${StudyFolder}/sessions ]] && [[ ${SessionsFolder} != "sessions" ]] && [[ -f ${StudyFolder}/.qunexstudy ]]; then
        # -- Add check in case the sessions folder is distinct from the default name
        # -- Eventually use the template file to replace hard-coded values
        QuNexSessionsSubFolders=`more $TOOLS/$QUNEXREPO/python/qx_utilities/templates/study_folders_default.txt | tr -d '\r'`
        QuNexSessionsFolders="${SessionsFolder}/inbox/MR ${SessionsFolder}/inbox/EEG ${SessionsFolder}/inbox/BIDS ${SessionsFolder}/inbox/HCPLS ${SessionsFolder}/inbox/behavior ${SessionsFolder}/inbox/concs ${SessionsFolder}/inbox/events ${SessionsFolder}/archive/MR ${SessionsFolder}/archive/EEG ${SessionsFolder}/archive/BIDS ${SessionsFolder}/archive/HCPLS ${SessionsFolder}/archive/behavior ${SessionsFolder}/specs ${SessionsFolder}/QC"
        for QuNexSessionsFolder in ${QuNexSessionsFolders}; do
            if [[ ! -d ${QuNexSessionsFolder} ]]; then
                echo "QuNex folder ${QuNexSessionsFolder} not found. Generating now..."; echo ""
                mkdir -p ${QuNexSessionsFolder} &> /dev/null
            fi
        done
    fi

    # -- If logfolder flag set then set it and set master log
    if [[ -z ${LogFolder} ]]; then
        MasterLogFolder="${StudyFolder}/processing/logs"
    else
        MasterLogFolder="$LogFolder"
    fi

    if [[ ! -d ${MasterLogFolder} ]]; then
        mkdir ${MasterLogFolder} &> /dev/null
    fi

    # -- Set and generate runlogs folder
    MasterRunLogFolder="${MasterLogFolder}/runlogs"
    if [[ ! -d ${MasterRunLogFolder} ]]; then
        mkdir ${MasterRunLogFolder} &> /dev/null
    fi

    # -- Set and generate comlogs folder
    MasterComlogFolder="${MasterLogFolder}/comlogs"
    if [[ ! -d ${MasterComlogFolder} ]]; then
        mkdir ${MasterComlogFolder} &> /dev/null
    fi

    # -- Set and generate runchecks folder
    RunChecksFolder="${StudyFolder}/processing/runchecks"
    if [[ ! -d ${RunChecksFolder} ]]; then
        mkdir ${RunChecksFolder} &> /dev/null
    fi

    # -- Specific call for python qx_utilities functions
    if [[ ${qxutil_command_to_run} ]]; then
        echo ""
        cyaneho "--- Full QuNex call for command: ${qxutil_command_to_run}"
        echo ""
        cyaneho "gmri ${gmriinput}"
        echo ""
        cyaneho "---------------------------------------------------------"
        echo ""
        echo ""
        qxutil_command_exec
    else
        # -- Specific call for QuNex bash commands
        # -- Define specific logs
        #
        # -- Runlog
        # --   Specification: Log-<command name>-<date>_<hour>.<minute>.<microsecond>.log
        # --   Example:       Log-map_hcp_data-2017-11-11_15.58.1510433930.log
        Runlog="${MasterRunLogFolder}/Log-${CommandToRun}_${TimeStamp}.log"
        # -- Comlog
        # --   Specification:  tmp_<command_name>[_B<N>]_<session code>_<date>_<hour>.<minute>.<microsecond>.log
        # --   Specification:  error_<command_name>[_B<N>]_<session code>_<date>_<hour>.<minute>.<microsecond>.log
        # --   Specification:  done_<command_name>[_B<N>]_<session code>_<date>_<hour>.<minute>.<microsecond>.log
        # --   Example:        done_ComputeBOLDStats_pb0986_2017-05-06_16.16.1494101784.log
        ComlogTmp="${MasterComlogFolder}/tmp_${CommandToRun}_${CASE}_${TimeStamp}.log"; touch ${ComlogTmp}; chmod 777 ${ComlogTmp}
        ComRun="${MasterComlogFolder}/Run_${CommandToRun}_${CASE}_${TimeStamp}.sh"; touch ${ComRun}; chmod 777 ${ComRun}
        ComlogDone="${MasterComlogFolder}/done_${CommandToRun}_${CASE}_${TimeStamp}.log"
        CompletionCheckPass="${RunChecksFolder}/CompletionCheck_${CommandToRun}_${TimeStamp}.Pass"
        ComlogError="${MasterComlogFolder}/error_${CommandToRun}_${CASE}_${TimeStamp}.log"
        CompletionCheckFail="${RunChecksFolder}/CompletionCheck_${CommandToRun}_${TimeStamp}.Fail"
        # -- Batchlog
        # --   <batch system>_<command name>_job<job number>.<date>_<hour>.<minute>.<microsecond>.log
        echo ""
        cyaneho "--- Full QuNex call for command: ${CommandToRun}"
        echo ""
        cyaneho "${QuNexCallToRun}"
        echo ""
        cyaneho "--------------------------------------------------------------"
        echo ""
        echo ""
        # -- Declare commands
        echo "# Generated by QuNex ${QuNexVer} on ${TimeStamp}" >> ${Runlog}
        echo "#" >> ${Runlog}
        echo "${QuNexCallToRun}" >> ${Runlog}
        echo "#!/bin/bash" >> ${ComRun}
        echo "# Generated by QuNex ${QuNexVer} on ${TimeStamp}" >> ${ComRun}
        echo "#" >> ${ComRun}
        echo "export PYTHONUNBUFFERED=1" >> ${ComRun}
        echo "${QuNexCallToRun}" >> ${ComRun}
        chmod 777 ${ComRun}
        # -- Check that $ComRun is set properly
        echo ""; if [ ! -f "${ComRun}" ]; then reho "ERROR: ${ComRun} file not found. Check your inputs"; echo ""; return 1; fi
        ComRunSize=`wc -c < ${ComRun}` > /dev/null 2>&1
        echo ""; if [[ "${ComRunSize}" == 0 ]]; then > /dev/null 2>&1; reho "ERROR: ${ComRun} file found but has no content. Check your inputs"; echo ""; return 1; fi
        # -- Define command to execute
        echo "# Generated by QuNex ${QuNexVer} on ${TimeStamp}" >> ${ComlogTmp}
        echo "#" >> ${ComlogTmp}
        ComRunExec=". ${ComRun} 2>&1 | tee -a ${ComlogTmp}"
        # -- Acceptance tests
        ComComplete="cat ${ComlogTmp} | grep 'Successful completion' > ${CompletionCheckPass}"
        ComError="cat ${ComlogTmp} | grep 'ERROR' > ${CompletionCheckFail}"
        # -- Garbage collection
        ComGarbageCollect="if [[ -f 0 && ! -s 0 ]]; then echo 'delete' >> qunex_garbage0; fi; if [[ -s 1 ]]; then cat 1 | grep 'qunex' > qunex_garbage1; fi; if [[ -s 2 ]]; then cat 2 | grep 'FSL_FIX_MCRROOT' >> qunex_garbage2; fi"
        ComGarbageRemove="if [[ -s qunex_garbage0 ]]; then rm 0; rm qunex_garbage0; fi; if [[ -s qunex_garbage1 ]]; then rm 1; rm qunex_garbage1; fi; if [[ -s qunex_garbage2 ]]; then rm 2; rm qunex_garbage2; fi"
        ComRunGarbage="${ComGarbageCollect}; ${ComGarbageRemove}"
        # -- Run the commands locally
        if [[ ${Cluster} == 1 ]]; then
            # -- Command to perform acceptance test
            ComRunCheck="if [[ -s ${CompletionCheckPass} && ! -s ${CompletionCheckFail} ]]; then mv ${ComlogTmp} ${ComlogDone}; echo ''; echo ' ===> Successful completion of ${CommandToRun}. Check final QuNex log output:'; echo ''; echo '    ${ComlogDone}'; qunex_passed; echo ''; else mv ${ComlogTmp} ${ComlogError}; echo ''; echo ' ===> ERROR during ${CommandToRun}. Check final QuNex error log output:'; echo ''; echo '    ${ComlogError}'; echo ''; qunex_failed; fi"
            # -- Combine final string of commands
            ComRunAll="${ComRunExec}; ${ComComplete}; ${ComError}; ${ComRunCheck}; ${ComRunGarbage}"
            geho "--------------------------------------------------------------"
            echo ""
            geho "   Running ${CommandToRun} locally on `hostname`"
            geho "   Command log:     ${Runlog}  "
            geho "   Command output: ${ComlogTmp} "
            echo ""
            geho "--------------------------------------------------------------"
            echo ""
            eval "${ComRunAll}"
        fi
        # -- Run the commands via scheduler
        if [[ ${Cluster} == 2 ]]; then
            # -- Command to perform acceptance test
            ComRunCheck="if [[ -s ${CompletionCheckPass} && ! -s ${CompletionCheckFail} ]]; then mv ${ComlogTmp} ${ComlogDone}; echo ''; echo ' ===> Successful completion of ${CommandToRun}. Check final QuNex log output:'; echo ''; echo '    ${ComlogDone}'; echo ''; echo 'QUNEX PASSED!'; echo ''; else mv ${ComlogTmp} ${ComlogError}; echo ''; echo ' ===> ERROR during ${CommandToRun}. Check final QuNex error log output:'; echo ''; echo '    ${ComlogError}'; echo ''; echo ''; echo 'QUNEX FAILED!'; fi"
            # -- Combine final string of commands
            ComRunAll="${ComRunExec}; ${ComComplete}; ${ComError}; ${ComRunCheck}; ${ComRunGarbage}"
            cd ${MasterRunLogFolder}
            gmri schedule command="${ComRunAll}" settings="${Scheduler}" bash="${Bash}"
            geho "--------------------------------------------------------------"
            echo ""
            geho "   Data successfully submitted to scheduler"
            geho "   Scheduler details: ${Scheduler}"
            geho "   Command log: ${Runlog}"
            geho "   Command output: ${ComlogTmp} "
            echo ""
            geho "--------------------------------------------------------------"
            echo ""
        fi
    fi
}

# ---------------------------------------------------------------------------------------------------------------
# -- run_turnkey - Turnkey execution of QuNex workflow via the XNAT docker engine
# ---------------------------------------------------------------------------------------------------------------

run_turnkey() {
    # -- Specify command variable
    unset QuNexCallToRun
    unset qxutil_command_to_run
    QuNexCallToRun="${TOOLS}/${QUNEXREPO}/bash/qx_utilities/run_turnkey.sh --bolds=\"${BOLDS// /,}\" ${runTurnkeyArguments} --sessions=\"${CASE}\" --turnkeysteps=\"${TURNKEY_STEPS// /,}\" --sessionids=\"${CASE}\""
    bash_call_execute
}

show_usage_run_turnkey() {
    ${TOOLS}/${QUNEXREPO}/bash/qx_utilities/run_turnkey.sh
}

# -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
# -- dwi_legacy - Executes the Diffusion Processing Script via FUGUE implementation for legacy data - (needed for legacy DWI data that is non-HCP compliant without counterbalanced phase encoding directions needed for topup)
# -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

dwi_legacy() {
    # -- Specify command variable
    QuNexCallToRun="${TOOLS}/${QUNEXREPO}/bash/qx_utilities/dwi_legacy.sh \
    --sessionsfolder=${SessionsFolder} \
    --session=${CASE} \
    --scanner=${Scanner} \
    --usefieldmap=${UseFieldmap} \
    --PEdir=${PEdir} \
    --echospacing=${EchoSpacing} \
    --TE=${TE} \
    --unwarpdir=${UnwarpDir} \
    --diffdatasuffix=${DiffDataSuffix} \
    --overwrite=${Overwrite}"
    # -- QuNex bash execute function
    bash_call_execute
}

show_usage_dwi_legacy() {
    echo ""; echo "qunex ${usage_input}"
    ${TOOLS}/${QUNEXREPO}/bash/qx_utilities/dwi_legacy.sh
}

# -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
# -- dwi_eddy_qc - Executes the DWI EddyQ C (dwi_eddy_qc.sh) via the QuNex bash wrapper
# -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

dwi_eddy_qc() {
    # -- Check if eddy_squad and eddy_quad exist in user path
    EddySquadCheck=`which eddy_squad`
    EddyQuadCheck=`which eddy_quad`
    if [[ -z ${EddySquadCheck} ]] || [[ -z ${EddySquadCheck} ]]; then
        echo ""
        reho "ERROR: EDDY QC does not seem to be installed on this system."
        echo ""
        exit 1
    fi
    # -- Specify command variable
    QuNexCallToRun=". ${TOOLS}/${QUNEXREPO}/bash/qx_utilities/dwi_eddy_qc.sh \
    --sessionsfolder=${SessionsFolder} \
    --session=${CASE} \
    --eddybase=${EddyBase} \
    --eddypath=${EddyPath} \
    --report=${Report} \
    --bvalsfile=${BvalsFile} \
    --mask=${Mask} \
    --eddyidx=${EddyIdx} \
    --eddyparams=${EddyParams} \
    --bvecsfile=${BvecsFile} \
    --overwrite=${Overwrite}"
    # -- QuNex bash execute function
    bash_call_execute
}

show_usage_dwi_eddy_qc() {
    echo ""; echo "qunex ${usage_input}"
    ${TOOLS}/${QUNEXREPO}/bash/qx_utilities/dwi_eddy_qc.sh
}

# -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
# -- dwi_parcellate - Executes the Diffusion Parcellation Script (dwi_parcellate.sh) via the QuNex bash wrapper
# -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

dwi_parcellate() {
    # -- Specify command variable
    QuNexCallToRun=". ${TOOLS}/${QUNEXREPO}/bash/qx_utilities/dwi_parcellate.sh \
    --sessionsfolder=${SessionsFolder} \
    --session=${CASE} \
    --matrixversion=${MatrixVersion} \
    --parcellationfile=${ParcellationFile} \
    --waytotal=${WayTotal} \
    --lengths=${Lengths} \
    --outname=${OutName} \
    --overwrite=${Overwrite}"
    # -- QuNex bash execute function
    bash_call_execute
}

show_usage_dwi_parcellate() {
    echo ""
    echo "qunex ${usage_input}"
    ${TOOLS}/${QUNEXREPO}/bash/qx_utilities/dwi_parcellate.sh
}

# -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
# -- dwi_seed_tractography_dense - Executes the Diffusion Seed Tractography Script (dwi_seed_tractography_dense.sh) via the QuNex bash wrapper
# -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

dwi_seed_tractography_dense() {
    # -- Specify command variable
    QuNexCallToRun="dwi_seed_tractography_dense.sh \
    --sessionsfolder="${SessionsFolder}" \
    --sessions="${CASE}" \
    --matrixversion="${MatrixVersion}" \
    --seedfile="${SeedFile}" \
    --waytotal="${WayTotal}" \
    --outname="${OutName}" \
    --overwrite="${Overwrite}""
    # -- QuNex bash execute function
    bash_call_execute
}

show_usage_dwi_seed_tractography_dense() {
    echo "qunex ${usage_input}"
    ${TOOLS}/${QUNEXREPO}/bash/qx_utilities/dwi_seed_tractography_dense.sh
}

# -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
# -- compute_bold_fc - Executes Global Brain Connectivity (GBC) or seed-based functional connectivity (fc_compute_wrapper.sh) via the QuNex bash wrapper
# -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

compute_bold_fc() {
    # -- Check type of run
    OutPath="$OutPathFC"
    if [[ ${RunType} == "individual" ]]; then
        OutPath="${SessionsFolder}/${CASE}/${InputPath}"
        # -- Make sure individual runs default to the original input path location (/images/functional)
        if [[ ${InputPath} == "" ]]; then
            InputPath="${SessionsFolder}/${CASE}/images/functional"
        fi
        # -- Make sure individual runs default to the original input path location (/images/functional)
        if [[ ${OutPath} == "" ]]; then
            OutPath="${SessionsFolder}/${CASE}/${InputPath}"
        fi
    fi

    # -- Check type of connectivity calculation is seed
    if [[ ${Calculation} == "seed" ]]; then
        echo ""
        # -- Specify command variable
        QuNexCallToRun="${TOOLS}/${QUNEXREPO}/bash/qx_utilities/fc_compute_wrapper.sh \
        --sessionsfolder=${SessionsFolder} \
        --calculation=${Calculation} \
        --runtype=${RunType} \
        --sessions=${CASE} \
        --inputfiles=${InputFiles} \
        --inputpath=${InputPath} \
        --extractdata=${ExtractData} \
        --outname=${OutName} \
        --flist=${FileList} \
        --overwrite=${Overwrite} \
        --ignore=${IgnoreFrames} \
        --roinfo=${ROIInfo} \
        --options=${FCCommand} \
        --method=${Method} \
        --targetf=${OutPath} \
        --mask='${MaskFrames}' \
        --covariance=${Covariance}"
        # -- QuNex bash execute function
        bash_call_execute
    fi

    # -- Check type of connectivity calculation is gbc
    if [[ ${Calculation} == "gbc" ]]; then
        echo ""
        # -- Specify command variable
        QuNexCallToRun="${TOOLS}/${QUNEXREPO}/bash/qx_utilities/fc_compute_wrapper.sh \
        --sessionsfolder=${SessionsFolder} \
        --calculation=${Calculation} \
        --runtype=${RunType} \
        --sessions=${CASE} \
        --inputfiles=${InputFiles} \
        --inputpath=${InputPath} \
        --extractdata=${ExtractData} \
        --outname=${OutName} \
        --flist=${FileList} \
        --overwrite=${Overwrite} \
        --ignore=${IgnoreFrames} \
        --target=${TargetROI} \
        --gbc-command=${GBCCommand} \
        --targetf=${OutPath} \
        --mask=${MaskFrames} \
        --rsmooth=${RadiusSmooth} \
        --rdilate=${RadiusDilate} \
        --verbose=${Verbose} \
        --time=${ComputeTime} \
        --vstep=${VoxelStep} \
        --covariance=${Covariance}"
        # -- QuNex bash execute function
        bash_call_execute
    fi

    # -- Check type of connectivity calculation is seed
    if [[ ${Calculation} == "dense" ]]; then
        echo ""
        # -- Specify command variable
        QuNexCallToRun="${TOOLS}/${QUNEXREPO}/bash/qx_utilities/fc_compute_wrapper.sh \
        --sessionsfolder=${SessionsFolder} \
        --calculation=${Calculation} \
        --runtype=${RunType} \
        --sessions=${CASE} \
        --inputfiles=${InputFiles} \
        --inputpath=${InputPath} \
        --outname=${OutName} \
        --overwrite=${Overwrite} \
        --targetf=${OutPath} \
        --covariance=${Covariance} \
        --mem-limit=${MemLimit} "
        # -- QuNex bash execute function
        bash_call_execute
    fi
}

show_usage_compute_bold_fc() {
    echo ""; echo "qunex ${usage_input}"
    ${TOOLS}/${QUNEXREPO}/bash/qx_utilities/fc_compute_wrapper.sh
}

# -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
# -- parcellate_anat - Executes the Structural Parcellation Script (StructuralParcellation.sh) via the QuNex bash wrapper
# -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

parcellate_anat() {
    # -- Parse general parameters
    QUEUE="$QUEUE"
    SessionsFolder="$SessionsFolder"
    CASE=${CASE}
    InputDataType="$InputDataType"
    OutName="$OutName"
    ParcellationFile="$ParcellationFile"
    ExtractData="$ExtractData"
    Overwrite="$Overwrite"
    # -- Specify command variable
    QuNexCallToRun=". ${TOOLS}/${QUNEXREPO}/bash/qx_utilities/parcellate_anat.sh \
    --sessionsfolder=${SessionsFolder} \
    --session=${CASE} \
    --inputdatatype=${InputDataType} \
    --parcellationfile=${ParcellationFile} \
    --overwrite=${Overwrite} \
    --outname=${OutName} \
    --extractdata=${ExtractData}"
    # -- QuNex bash execute function
    bash_call_execute
}

show_usage_parcellate_anat() {
    echo ""; echo "qunex ${usage_input}"
    ${TOOLS}/${QUNEXREPO}/bash/qx_utilities/parcellate_anat.sh
}

# -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
# -- parcellate_bold - Executes the BOLD Parcellation Script (parcellate_bold.sh) via the QuNex bash wrapper
# -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

bold_parcellation() {
    # -- Parse general parameters
    if [[ -z ${SingleInputFile} ]]; then
        BOLDOutput="${SessionsFolder}/${CASE}/${OutPath}"
    else
        BOLDOutput="${OutPath}"
    fi
    # -- Specify command variable
    QuNexCallToRun=". ${TOOLS}/${QUNEXREPO}/bash/qx_utilities/parcellate_bold.sh \
    --sessionsfolder='${SessionsFolder}' \
    --sessions='${CASE}' \
    --inputfile='${InputFile}' \
    --singleinputfile='${SingleInputFile}' \
    --inputpath='${InputPath}' \
    --inputdatatype='${InputDataType}' \
    --parcellationfile='${ParcellationFile}' \
    --overwrite='${Overwrite}' \
    --outname='${OutName}' \
    --outpath='${OutPath}' \
    --computepconn='${ComputePConn}' \
    --extractdata='${ExtractData}' \
    --useweights='${UseWeights}' \
    --weightsfile='${WeightsFile}'"
    # -- QuNex bash execute function
    bash_call_execute
}

show_usage_parcellate_bold() {
    echo ""; echo "qunex ${usage_input}"
    ${TOOLS}/${QUNEXREPO}/bash/qx_utilities/parcellate_bold.sh
}

# -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
# -- extract_roi - Executes the ROI Extraction Script (extract_roi.sh) via the QuNex bash wrapper
# -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

extract_roi() {
    # -- Parse general parameters
    ROIFileSessionSpecific="$ROIFileSessionSpecific"
    SingleInputFile="$SingleInputFile"
    if [[ -z ${SingleInputFile} ]]; then
        OutPath="${SessionsFolder}/${CASE}/${OutPath}"
    else
        OutPath="${OutPath}"
        InputFile="${SingleInputFile}"
    fi
    if [[ ${ROIFileSessionSpecific} == "no" ]]; then
        ROIFile="${ROIFile}"
    else
        ROIFile="${SessionsFolder}/${CASE}/${ROIFile}"
    fi
    # -- Specify command variable
    QuNexCallToRun=". ${TOOLS}/${QUNEXREPO}/bash/qx_utilities/extract_roi.sh \
    --roifile='${ROIInputFile}' \
    --inputfile='${InputFile}' \
    --outdir='${OutPath}' \
    --outname='${OutName}'"
    # -- QuNex bash execute function
    bash_call_execute
}

show_usage_roi_extract() {
    echo ""
    echo "qunex ${usage_input}"
    ${TOOLS}/${QUNEXREPO}/bash/qx_utilities/extract_roi.sh
}

# ------------------------------------------------------------------------------------------------------
# -- dwi_dtifit - Executes the dtifit script from FSL (needed for probabilistic tractography)
# ------------------------------------------------------------------------------------------------------

dwi_dtifit() {
    # -- Parse optional parameters
    optional_parameters=""

    # mask
    if [[ -n ${mask} ]]; then
        optional_parameters=" \
        --mask='${mask}'
        "
    fi

    # bvecs
    if [[ -n ${bvecs} ]]; then
        optional_parameters="${optional_parameters} \
        --bvecs='${bvecs}'
        "
    fi

    # bvals
    if [[ -n ${bvals} ]]; then
        optional_parameters="${optional_parameters} \
        --bvals='${bvals}'
        "
    fi

    # cni
    if [[ -n ${cni} ]]; then
        optional_parameters="${optional_parameters} \
        --cni='${cni}'
        "
    fi

    # sse
    if [[ -n ${sse} ]]; then
        optional_parameters="${optional_parameters} \
        --sse
        "
    fi

    # wls
    if [[ -n ${wls} ]]; then
        optional_parameters="${optional_parameters} \
        --wls
        "
    fi

    # kurt
    if [[ -n ${kurt} ]]; then
        optional_parameters="${optional_parameters} \
        --kurt
        "
    fi

    # kurtdir
    if [[ -n ${kurtdir} ]]; then
        optional_parameters="${optional_parameters} \
        --kurtdir
        "
    fi

    # littlebit
    if [[ -n ${littlebit} ]]; then
        optional_parameters="${optional_parameters} \
        --littlebit
        "
    fi

    # save_tensor
    if [[ -n ${save_tensor} ]]; then
        optional_parameters="${optional_parameters} \
        --save_tensor
        "
    fi

    # zmin
    if [[ -n ${zmin} ]]; then
        optional_parameters="${optional_parameters} \
        --zmin='${zmin}'
        "
    fi

    # zmax
    if [[ -n ${zmax} ]]; then
        optional_parameters="${optional_parameters} \
        --zmax='${zmax}'
        "
    fi

    # ymin
    if [[ -n ${ymin} ]]; then
        optional_parameters="${optional_parameters} \
        --ymin='${ymin}'
        "
    fi

    # ymax
    if [[ -n ${ymax} ]]; then
        optional_parameters="${optional_parameters} \
        --ymax='${ymax}'
        "
    fi

    # xmin
    if [[ -n ${xmin} ]]; then
        optional_parameters="${optional_parameters} \
        --xmin='${xmin}'
        "
    fi

    # xmax
    if [[ -n ${xmax} ]]; then
        optional_parameters="${optional_parameters} \
        --xmax='${xmax}'
        "
    fi

    # gradnonlin
    if [[ -n ${gradnonlin} ]]; then
        optional_parameters="${optional_parameters} \
        --gradnonlin='${gradnonlin}''
        "
    fi

    # -- Specify command variable
    QuNexCallToRun=". ${TOOLS}/${QUNEXREPO}/bash/qx_utilities/dwi_dtifit.sh \
    --sessionsfolder='${SessionsFolder}' \
    --session='${CASE}' \
    --overwrite='${Overwrite}' \
    --species='${Species}' ${optional_parameters}"

    # -- QuNex bash execute function
    bash_call_execute
}

show_usage_dwi_dtifit() {
    echo ""; echo "qunex ${usage_input}"
    ${TOOLS}/${QUNEXREPO}/bash/qx_utilities/dwi_dtifit.sh
}

# ------------------------------------------------------------------------------------------------------
# -- dwi_bedpostx_gpu - Executes the bedpostx_gpu code from FSL (needed for probabilistic tractography)
# ------------------------------------------------------------------------------------------------------

dwi_bedpostx_gpu() {
    # -- Specify command variable
    QuNexCallToRun=". ${TOOLS}/${QUNEXREPO}/bash/qx_utilities/dwi_bedpostx_gpu.sh \
    --sessionsfolder='${SessionsFolder}' \
    --session='${CASE}' \
    --fibers='${Fibers}' \
    --weight='${Weight}' \
    --burnin='${Burnin}' \
    --jumps='${Jumps}' \
    --sample='${Sample}' \
    --model='${Model}' \
    --rician='${Rician}' \
    --gradnonlin='${Gradnonlin}' \
    --overwrite='${Overwrite}' \
    --species='${Species}'"
    # -- QuNex bash execute function
    bash_call_execute
}

show_usage_dwi_bedpostx_gpu() {
    echo ""; echo "qunex ${usage_input}"
    ${TOOLS}/${QUNEXREPO}/bash/qx_utilities/dwi_bedpostx_gpu.sh
}

# ------------------------------------------------------------------------------------------------------------------------------
# -- auto_ptx - Executes the auto_ptx script from FSL (needed for probabilistic estimation of large-scale fiber bundles / tracts)
# -------------------------------------------------------------------------------------------------------------------------------

auto_ptx() {
    geho "WARNING: auto_ptx is deprecated, you should probably use dwi_xtract instead!"

    # -- Check inputs
    if [[ -d ${BedPostXFolder} ]]; then 
        reho "ERROR: Prior BedpostX run not found or incomplete for $CASE. Check work and re-run."
        exit 1
    fi
    if [[ -z ${AutoPtxFolder} ]]; then 
        reho "ERROR: AutoPtxFolder environment variable not. Set it correctly and re-run."
        exit 1
    fi
    # -- Set commands
    Com1="${AutoPtxFolder}/autoptx ${SessionsFolder} ${CASE} ${BedPostXFolder}"
    Com2="${AutoPtxFolder}/prepare_for_display.sh ${StudyFolder}/${CASE}/MNINonLinear/Results/autoptx 0.005 1"
    Com3="${AutoPtxFolder}/prepare_for_display.sh ${StudyFolder}/${CASE}/MNINonLinear/Results/autoptx 0.005 0"
    # -- Specify command variable
    QuNexCallToRun="${Com1}; ${Com2}; ${Com3}"
    # -- QuNex bash execute function
    bash_call_execute
}

show_usage_auto_ptx() {
    echo ""
    echo "qunex ${usage_input} "
    echo ""
    echo "This command runs the auto_ptx script in ${AutoPtxFolder}."
    echo ""
    echo "For full details on auto_ptx functionality see: https://fsl.fmrib.ox.ac.uk/fsl/fslwiki/AutoPtx"
    echo ""
}

# -------------------------------------------------------------------------------------------------------------------
# -- Executes the HCP Pretractography (dwi_pre_tractography) [ Stam's implementation for all grayordinates ]
# ------------------------------------------------------------------------------------------------------------------

dwi_pre_tractography() {
    # -- Parse general parameters
    RunFolder="${SessionsFolder}/${CASE}/hcp/"
    # -- Specify command variable
    QuNexCallToRun="${HCPPIPEDIR_dMRITractFull}/pre_tractography/pre_tractography.sh ${RunFolder} ${CASE} 0"
    # -- QuNex bash execute function
    bash_call_execute
}

show_usage_dwi_pre_tractography() {
    echo ""; echo "qunex ${usage_input}"
    ${HCPPIPEDIR_dMRITractFull}/pre_tractography/pre_tractography.sh
}

# --------------------------------------------------------------------------------------------------------------------------------------------------
# -- dwi_probtrackx_dense_gpu - Executes the HCP Matrix1 and / or 3 code and generates WB dense connectomes (Stam's implementation for all grayordinates)
# --------------------------------------------------------------------------------------------------------------------------------------------------

dwi_probtrackx_dense_gpu() {
    # -- Specify command variable
    QuNexCallToRun=". ${TOOLS}/${QUNEXREPO}/bash/qx_utilities/dwi_probtrackx_dense_gpu.sh \
    --sessionsfolder='${SessionsFolder}' \
    --sessions='${CASES}' \
    --scriptsfolder='${ScriptsFolder}' \
    --omatrix1='${MatrixOne}' \
    --omatrix3='${MatrixThree}' \
    --nsamplesmatrix1='${NsamplesMatrixOne}' \
    --nsamplesmatrix3='${NsamplesMatrixThree}' \
    --distancecorrection='${distance_correction}' \
    --storestreamlineslength='${store_streamlines_length}' \
    --overwrite='${Overwrite}' "
    # -- QuNex bash execute function
    bash_call_execute
}

show_usage_dwi_probtrackx_dense_gpu() {
    echo ""; echo "qunex ${usage_input}"
    ${TOOLS}/${QUNEXREPO}/bash/qx_utilities/dwi_probtrackx_dense_gpu.sh
}

# ------------------------------------------------------------------------------------------------------------------------------
# -- run_qc - Performs various QC operations across modalities
# -------------------------------------------------------------------------------------------------------------------------------

run_qc() {
    # -- Check general output folders for QC
    if [ ! -d ${SessionsFolder}/QC ]; then
        mkdir -p ${SessionsFolder}/QC &> /dev/null
    fi
    # -- Check T1w output folders for QC
    if [ ! -d ${OutPath} ]; then
        mkdir -p ${OutPath} &> /dev/null
    fi
    # -- Specify command variable
    QuNexCallToRun=". ${TOOLS}/${QUNEXREPO}/bash/qx_utilities/run_qc.sh \
    --sessionsfolder='${SessionsFolder}' \
    --sessions='${CASE}' \
    --outpath='${OutPath}' \
    --overwrite='${Overwrite}' \
    --scenetemplatefolder='${scenetemplatefolder}' \
    --modality='${Modality}' \
    --datapath='${GeneralSceneDataPath}' \
    --datafile='${GeneralSceneDataFile}' \
    --customqc=${runQC_Custom} \
    --omitdefaults=${OmitDefaults} \
    --dwipath='${DWIPath}' \
    --dwidata='${DWIData}' \
    --dwilegacy='${DWILegacy}' \
    --dtifitqc='${DtiFitQC}' \
    --bedpostxqc='${BedpostXQC}' \
    --eddyqcstats='${EddyQCStats}' \
    --bolddata='${BOLDLIST}' \
    --boldprefix='${BOLDPrefix}' \
    --boldsuffix='${BOLDSuffix}' \
    --skipframes='${SkipFrames}' \
    --snronly='${SNROnly}' \
    --timestamp='${TimeStamp}' \
    --scenezip='${SceneZip}' \
    --boldfc='${BOLDfc}' \
    --boldfcinput='${BOLDfcInput}' \
    --boldfcpath='${BOLDfcPath}' \
    --suffix='${Suffix}' \
    --hcp_suffix='${HCPSuffix}' \
    --batchfile='${SessionBatchFile}' "
    # -- QuNex bash execute function
    bash_call_execute
}

show_usage_run_qc() {
    echo ""; echo "qunex ${usage_input}"
    ${TOOLS}/${QUNEXREPO}/bash/qx_utilities/run_qc.sh
}

# =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-==-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-==-=-=-=-=-=-=
# =-=-=-=-=-==-=-=-= Establish general QuNex functions and variables =-=-=-=-=-=-=-=-=-=-=
# =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-==-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-==-=-=-=-=-=-=

# ------------------------------------------------------------------------------
# -- Capture current working directory
# ------------------------------------------------------------------------------
dirs -c  &> /dev/null
pushd `pwd` &> /dev/null


# ------------------------------------------------------------------------------
# -- Load relevant libraries for logging and parsing options
# ------------------------------------------------------------------------------
if [[ ! -z $HCPPIPEDIR ]]; then
    source $HCPPIPEDIR/global/scripts/log.shlib  # -- Logging related functions
    source $HCPPIPEDIR/global/scripts/opts.shlib # -- Command line option functions
fi


# ------------------------------------------------------------------------------
# -- Load Core Functions
# ------------------------------------------------------------------------------

# -- Parses the input command line for a specified command line option
# -- The first parameter is the command line option to look for.
# -- The remaining parameters are the full list of flagged command line arguments
get_parameters() {
    sopt="$1"
    shift 1
    for fn in "$@" ; do
        if [ `echo $fn | grep -- "^${sopt}=" | wc -w` -gt 0 ]; then
            echo $fn | sed "s/^${sopt}=//"
            return 0
        fi
    done
}

# -- Same as above except this works on flags
get_flags() {
    sopt="$1"
    shift 1
    for fn in "$@" ; do
        if [ `echo $fn | grep -- "^${sopt}" | wc -w` -gt 0 ]; then
            echo "yes"
            return 0
        fi
    done
}

# -- Checks command line arguments for "--help" indicating that help has been requested
check_help_request() {
    for fn in "$@" ; do
        if [[ ${fn} = "--help" ]]; then
            return 0
        fi
    done
}

# -- Set and report version
QuNexVer=`cat ${TOOLS}/${QUNEXREPO}/VERSION.md`
echo ""
geho " ........................ Running QuNex v${QuNexVer} ........................"
echo ""

# -- Checks for version
show_version() {
    QuNexVer=`cat ${TOOLS}/${QUNEXREPO}/VERSION.md`
    echo ""
    echo "Quantitative Neuroimaging Environment & Toolbox (QuNex) Suite Version: ${QuNexVer}"
}


# ------------------------------------------------------------------------------
# -- Parse Command Line Options
# ------------------------------------------------------------------------------

# -- Check if version was requested
if [ "$1" == "-version" ] || [ "$1" == "version" ] || [ "$1" == "--version" ] || [ "$1" == "--v" ] || [ "$1" == "-v" ]; then
    show_version
    echo ""
    exit 0
fi

# -- Check if version was requested
if [ "$1" == "-splash" ] || [ "$1" == "splash" ] || [ "$1" == "--splash" ] || [ "$1" == "--s" ] || [ "$1" == "-s" ]; then
    show_splash
    echo ""
    exit 0
fi

if [ $(check_help_request $@) ]; then
    show_splash
    show_usage
    exit 0
fi

if [[ -z ${1} ]]; then
    show_splash
    show_usage
    exit 0
fi

if [[ ${1} == "help" ]]; then
    show_splash
    show_usage
    exit 0
fi

if [[ ${1} == "--envsetup" ]] || [[ ${1} == "-envsetup" ]] || [[ ${1} == "envsetup" ]]; then
    show_version
    echo ""
    echo "Printing help call for $TOOLS/$QUNEXREPO/env/qunex_environment.sh"
    echo ""
    bash ${TOOLS}/$QUNEXREPO/env/qunex_environment.sh --help
    exit 0
fi

# ------------------------------------------------------------------------------
# -- Map deprecated commands
# ------------------------------------------------------------------------------

# -- Use the check_deprecated_commands from niutilities to remap 
if [[ $1 != --* ]]; then
    # grep the command
    deprecation=`gmri check_deprecated_commands --command="$1"`
    # print and set new command if something was deprecated
    if [[ -n $deprecation ]]; then
        echo ""
        echo $deprecation
        command_name=`echo $deprecation | grep "is now known as" | sed 's/^.*is now known as //g'`
        if [[ -n $command_name ]]; then
            set -- ${command_name} "${@:2}"
        fi
    fi
fi


# ------------------------------------------------------------------------------
# -- gmri outside local commands to bypass checking
# ------------------------------------------------------------------------------

# -- Get list of all supported gmri commands
gmri_commands=`gmri -available`
# -- Check if command-line input matches any of the gmri commands
unset qxutil_command_to_run
is_gmri_command=0

for gmri_command in $gmri_commands; do
    if [[ $gmri_command == $1 ]]; then
        is_gmri_command=1
    fi
done

if [[ $is_gmri_command == 1 ]]; then
    # -- If yes then set the gmri function variable
    qxutil_command_to_run="$1"

    # -- Check for input with question mark
    if [[ "$qxutil_command_to_run" =~ .*"?".* ]] && [[ -z ${2} ]]; then
        # -- Set usage_input variable to pass and remove question mark
        usage_input=`echo ${qxutil_command_to_run} | cut -c 2-`
        # -- If no other input is provided print help
        show_usage_qxutil
        exit 0
    fi

    # -- Check for input with flag mark
    if [[ "$qxutil_command_to_run" =~ .*"-".* ]] && [[ -z ${2} ]]; then
        # -- Set usage_input variable to pass and remove question mark
        usage_input=`echo ${qxutil_command_to_run} | cut -c 2-`
        # -- If no other input is provided print help
        show_usage_qxutil
        exit 0
    fi

    # -- Check for input is command name with no other arguments
    if [[ "$qxutil_command_to_run" != *"-"* ]] && [[ -z ${2} ]]; then
        usage_input="$qxutil_command_to_run"
        # -- If no other input is provided print help
        show_usage_qxutil
        exit 0
    # -- Otherwise pass the command with all inputs from the command line
    else
        # -- Handle input parameters
        unset gmriinput

        for inputarg in "$@"; do

            # flags
            if [[ ${inputarg} =~ '=' ]]; then
                if [[ $inputarg =~ "\"" ]]; then
                    inputarg=`echo "${inputarg}'" | sed "0,/=/s//=\'/"`
                else
                    inputarg=`echo "${inputarg}\"" | sed "0,/=/s//=\"/"`
                fi
            fi

            if [[ -z $gmriinput ]]; then
                gmriinput="${inputarg}"
            else
                gmriinput="${gmriinput} ${inputarg}"
            fi
        done
    fi

    # execute
    bash_call_execute

    exit 0
else
    unset qxutil_command_to_run
fi


# ------------------------------------------------------------------------------
# -- Check if specific command help requested
# ------------------------------------------------------------------------------

# -- Check if command is supported
is_qunex_command() {
    # check if qunex bash command
    is_qunex_command=0
    for qunex_command in $qunex_commands; do
        if [[ $qunex_command == $1 ]]; then
            is_qunex_command=1
        fi
    done
    if [[ $is_qunex_command == 1 ]]; then
        show_usage_"$1"
        exit 0
    else
        echo ""
        reho "ERROR: $1 --> Requested command is not supported. Refer to general QuNex usage."
        echo ""
        exit 0
    fi
}

# -- Check for input with double flags
if [[ ${1} =~ .*--.* ]] && [[ -z ${2} ]] || [[ ${1} =~ .*-.* ]] && [[ -z ${2} ]]; then
    Usage="$1"
    if [[ ${Usage} == "--a" ]] || [[ ${Usage} == "--all" ]] || [[ ${Usage} == "--allcommands" ]]; then
        show_splash
        show_all_qunex_commands
        exit 0
    fi
fi

# -- Check for input with single flags
if [[ ${1} =~ .*-.* ]] && [[ -z ${2} ]]; then
    Usage="$1"
    if [[ ${Usage} == "-a" ]] || [[ ${Usage} == "-all" ]] || [[ ${Usage} == "-allcommands" ]]; then
        show_splash
        show_all_qunex_commands
        exit 0
    fi  
fi

# -- Check for input with question mark
HelpInputUsage="$1"
if [[ ${HelpInputUsage:0:1} == "?" ]] && [[ -z ${2} ]]; then
    Usage="$1"
    usage_input=`echo ${Usage} | cut -c 2-`
    # -- Check if input part of function list
    is_qunex_command ${usage_input}
    show_version
    show_usage_"${usage_input}"
    exit 0
fi

# -- Check for input with no flags
if [[ -z ${2} ]]; then
    usage_input="$1"
    # -- Check if input part of function list
    is_qunex_command ${usage_input}
    show_version
    show_usage_"${usage_input}"
    exit 0
fi


# ------------------------------------------------------------------------------
# -- Check if running script interactively or using flag arguments
# ------------------------------------------------------------------------------

# -- Clear variables for new run
unset CommandToRun
unset sessions
unset StudyFolder
unset CASES
unset Overwrite
unset Scheduler
unset ClusterName
unset setflag
unset doubleflag
unset singleflag
unset SESSIONIDS
unset SESSIONS
unset SESSION_LABELS

# -- Check if first parameter is missing flags and parse it as CommandToRun
if [ -z `echo "$1" | grep '-'` ]; then
    CommandToRun="$1"
    # -- Check if single or double flags are set
    doubleflagparameter=`echo $2 | cut -c1-2`
    singleflagparameter=`echo $2 | cut -c1`
    if [[ ${doubleflagparameter} == "--" ]]; then
        setflag="$doubleflagparameter"
    else
        if [[ ${singleflagparameter} == "-" ]]; then
            setflag="$singleflagparameter"
        fi
    fi
else
    # -- Check if single or double flags are set
    doubleflag=`echo $1 | cut -c1-2`
    singleflag=`echo $1 | cut -c1`
    if [[ ${doubleflag} == "--" ]]; then
        setflag="$doubleflag"
    else
        if [[ ${singleflag} == "-" ]]; then
            setflag="$singleflag"
        fi
    fi
fi

# -- Check if command is run_turnkey and set arguments
if [[ ${CommandToRun} == "run_turnkey" ]]; then
    runTurnkeyArguments="$@"
    runTurnkeyArguments=`printf '%s\n' "${runTurnkeyArguments//run_turnkey/}"`
fi

# -- Next check if any additional flags are set
if [[ ${setflag} =~ .*-.* ]]; then
    echo ""
    # -- First get function / command input (to harmonize input with gmri)
    if [[ -z ${CommandToRun} ]]; then
        FunctionInput=`get_parameters "${setflag}function" "$@"` # function to execute
        CommandInput=`get_parameters "${setflag}command" "$@"`   # command to execute
        # -- If input name uses 'command' instead of function set that to $CommandToRun
        if [[ -z ${FunctionInput} ]]; then
            CommandToRun="$CommandInput"
        else
            CommandToRun="$FunctionInput"
        fi
    fi
    # -- StudyFolder & SessionsFolder input flags
    StudyFolder=`get_parameters "${setflag}studyfolder" $@`                      # study folder to work on
    if [[ -z ${StudyFolder} ]]; then
        StudyFolder=`get_parameters "${setflag}path" $@`                         # local folder to work on
    fi
    StudyFolderPath="${StudyFolder}"
    STUDY_PATH="${StudyFolder}"    

    SessionsFolder=`get_parameters "${setflag}sessionsfolder" $@`                # sessions folder path to work on
    if [[ -z ${SessionsFolder} ]]; then
       SessionsFolder=`get_parameters "${setflag}sessionfolder"  $@`                # sessions folder path to work on
    fi    
    # -- backwards compatibility -- sessionsfolder used to be supported by --subjectsfolder or --subjectfolder
    if [[ -z ${SessionsFolder} ]]; then
        SubjectFolder=`get_parameters "${setflag}subjectsfolder" $@`
        SessionsFolder="${SubjectFolder}"
        if [[ ! -z ${SubjectFolder} ]]; then
            mageho "WARNING: The --subjectsfolder parameter is now renamed to --sessionsfolder"
        fi
    fi
    if [[ -z ${SessionsFolder} ]]; then
        SubjectFolder=`get_parameters "${setflag}subjectfolder" $@`
        SessionsFolder="${SubjectFolder}"
        if [[ ! -z ${SubjectFolder} ]]; then
            mageho "WARNING: The --subjectfolder parameter is now renamed to --sessionsfolder"
        fi
    fi

    # -- Check StudyFolder and set
    if [[ -z ${StudyFolder} ]] && [[ ! -z ${StudyFolderPath} ]]; then
        StudyFolder="$StudyFolderPath"
        STUDY_PATH="${StudyFolderPath}"
    fi

    if [[ ! -z ${StudyFolder} ]] && [[ -z ${StudyFolderPath} ]]; then
        StudyFolderPath="$StudyFolder"
        STUDY_PATH="${StudyFolder}"
    fi

    # -- If study folder is missing but sessions folder is defined assume standard QuNex folder structure
    if [[ -z ${StudyFolder} ]]; then
        if [[ ! -z ${SessionsFolder} ]] && [[ -d ${SessionsFolder} ]]; then
            StudyFolder="$(dirname "$SessionsFolder")"

            StudyFolderPath="${StudyFolder}"
            STUDY_PATH="${StudyFolder}"
        else
            StudyFolder=`echo ${SessionsFolder%/*}`
            if [[ -d ${StudyFolder} ]]; then
                SessionsFolderName=`basename ${SessionsFolder}`
                echo ""
                mageho "WARNING: ${StudyFolder}/${SessionsFolderName} is not present."
                echo ""
                echo "    ---> Found: ${StudyFolder}"
                SessionsFolderName="sessions"
                SessionsFolder="${StudyFolder}/${SessionsFolderName}"
            fi
            if [ -d ${SessionsFolder} ]; then
                echo "    ---> Resetting to defaults: ${SessionsFolder}"
                echo ""
            else
                echo ""
                echo ""
                reho "ERROR: Study folder or sessions folder is not defined or missing."
                reho "       Check your inputs and re-run QuNex."
                echo ""
                exit 1
            fi
        fi
    fi

    # -- Check if SessionsFolderName and SessionsFolder match
    if [[ ! -z ${SessionsFolder} ]] && [[ ! -z ${SessionsFolderName} ]]; then
        SessionsFolderBase=`basename ${SessionsFolder}`
        if [[ ${SessionsFolderBase} != ${SessionsFolderName} ]]; then 
            mageho "WARNING: Sessions folder base is mismatching the --sessionsfoldername input."
            echo ""
            echo "    ---> Aligning variables to match ${SessionsFolder}"
            SessionsFolderName=`basename ${SessionsFolder}`
            echo "    ---> Session folder name set to: ${SessionsFolderName}"
            echo ""
        fi
    fi

    # -- If sessions folder is missing but study folder is defined assume standard QuNex folder structure
    if [[ -z ${SessionsFolder} ]]; then
       if [[ -z ${SessionsFolderName} ]]; then
           SessionsFolderName="sessions"
           if [[ ! -z ${SubjectFolder} ]]; then
               SessionsFolder="${SubjectFolder}"
           fi
           if [[ -z ${StudyFolder} ]]; then
               echo "" &> /dev/null
           else
               SessionsFolder="$StudyFolder/$SessionsFolderName"
           fi
       fi
    fi

    # -- If session folder name is missing but absolute path sessions folder is defined assume standard QuNex folder structure or check basename
    if [[ -z ${SessionsFolderName} ]]; then
        if [[ -z ${SessionsFolder} ]]; then
            SessionsFolderName="sessions"
            if [[ ! -z ${StudyFolder} ]]; then
                SessionsFolder="${StudyFolder}/${SessionsFolderName}"
            else
                echo "" &> /dev/null
            fi
        else
            SessionsFolderName=`basename ${SessionsFolder}`
        fi
    fi

    # -- Set study path
    if [[ -z ${STUDY_PATH} ]]; then
         STUDY_PATH=${StudyFolder}
    fi

    if [[ -z ${StudyFolderPath} ]]; then
         StudyFolderPath=${StudyFolder}
    fi

    # -- If logfolder flag set then set it and set master log
    if [[ -z ${LogFolder} ]]; then
        LogFolder="${StudyFolder}/processing/logs"
    fi

    # -- Set additional RunTurnkey flags
    TURNKEY_TYPE=`get_parameters "${setflag}turnkeytype" $@`
    TURNKEY_STEPS=`get_parameters "${setflag}turnkeysteps" $@`
    WORKDIR=`get_parameters "${setflag}workingdir" $@`
    PROJECT_NAME=`get_parameters "${setflag}projectname" $@`
    CleanupSession=`get_parameters "${setflag}cleanupsession" $@`
    CleanupProject=`get_parameters "${setflag}cleanupproject" $@`
    RawDataInputPath=`get_parameters "${setflag}rawdatainput" $@`
    OVERWRITE_SESSION=`get_parameters "${setflag}overwritesession" $@`
    OVERWRITE_STEP=`get_parameters "${setflag}overwritestep" $@`
    OVERWRITE_PROJECT=`get_parameters "${setflag}overwriteproject" $@`
    OVERWRITE_PROJECT_FORCE=`get_parameters "${setflag}overwriteprojectforce" $@`
    OVERWRITE_PROJECT_XNAT=`get_parameters "${setflag}overwriteprojectxnat" $@`
    BATCH_PARAMETERS_FILENAME=`get_parameters "${setflag}batchfile" $@`
    LOCAL_BATCH_FILE=`get_parameters "${setflag}local_batchfile" $@`
    SessionBatchFile=`get_parameters "${setflag}batchfile" $@`
    SCAN_MAPPING_FILENAME=`get_parameters "${setflag}mappingfile" $@`
    XNAT_ACCSESSION_ID=`get_parameters "${setflag}xnataccsessionid" $@`
    XNAT_SESSION_LABELS=`get_parameters "${setflag}xnatsessionlabels" "$@" | sed 's/,/ /g;s/|/ /g'`; XNAT_SESSION_LABELS=`echo "${XNAT_SESSION_LABELS}" | sed 's/,/ /g;s/|/ /g'`
    XNAT_PROJECT_ID=`get_parameters "${setflag}xnatprojectid" $@`
    XNAT_SUBJECT_ID=`get_parameters "${setflag}xnatsubjectid" $@`
    XNAT_HOST_NAME=`get_parameters "${setflag}xnathost" $@`
    XNAT_USER_NAME=`get_parameters "${setflag}xnatuser" $@`
    XNAT_PASSWORD=`get_parameters "${setflag}xnatpass" $@`
    XNAT_STUDY_INPUT_PATH=`get_parameters "${setflag}xnatstudyinputpath" $@`

    # -- General sessions and sessionids flags
    CASES=`get_parameters "${setflag}sessions" "$@" | sed 's/,/ /g;s/|/ /g'`; CASES=`echo "$CASES" | sed 's/,/ /g;s/|/ /g'` # list of input cases; removing comma or pipes
    SESSIONIDS=`get_parameters "${setflag}sessionids" "$@" | sed 's/,/ /g;s/|/ /g'`; SESSIONIDS=`echo "$SESSIONIDS" | sed 's/,/ /g;s/|/ /g'` # list of input cases; removing comma or pipes

    if [[ -z ${CASES} ]]; then
        if [[ ! -z ${SESSIONIDS} ]]; then
            CASES="$SESSIONIDS"
            SESSIONS="$SESSIONIDS"
        fi
    fi

    # -- Backwards comapatibility, session* used to be subject* 
    if [[ -z ${CASES} ]]; then
        CASES=`get_parameters "${setflag}subjects" "$@" | sed 's/,/ /g;s/|/ /g'`; CASES=`echo "$CASES" | sed 's/,/ /g;s/|/ /g'` # list of input cases; removing comma or pipes
        SESSIONS="$CASES"
        SESSIONIDS="$CASES"
        if [[ ! -z ${CASES} ]]; then
            mageho "WARNING: The --subjects parameter is now renamed to --sessions"
        fi
    fi

    # -- Backwards compatibility, sessionids* used to be subjid* 
    if [[ -z ${CASES} ]]; then
        if [[ -z ${SESSIONIDS} ]]; then
            SESSIONIDS=`get_parameters "${setflag}subjid" "$@" | sed 's/,/ /g;s/|/ /g'`; SESSIONIDS=`echo "$SESSIONIDS" | sed 's/,/ /g;s/|/ /g'` # list of input cases; removing comma or pipes
            SESSIONS="$SESSIONIDS"
            CASES="$SESSIONS"
            if [[ ! -z ${SESSIONIDS} ]]; then
                mageho "WARNING: The --subjid parameter is now renamed to  --sessionids"
            fi
        fi
    fi

    # -- Backwards compatibility for session labels
    if [[ -z ${CASES} ]]; then
        if [[ -z ${SESSION_LABELS} ]]; then
            SESSION_LABELS=`get_parameters "--session" "$@" | sed 's/,/ /g;s/|/ /g'`; SESSION_LABELS=`echo "$SESSION_LABELS" | sed 's/,/ /g;s/|/ /g'`
            SESSIONS="$SESSION_LABELS"
            CASES="$SESSION_LABELS"
            SESSIONIDS="$SESSION_LABELS"
        fi
    fi

    # -- Backwards compatibility for session labels
    if [[ -z ${CASES} ]]; then
        if [[ -z ${SESSION_LABELS} ]]; then
            SESSION_LABELS=`get_parameters "--sessionlabels" "$@" | sed 's/,/ /g;s/|/ /g'`; SESSION_LABELS=`echo "$SESSION_LABELS" | sed 's/,/ /g;s/|/ /g'`
            SESSIONS="$SESSION_LABELS"
            CASES="$SESSION_LABELS"
            SESSIONIDS="$SESSION_LABELS"
        fi
    fi

    # -- Backwards compatibility for session labels
    if [[ -z ${CASES} ]]; then
        if [[ -z ${SESSION_LABELS} ]]; then
            SESSION_LABELS=`get_parameters "--sessions" "$@" | sed 's/,/ /g;s/|/ /g'`; SESSION_LABELS=`echo "$SESSION_LABELS" | sed 's/,/ /g;s/|/ /g'`
            SESSIONS="$SESSION_LABELS"
            CASES="$SESSION_LABELS"   
            SESSIONIDS="$SESSION_LABELS"
        fi
    fi

    # -- General operational flags
    Overwrite=`get_parameters "${setflag}overwrite" $@`  # Clean prior run and starr fresh [yes/no]
    PRINTCOM=`get_parameters "${setflag}printcom" $@`    # Option for printing the entire command
    Scheduler=`get_parameters "${setflag}scheduler" $@`  # Specify the type of scheduler to use
    Bash=`get_parameters "${setflag}bash" "$@"`          # Specify bash commands to run on the compute node
    LogFolder=`get_parameters "${setflag}logfolder" $@`  # Log location
    LogSave=`get_parameters "${setflag}log" $@`          # Log save

    # -- If log flag set then set it
    if [[ -z ${LogSave} ]] || [[ ${LogSave} == "yes" ]]; then
        LogSave="keep"
    fi

    # -- If log flag set to no then remove it
    if [[ ${LogSave} == "no" ]]; then
        LogSave="remove"
    fi

    # -- If scheduler flag set then set RunMethod variable
    if [[ ! -z ${Scheduler} ]]; then
        RunMethod="2"
    else
        RunMethod="1"
    fi

    # -- Input flags for general_plot_bold_timeseries
    QCPlotElements=`get_parameters "${setflag}qcplotelements" $@`
    QCPlotImages=`get_parameters "${setflag}qcplotimages" $@`
    QCPlotMasks=`get_parameters "${setflag}qcplotmasks" $@`
    # -- Path options for FreeSurfer or QuNex
    FreeSurferHome=`get_parameters "${setflag}hcp_freesurfer_home" $@`
    QuNexVersion=`get_parameters "${setflag}version" $@`
    # -- Input flags for create_list
    ListGenerate=`get_parameters "${setflag}listtocreate" $@`
    Append=`get_parameters "${setflag}append" $@`
    ListName=`get_parameters "${setflag}listname" $@`
    HeaderBatch=`get_parameters "${setflag}headerbatch" $@`
    ListFunction=`get_parameters "${setflag}listfunction" $@`
    ParcellationFile=`get_parameters "${setflag}parcellationfile" $@`
    FileType=`get_parameters "${setflag}filetype" $@`
    BoldSuffix=`get_parameters "${setflag}boldsuffix" $@`
    SessionHCPFile=`get_parameters "${setflag}sessionhcpfile" $@`
    ListPath=`get_parameters "${setflag}listpath" $@`
    # -- Input flags for extract_roi
    ROIFile=`get_parameters "${setflag}roifile" $@`
    ROIFileSessionSpecific=`get_parameters "${setflag}sessionroifile" $@`
    # -- Input flags for  compute_bold_fc
    InputFiles=`get_parameters "${setflag}inputfiles" $@`
    OutPathFC=`get_parameters "${setflag}targetf" $@`
    Calculation=`get_parameters "${setflag}calculation" $@`
    RunType=`get_parameters "${setflag}runtype" $@`
    FileList=`get_parameters "${setflag}flist" $@`
    IgnoreFrames=`get_parameters "${setflag}ignore" $@`
    MaskFrames=`get_parameters "${setflag}mask" "$@"`
    Covariance=`get_parameters "${setflag}covariance" $@`
    TargetROI=`get_parameters "${setflag}target" $@`
    RadiusSmooth=`get_parameters "${setflag}rsmooth" $@`
    RadiusDilate=`get_parameters "${setflag}rdilate" $@`
    GBCCommand=`get_parameters "${setflag}command" $@`
    Verbose=`get_parameters "${setflag}verbose" $@`
    ComputeTime=`get_parameters "${setflag}-time" $@`
    VoxelStep=`get_parameters "${setflag}vstep" $@`
    ROIInfo=`get_parameters "${setflag}roinfo" $@`
    FCCommand=`get_parameters "${setflag}options" $@`
    Method=`get_parameters "${setflag}method" $@`
    MemLimit=`get_parameters "${setflag}mem-limit" $@`
    # -- Input flags for bold_parcellation
    InputFile=`get_parameters "${setflag}inputfile" $@`
    InputPath=`get_parameters "${setflag}inputpath" $@`
    InputDataType=`get_parameters "${setflag}inputdatatype" $@`
    SingleInputFile=`get_parameters "${setflag}singleinputfile" $@`
    OutPath=`get_parameters "${setflag}outpath" $@`
    OutName=`get_parameters "${setflag}outname" $@`
    ExtractData=`get_parameters "${setflag}extractdata" $@`
    ComputePConn=`get_parameters "${setflag}computepconn" $@`
    UseWeights=`get_parameters "${setflag}useweights" $@`
    WeightsFile=`get_parameters "${setflag}weightsfile" $@`
    ParcellationFile=`get_parameters "${setflag}parcellationfile" $@`
    # -- Input flags for dwi_legacy
    EchoSpacing=`get_parameters "${setflag}echospacing" $@`
    PEdir=`get_parameters "${setflag}PEdir" $@`
    TE=`get_parameters "${setflag}TE" $@`
    UnwarpDir=`get_parameters "${setflag}unwarpdir" $@`
    DiffDataSuffix=`get_parameters "${setflag}diffdatasuffix" $@`
    Scanner=`get_parameters "${setflag}scanner" $@`
    UseFieldmap=`get_parameters "${setflag}usefieldmap" $@`
    # -- Input flags for dwi_parcellate
    MatrixVersion=`get_parameters "${setflag}matrixversion" $@`
    ParcellationFile=`get_parameters "${setflag}parcellationfile" $@`
    OutName=`get_parameters "${setflag}outname" $@`
    WayTotal=`get_parameters "${setflag}waytotal" $@`
    Lengths=`get_parameters "${setflag}lengths" $@`
    # -- Input flags for  dwi_seed_tractography_dense
    SeedFile=`get_parameters "${setflag}seedfile" $@`
    # -- Input flags for dwi_eddy_qc
    EddyBase=`get_parameters "${setflag}eddybase" $@`
    EddyPath=`get_parameters "${setflag}eddypath" $@`
    Report=`get_parameters "${setflag}report" $@`
    BvalsFile=`get_parameters "${setflag}bvalsfile" $@`
    BvecsFile=`get_parameters "${setflag}bvecsfile" $@`
    EddyIdx=`get_parameters "${setflag}eddyidx" $@`
    EddyParams=`get_parameters "${setflag}eddyparams" $@`
    List=`get_parameters "${setflag}list" $@`
    Mask=`get_parameters "${setflag}mask" $@`
    GroupBar=`get_parameters "${setflag}groupvar" $@`
    OutputDir=`get_parameters "${setflag}outputdir" $@`
    Update=`get_parameters "${setflag}update" $@`
    # -- Input flags for dwi_dtifit
    bvecs=`get_parameters "${setflag}bvecs" $@`
    bvals=`get_parameters "${setflag}bvals" $@`
    cni=`get_parameters "${setflag}cni" $@`
    sse=`get_flags "${setflag}sse" $@`
    wls=`get_flags "${setflag}wls" $@`
    kurt=`get_flags "${setflag}kurt" $@`
    kurtdir=`get_flags "${setflag}kurtdir" $@`
    littlebit=`get_flags "${setflag}littlebit" $@`
    save_tensor=`get_flags "${setflag}save_tensor" $@`
    zmin=`get_parameters "${setflag}zmin" $@`
    zmax=`get_parameters "${setflag}zmax" $@`
    ymin=`get_parameters "${setflag}ymin" $@`
    ymax=`get_parameters "${setflag}ymax" $@`
    xmin=`get_parameters "${setflag}xmin" $@`
    xmax=`get_parameters "${setflag}xmax" $@`
    gradnonlin=`get_parameters "${setflag}gradnonlin" $@`
    # -- Input flags for dwi_bedpostx_gpu
    Fibers=`get_parameters "${setflag}fibers" $@`
    Weight=`get_parameters "${setflag}weight" $@`
    Burnin=`get_parameters "${setflag}burnin" $@`
    Jumps=`get_parameters "${setflag}jumps" $@`
    Sample=`get_parameters "${setflag}sample" $@`
    Model=`get_parameters "${setflag}model" $@`
    Rician=`get_parameters "${setflag}rician" $@`
    Gradnonlin=`get_parameters "${setflag}gradnonlin" $@`
    # -- Input flags for dwi_probtrackx_dense_gpu
    MatrixOne=`get_parameters "${setflag}omatrix1" $@`
    MatrixThree=`get_parameters "${setflag}omatrix3" $@`
    NsamplesMatrixOne=`get_parameters "${setflag}nsamplesmatrix1" $@`
    NsamplesMatrixThree=`get_parameters "${setflag}nsamplesmatrix3" $@`
    distance_correction=`get_parameters "--distancecorrection" $@`
    store_streamlines_length=`get_parameters "--storestreamlineslength" $@`
    ScriptsFolder=`get_parameters "${setflag}scriptsfolder" $@`
    # -- Input flags for run_qc 
    OutPath=`get_parameters "${setflag}outpath" $@`
    scenetemplatefolder=`get_parameters "${setflag}scenetemplatefolder" $@`
    UserSceneFile=`get_parameters "${setflag}userscenefile" $@`
    UserScenePath=`get_parameters "${setflag}userscenepath" $@`
    Modality=`get_parameters "${setflag}modality" $@`
    runQC_Custom=`get_parameters "${setflag}customqc" $@`
    OmitDefaults=`get_parameters "${setflag}omitdefaults" $@`
    HCPSuffix=`get_parameters "${setflag}hcp_suffix" $@`
    DWIPath=`get_parameters "${setflag}dwipath" $@`
    DWIData=`get_parameters "${setflag}dwidata" $@`
    DtiFitQC=`get_parameters "${setflag}dtifitqc" $@`
    BedpostXQC=`get_parameters "${setflag}bedpostxqc" $@`
    EddyQCStats=`get_parameters "${setflag}eddyqcstats" $@`
    DWILegacy=`get_parameters "${setflag}dwilegacy" $@`
    GeneralSceneDataFile=`get_parameters "${setflag}datafile" $@`
    GeneralSceneDataPath=`get_parameters "${setflag}datapath" $@`
    ICAFIXFunction=`get_parameters "${setflag}icafixfunction" $@`
    HPFilter=`get_parameters "${setflag}hpfilter" $@`
    MovCorr=`get_parameters "${setflag}movcorr" $@`
    # -- Code block for BOLDs
    BOLDS=`get_parameters "${setflag}bolds" "$@" | sed 's/,/ /g;s/|/ /g'`; BOLDS=`echo "${BOLDS}" | sed 's/,/ /g;s/|/ /g'`
    
    if [[ -z ${BOLDS} ]]; then
        BOLDS=`get_parameters "${setflag}boldruns" "$@" | sed 's/,/ /g;s/|/ /g'`; BOLDS=`echo "${BOLDS}" | sed 's/,/ /g;s/|/ /g'`
    fi

    if [[ -z ${BOLDS} ]]; then
        BOLDS=`get_parameters "${setflag}bolddata" "$@" | sed 's/,/ /g;s/|/ /g'`; BOLDS=`echo "${BOLDS}" | sed 's/,/ /g;s/|/ /g'`
    fi

    BOLDRUNS="${BOLDS}"
    BOLDDATA="${BOLDS}"
    BOLDfc=`get_parameters "${setflag}boldfc" $@`
    BOLDfcInput=`get_parameters "${setflag}boldfcinput" $@`
    BOLDfcPath=`get_parameters "${setflag}boldfcpath" $@`

    if [[ -z ${BOLDLIST} ]]; then BOLDLIST=`get_parameters "${setflag}bolddata" "$@"`; fi
    if [[ -z ${BOLDLIST} ]]; then BOLDLIST=`get_parameters "${setflag}bolds" "$@"`; fi
    if [[ -z ${BOLDLIST} ]]; then BOLDLIST=`get_parameters "${setflag}boldruns" "$@"`; fi

    BOLDLIST=`echo "${BOLDLIST}" | sed 's/ /,/g;s/|/ /g'`
    BOLDSuffix=`get_parameters "${setflag}boldsuffix" $@`
    BOLDPrefix=`get_parameters "${setflag}boldprefix" $@`
    SkipFrames=`get_parameters "${setflag}skipframes" $@`
    SNROnly=`get_parameters "${setflag}snronly" $@`
    TimeStamp=`get_parameters "${setflag}timestamp" $@`
    Suffix=`get_parameters "${setflag}suffix" $@`
    SceneZip=`get_parameters "${setflag}scenezip" $@`

    # -- Check if session input is a parameter file instead of list of cases
    if [[ ${CASES} == *.txt ]]; then
        SessionBatchFile="$CASES"
        echo ""
        echo "Using $SessionBatchFile for input."
        echo ""
        CASES=`more ${SessionBatchFile} | grep "id:"| cut -d " " -f 2`
    fi

    # -- Get species flag for NHP pipelines
    Species=`get_parameters "${setflag}species" $@`
fi

# ------------------------------------------------------------------------------
# -- Backwards compatibility settings for subjects vs. sessions folder 
# ------------------------------------------------------------------------------

if [[ -z ${qxutil_command_to_run} ]]; then
    if [[ ${SessionsFolderName} != "subjects" ]]; then
        if [[ -d "${StudyFolder}/subjects" ]] && [[ -d "${StudyFolder}/${SessionsFolderName}" ]]; then
            mageho "WARNING: You are attempting to execute a QuNex command using a conflicting QuNex file hierarchy:"
            echo ""
            echo "     Found: --> ${StudyFolder}/subjects"
            echo "     Found: --> ${StudyFolder}/${SessionsFolderName}"
            echo ""
            if [[ ${SessionsFolderName} != "sessions" ]]; then
                echo ""
                echo "     Note: Current version of QuNex supports the following default specification: "
                echo "            --> ${StudyFolder}/sessions"
                echo ""
            fi
            echo "     To avoid the possibility of a backwards incompatible or duplicate "
            echo "     QuNex runs please review the study directory structure and consider" 
            echo "     resolving the conflict such that a consistent folder specification is used. "
            echo ""
            echo "     QuNex will proceed but please consider renaming your directories per latest specs:"
            echo "          https://bitbucket.org/oriadev/qunex/wiki/Overview/DataHierarchy"
            echo ""
        fi

        if [[ -d "${StudyFolder}/subjects" ]] && [[ ! -d "${StudyFolder}/${SessionsFolderName}" ]]; then
            SessionsFolderBase=`base $SessionsFolder`
            if [[ ${SessionsFolderBase} == "subjects" ]]; then 
                SessionsFolderName="${SessionsFolderBase}"
                mageho "WARNING: You are attempting to execute QuNex command using an outdated QuNex file hierarchy:"
                echo ""
                echo "     Found: --> ${StudyFolder}/${SessionsFolderName}"
                echo ""
                echo "     Note: Current version of QuNex supports the following default specification: "
                echo "            --> ${StudyFolder}/sessions"
                echo ""
                echo "     QuNex will proceed but please consider renaming your directories per latest specs:"
                echo "          https://bitbucket.org/oriadev/qunex/wiki/Overview/DataHierarchy"
                echo ""
            else
                mageho "WARNING: You are attempting to execute QuNex command using a conflicting QuNex file hierarchy:"
                echo ""
                echo "     Found: --> ${StudyFolder}/subjects"
                echo "     Found: --> ${StudyFolder}/${SessionsFolderBase}"
                echo ""
                echo "     Note: Current version of QuNex supports the following default specification: "
                echo "            --> ${StudyFolder}/sessions"
                echo ""
                echo "     To avoid the possibility of a backwards incompatible or duplicate "
                echo "     QuNex runs please review the study directory structure and consider" 
                echo "     resolving the conflict such that a consistent folder specification is used. "
                echo ""
                echo "     QuNex will proceed but please consider renaming your directories per latest specs:"
                echo "          https://bitbucket.org/oriadev/qunex/wiki/Overview/DataHierarchy"
                echo ""
            fi
        fi
    fi

    # -- Check for outdated folder hierarchy
    if [[ ${SessionsFolderName} == "subjects" ]] && [[ -d "${StudyFolder}/${SessionsFolderName}" ]]; then
        mageho "WARNING: You are attempting to execute QuNex command using an outdated QuNex file hierarchy:"
        echo ""
        echo "       Found: --> ${StudyFolder}/${SessionsFolderName}"
        echo ""
        echo "     Note: Current version of QuNex supports the following default specification: "
        echo "       --> ${StudyFolder}/sessions"
        echo ""
        echo "       QuNex will proceed but please consider renaming your directories per latest specs:"
        echo "          https://bitbucket.org/oriadev/qunex/wiki/Overview/DataHierarchy"
        echo ""
    fi
fi

# -- Set sessions variable
if [[ -d "${StudyFolder}/sessions" ]] && [[ ! -d "${StudyFolder}/subjects" ]] && [[ ! -d "${StudyFolder}/${SessionsFolderName}" ]]; then
    QuNexSessionsFolder="${StudyFolder}/sessions"
    SessionsFolderName="sessions"
fi

if [[ ! -d "${StudyFolder}/sessions" ]] && [[ ! -d "${StudyFolder}/subjects" ]] && [[ ! -d "${StudyFolder}/${SessionsFolderName}" ]]; then
    QuNexSessionsFolder="${StudyFolder}/sessions"
    SessionsFolderName="sessions"
fi

# -- return to stored folder
popd &> /dev/null

# =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-==-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-==-=-=-=-=-=-=-
# =-=-=-=-=-=-=-=-=-=-=-= Execute specific commands =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
# =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-==-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-==-=-=-=-=-=-=-

# ------------------------------------------------------------------------------
# -- run_turnkey
# ------------------------------------------------------------------------------

if [[ ${CommandToRun} == "run_turnkey" ]]; then
    # -- Check for cases
    if [[ -z ${CASES} ]]; then
        if [[ ! -z ${XNAT_SESSION_LABELS} ]]; then
            CASES="$XNAT_SESSION_LABELS"
        fi
    fi
    if [[ -z ${CASES} ]]; then reho "ERROR: List of sessions missing"; exit 1; fi
    # -- Check for WORKDIR and StudyFolder for an XNAT run
    if [[ -z ${WORKDIR} ]]; then 
        if [[ ! -z ${XNAT_PROJECT_ID} ]]; then
            WORKDIR="/output"; echo "NOTE: Working directory where study is located is missing. Setting defaults: ${WORKDIR}"; echo ''
        fi
    fi
    if [[ -z ${WORKDIR} ]]; then reho "ERROR: Working folder for $CommandToRun missing."; exit 1; fi
    
    if [[ -z ${StudyFolder} ]]; then 
        if [[ ! -z ${XNAT_PROJECT_ID} ]]; then
            StudyFolder="${WORKDIR}/${XNAT_PROJECT_ID}"
        fi
    fi
    if [[ -z ${StudyFolder} ]]; then reho "ERROR: Study folder missing."; exit 1; fi
   # -- Check if cluster options are set
   Cluster="$RunMethod"
   if [[ ${Cluster} == "2" ]]; then
           if [[ -z ${Scheduler} ]]; then reho "ERROR: Scheduler specification and options missing."; exit 1; fi
   fi
   # -- Clean up argument flags
   runTurnkeyArgumentsInput="${runTurnkeyArguments}"
   runTurnkeyArguments=`echo "${runTurnkeyArguments}" | sed 's|--sessions=.[^-]*||g'`
   runTurnkeyArguments=`echo "${runTurnkeyArguments}" | sed 's|--turnkeysteps=.[^-]*||g'`
   runTurnkeyArguments=`echo "${runTurnkeyArguments}" | sed 's|--sessionids=.[^-]*||g'`
   runTurnkeyArguments=`echo "${runTurnkeyArguments}" | sed 's|--bolds=.[^-]*||g'`
   runTurnkeyArguments=`echo "${runTurnkeyArguments}" | sed 's|--bolddata=.[^-]*||g'`
   runTurnkeyArguments=`echo "${runTurnkeyArguments}" | sed 's|--boldruns=.[^-]*||g'`
   echo ""
   echo "Running $CommandToRun with the following parameters:"
   echo "--------------------------------------------------------------"
   echo ""
   echo " Turnkey steps: ${TURNKEY_STEPS} "
   echo " Turnkey arguments:"
   echo "${runTurnkeyArguments} " | sed -e $'s/ /\\\n/g'
    # -- Loop through all the cases
    for CASE in ${CASES}; do ${CommandToRun}; done
fi

# ------------------------------------------------------------------------------
# -- run_qc
# ------------------------------------------------------------------------------

if [ "$CommandToRun" == "qc_preproc" ] || [ "$CommandToRun" == "run_qc" ]; then
    if [ "$CommandToRun" == "qc_preproc" ]; then
       echo ""
       reho "---> NOTE: qc_preproc is deprecated. New function name --> ${CommandToRun}"
       echo ""
    fi
    CommandToRun="run_qc"
    # -- Check all the user-defined parameters:
    if [[ -z ${CommandToRun} ]]; then reho "ERROR: Explicitly specify name of command in flag or use function name as first argument (e.g. qunex<command_name> followed by flags) to run missing"; exit 1; fi
    if [[ -z ${StudyFolder} ]]; then reho "ERROR: Study folder missing."; exit 1; fi
    if [[ -z ${SessionsFolder} ]]; then reho "ERROR: Sessions folder missing."; exit 1; fi
    if [[ -z ${CASES} ]]; then reho "ERROR: List of sessions missing."; exit 1; fi
    if [[ -z ${Modality} ]]; then reho "ERROR: Modality to perform QC on missing."; exit 1; fi
    if [[ -z ${runQC_Custom} ]]; then runQC_Custom="no"; fi
    if [[ ${runQC_Custom} == "yes" ]]; then scenetemplatefolder="${StudyFolder}/processing/scenes/QC/${Modality}"; fi
    if [[ -z ${OmitDefaults} ]]; then OmitDefaults="no"; fi
    Cluster="$RunMethod"
    if [[ ${Cluster} == "2" ]]; then
        if [[ -z ${Scheduler} ]]; then reho "ERROR: Scheduler specification and options missing."; exit 1; fi
    fi
    # -- Perform some careful scene checks
    if [[ -z ${UserSceneFile} ]]; then
        if [ ! -z "$UserScenePath" ]; then 
            echo "---> Provided --userscenepath but --userscenefile not specified."; echo "";
            echo "     Check your inputs and re-run."; echo "";
            scenetemplatefolder="${TOOLS}/${QUNEXREPO}/qx_library/data/scenes/qc"
            geho "---> Reverting to QuNex defaults: ${scenetemplatefolder}"; echo ""
        fi
        if [ -z "$scenetemplatefolder" ]; then
            scenetemplatefolder="${TOOLS}/${QUNEXREPO}/qx_library/data/scenes/qc"
            echo "---> Template folder path value not explicitly specified."; echo ""
            geho "---> Using QuNex defaults: ${scenetemplatefolder}"; echo ""
        fi
        if ls ${scenetemplatefolder}/*${Modality}*.scene 1> /dev/null 2>&1; then 
            geho "---> Scene files found in:"; geho "`ls ${scenetemplatefolder}/*${Modality}*.scene`"; echo ""
        else 
            echo "---> Specified folder contains no scenes: ${scenetemplatefolder}"; echo ""
            scenetemplatefolder="${TOOLS}/${QUNEXREPO}/qx_library/data/scenes/qc"
            geho "---> Reverting to defaults: ${scenetemplatefolder} "; echo ""
        fi
    else
        if [[ -f ${UserSceneFile} ]]; then
            geho "---> User scene file found: ${UserSceneFile}"; echo ""
            UserScenePath=`echo ${UserSceneFile} | awk -F'/' '{print $1}'`
            UserSceneFile=`echo ${UserSceneFile} | awk -F'/' '{print $2}'`
            scenetemplatefolder=${UserScenePath}
        else
            if [ -z "$UserScenePath" ] && [ -z "$scenetemplatefolder" ]; then 
                reho "---> ERROR: Path for user scene file not specified."
                reho "     Specify --scenetemplatefolder or --userscenepath with correct path and re-run."; echo ""; exit 1
            fi
            if [ ! -z "$UserScenePath" ] && [ -z "$scenetemplatefolder" ]; then 
                scenetemplatefolder=${UserScenePath}
            fi
            if ls ${scenetemplatefolder}/${UserSceneFile} 1> /dev/null 2>&1; then 
                geho "---> User specified scene files found in: ${scenetemplatefolder}/${UserSceneFile} "; echo ""
            else 
                reho "---> ERROR: User specified scene ${scenetemplatefolder}/${UserSceneFile} not found." 
                reho "     Check your inputs and re-run."; echo ""; exit 1
            fi
        fi
    fi
    if [ -z "$OutPath" ]; then OutPath="${SessionsFolder}/QC/${Modality}"; echo "Output folder path value not explicitly specified. Using default: ${OutPath}"; fi
    if [ -z "$SceneZip" ]; then SceneZip="yes"; echo "Generation of scene zip file not explicitly provided. Using default: ${SceneZip}"; fi
    # -- DWI modality-specific settings:
    if [ "$Modality" = "DWI" ]; then
        if [ -z "$DWIPath" ]; then DWIPath="Diffusion"; echo "DWI input path not explicitly specified. Using default: ${DWIPath}"; fi
        if [ -z "$DWIData" ]; then DWIData="data"; echo "DWI data name not explicitly specified. Using default: ${DWIData}"; fi
        if [ -z "$DWILegacy" ]; then DWILegacy="no"; echo "DWI legacy not specified. Using default: ${scenetemplatefolder}"; fi
        if [ -z "$DtiFitQC" ]; then DtiFitQC="no"; echo "DWI dtifit QC not specified. Using default: ${DtiFitQC}"; fi
        if [ -z "$BedpostXQC" ]; then BedpostXQC="no"; echo "DWI BedpostX not specified. Using default: ${BedpostXQC}"; fi
        if [ -z "$EddyQCStats" ]; then EddyQCStats="no"; echo "DWI EDDY QC Stats not specified. Using default: ${EddyQCStats}"; fi
    fi
    # -- BOLD modality-specific settings:
    if [[ ${Modality} = "BOLD" ]]; then
        # - Check if BOLDS parameter is empty:
        if [ -z "$BOLDS" ]; then
            echo ""
            echo "WARNING: BOLD input list not specified. Relying on session_hcp.txt individual information files."
            BOLDS="session_hcp.txt"
            echo ""
        fi
        if [ -z "$BOLDPrefix" ]; then BOLDPrefix=""; echo "Input BOLD Prefix not specified. Assuming no BOLD name prefix."; fi
        if [ -z "$BOLDSuffix" ]; then BOLDSuffix=""; echo "Processed BOLD Suffix not specified. Assuming no BOLD output suffix."; fi
    fi
    # -- General modality settings:
    if [ "$Modality" = "general" ] || [ "$Modality" = "General" ] || [ "$Modality" = "GENERAL" ] ; then
        if [ -z "$GeneralSceneDataFile" ]; then reho "ERROR: Data input not specified"; echo ""; exit 1; fi
        if [ -z "$GeneralSceneDataPath" ]; then reho "ERROR: Data input path not specified"; echo ""; exit 1; fi
    fi
    # -- Report parameters
    echo ""
    echo "Running $CommandToRun with the following parameters:"
    echo "--------------------------------------------------------------"
    echo "   Study Folder: ${StudyFolder}"
    echo "   Sessions Folder: ${SessionsFolder}"
    echo "   Sessions: ${CASES}"
    echo "   QC Modality: ${Modality}"
    echo "   QC Output Path: ${OutPath}"
    echo "   Study Log Folder: ${LogFolder}"
    echo "   Custom QC requested: ${runQC_Custom}"
    echo "   HCP folder suffix: ${HCPSuffix}"
    if [ "$runQC_Custom" == "yes" ]; then
        echo "   Custom QC modalities: ${Modality}"
    fi
    if [ "$Modality" == "BOLD" ] || [ "$Modality" == "bold" ]; then
        if [[ ! -z ${SessionBatchFile} ]]; then
            if [[ ! -f ${SessionBatchFile} ]]; then
                reho "ERROR: Requested BOLD modality with a batch file. Batch file not found."
                exit 1
            else
                echo "   Session batch file requested: ${SessionBatchFile}"
                BOLDSBATCH="${BOLDRUNS}"
            fi
        fi
        if [[ ! -z ${BOLDRUNS} ]]; then
            echo "   BOLD runs requested: ${BOLDRUNS}"
        else
            echo "   BOLD runs requested: all"
        fi
    fi
    echo "   Omit default QC: ${OmitDefaults}"
    echo "   QC Scene Template Folder: ${scenetemplatefolder}"
    echo "   QC User-defined Scene: ${UserSceneFile}"
    echo "   Overwrite prior run: ${Overwrite}"
    echo "   Zip Scene File: ${SceneZip}"
    if [ "   $Modality" = "DWI" ]; then
        echo "   DWI input path: ${DWIPath}"
        echo "   DWI input name: ${DWIData}"
        echo "   DWI legacy processing: ${DWILegacy}"
        echo "   DWI dtifit QC requested: ${DtiFitQC}"
        echo "   DWI bedpostX QC requested: ${BedpostXQC}"
        echo "   DWI EDDY QC Stats requested: ${EddyQCStats}"
    fi
    if [ "$Modality" = "BOLD" ]; then
        echo "   BOLD data input: ${BOLDS}"
        echo "   BOLD Prefix: ${BOLDPrefix}"
        echo "   BOLD Suffix: ${BOLDSuffix}"
        echo "   Skip Initial Frames: ${SkipFrames}"
        echo "   Compute SNR Only: ${SNROnly}"
        if [ "$SNROnly" == "yes" ]; then echo ""; echo "   BOLD SNR only specified. Will skip QC images"; echo ""; fi
        if [[ ! -z ${BOLDfc} ]]; then
            echo "   BOLD FC requested: ${BOLDfc}"
            echo "   BOLD FC input: ${BOLDfcInput}"
            echo "   BOLD FC path: ${BOLDfcPath}"
        fi
    fi
    if [ "$Modality" = "general" ]; then
        echo "  Data input path: ${GeneralSceneDataPath}"
        echo "  Data input: ${GeneralSceneDataFile}"
    fi
    echo ""
    # -- Loop through all the cases
    for CASE in ${CASES}; do ${CommandToRun} ${CASE}; done
fi

# ------------------------------------------------------------------------------
# -- dwi_eddy_qc - eddyqc - uses EDDY QC by Matteo Bastiani, FMRIB
# ------------------------------------------------------------------------------

if [ "$CommandToRun" == "dwi_eddy_qc" ]; then
    # -- Check all the user-defined parameters:
    if [[ -z ${CommandToRun} ]]; then reho "ERROR: Explicitly specify name of command in flag or use function name as first argument (e.g. qunex<command_name> followed by flags) to run missing"; exit 1; fi
    if [[ -z ${StudyFolder} ]]; then reho "ERROR: Study folder missing"; exit 1; fi
    if [[ -z ${SessionsFolder} ]]; then reho "ERROR: Sessions folder missing"; exit 1; fi
    if [ -z "$Report" ]; then reho "ERROR: Report type missing"; exit 1; fi
    # -- Perform checks for individual run
    if [ "$Report" == "individual" ]; then
        if [[ -z ${CASES} ]]; then reho "ERROR: List of sessions missing"; exit 1; fi
        if [ -z "$EddyBase" ]; then reho "Eddy base input name missing"; exit 1; fi
        if [ -z "$BvalsFile" ]; then reho "BVALS file missing"; exit 1; fi
        if [ -z "$EddyIdx" ]; then reho "Eddy index missing"; exit 1; fi
        if [ -z "$EddyParams" ]; then reho "Eddy parameters missing"; exit 1; fi
        if [ -z "$Mask" ]; then reho "ERROR: Mask missing"; exit 1; fi
        if [ -z "$BvecsFile" ]; then BvecsFile=""; fi
    fi
    # -- Perform checks for group run
    if [ "$Report" == "group" ]; then
        if [ -z "$List" ]; then reho "ERROR: List of sessions missing"; exit 1; fi
        if [ -z "$Update" ]; then Update="false"; fi
        if [ -z "$GroupVar" ]; then GroupVar=""; fi
    fi
    # -- Check if cluster options are set
    Cluster="$RunMethod"
    if [[ ${Cluster} == "2" ]]; then
            if [[ -z ${Scheduler} ]]; then reho "ERROR: Scheduler specification and options missing."; exit 1; fi
    fi
    # -- Loop through cases for an individual run call
    if [ ${Report} == "individual" ]; then
        for CASE in ${CASES}; do
            # -- Check in/out paths
            if [ -z ${EddyPath} ]; then
                reho "Eddy path not set. Assuming defaults."
                EddyPath="${SessionsFolder}/${CASE}/hcp/${CASE}/Diffusion/eddy"
            else
                EddyPath="${SessionsFolder}/${CASE}/hcp/${CASE}/$EddyPath"
                echo $EddyPath
            fi
            if [ -z ${OutputDir} ]; then
                reho "Output folder not set. Assuming defaults."
                OutputDir="${EddyPath}/${EddyBase}.qc"
            fi
            # -- Report individual parameters
            echo ""
            echo "Running $CommandToRun with the following parameters:"
            echo "--------------------------------------------------------------"
            echo "   StudyFolder: ${StudyFolder}"
            echo "   Sessions Folder: ${SessionsFolder}"
            echo "   Session: ${CASE}"
            echo "   Study Log Folder: ${LogFolder}"
            echo "   Report Type: ${Report}"
            echo "   Eddy QC Input Path: ${EddyPath}"
            echo "   Eddy QC Output Path: ${OutputDir}"
            echo "   Eddy Inputs Base Name: ${EddyBase}"
            echo "   Mask: ${EddyPath}/${Mask}"
            echo "   BVALS file: ${EddyPath}/${BvalsFile}"
            echo "   Eddy Index file: ${EddyPath}/${EddyIdx}"
            echo "   Eddy parameter file: ${EddyPath}/${EddyParams}"
            # Report optional parameters
            echo "   BvecsFile: ${EddyPath}/${BvecsFile}"
            echo "   Overwrite: ${EddyPath}/${Overwrite}"
            echo ""
            # -- Execute function
            ${CommandToRun} ${CASE}
        done
    fi

    # -- Check if group call specified
    if [ ${Report} == "group" ]; then
        # -- Report group parameters
        echo ""
        echo "Running $CommandToRun with the following parameters:"
        echo "--------------------------------------------------------------"
        echo "   Study Folder: ${StudyFolder}"
        echo "   Sessions Folder: ${SessionsFolder}"
        echo "   Study Log Folder: ${LogFolder}"
        echo "   Report Type: ${Report}"
        echo "   Eddy QC Input Path: ${EddyPath}"
        echo "   Eddy QC Output Path: ${OutputDir}"
        echo "   List: ${List}"
        echo "   Grouping Variable: ${GroupVar}"
        echo "   Update single sessions: ${Update}"
        echo "   Overwrite: ${EddyPath}/${Overwrite}"
        echo ""
    fi
fi

# ------------------------------------------------------------------------------
# -- parcellate_anat
# ------------------------------------------------------------------------------

if [ "$CommandToRun" == "parcellate_anat" ]; then
    # -- Check all the user-defined parameters:
    if [[ -z ${CommandToRun} ]]; then reho "ERROR: Explicitly specify name of command in flag or use function name as first argument (e.g. qunex<command_name> followed by flags) to run missing"; exit 1; fi
    if [[ -z ${StudyFolder} ]]; then reho "ERROR: Study folder missing"; exit 1; fi
    if [[ -z ${SessionsFolder} ]]; then reho "ERROR: Sessions folder missing"; exit 1; fi
    if [[ -z ${CASES} ]]; then reho "ERROR: List of sessions missing"; exit 1; fi
    if [ -z "$InputDataType" ]; then reho "ERROR: Input data type value missing"; exit 1; fi
    if [[ -z ${OutName} ]]; then reho "ERROR: Output file name value missing"; exit 1; fi
    if [ -z "$ParcellationFile" ]; then reho "ERROR: File to use for parcellation missing"; exit 1; fi
    Cluster="$RunMethod"

    if [[ ${Cluster} == "2" ]]; then
            if [[ -z ${Scheduler} ]]; then reho "ERROR: Scheduler specification and options missing."; exit 1; fi
    fi

    # -- Check optional parameters if not specified
    if [ -z "$ExtractData" ]; then ExtractData="no"; fi
    if [ -z "$Overwrite" ]; then Overwrite="no"; fi

    # -- Report parameters
    echo ""
    echo "Running $CommandToRun with the following parameters:"
    echo "--------------------------------------------------------------"
    echo "   Study Folder: ${StudyFolder}"
    echo "   Sessions Folder: ${SessionsFolder}"
    echo "   Sessions: ${CASES}"
    echo "   Study Log Folder: ${LogFolder}"
    echo "   ParcellationFile: ${ParcellationFile}"
    echo "   Parcellated Data Output Name: ${OutName}"
    echo "   Input Data Type: ${InputDataType}"
    echo "   Extract data in CSV format: ${ExtractData}"
    echo "   Overwrite prior run: ${Overwrite}"
    echo ""

    # -- Loop through all the cases
    for CASE in ${CASES}; do ${CommandToRun} ${CASE}; done
fi

# ------------------------------------------------------------------------------
# -- dwi_dtifit
# ------------------------------------------------------------------------------

if [ "$CommandToRun" == "dwi_dtifit" ]; then
    # -- Check all the user-defined parameters:
    if [[ -z ${CommandToRun} ]]; then reho "ERROR: Explicitly specify name of command in flag or use function name as first argument (e.g. qunex<command_name> followed by flags) to run missing"; exit 1; fi
    if [[ -z ${StudyFolder} ]]; then reho "ERROR: Study folder missing"; exit 1; fi
    if [[ -z ${SessionsFolder} ]]; then reho "ERROR: Sessions folder missing"; exit 1; fi
    if [[ -z ${CASES} ]]; then reho "ERROR: List of sessions missing"; exit 1; fi
    Cluster="$RunMethod"
    if [[ ${Cluster} == "2" ]]; then
        if [[ -z ${Scheduler} ]]; then reho "ERROR: Scheduler specification and options missing."; exit 1; fi
    fi

    # -- Loop through all the cases
    for CASE in ${CASES}; do ${CommandToRun} ${CASE}; done
fi

# ------------------------------------------------------------------------------
# -- dwi_bedpostx_gpu
# ------------------------------------------------------------------------------

if [ "$CommandToRun" == "dwi_bedpostx_gpu" ]; then
    # -- Check required parameters
    if [[ -z ${StudyFolder} ]]; then reho "ERROR: Study Folder missing"; exit 1; fi
    if [[ -z ${CASES} ]]; then reho "ERROR: List of sessions missing"; exit 1; fi
    Cluster=${RunMethod}

    # -- Loop through all the cases
    for CASE in ${CASES}; do ${CommandToRun} ${CASE}; done
fi

# ------------------------------------------------------------------------------
# -- dwi_legacy
# ------------------------------------------------------------------------------

if [ "$CommandToRun" == "dwi_legacy" ]; then
    # -- Check all the user-defined parameters:
    if [[ -z ${CommandToRun} ]]; then reho "ERROR: Explicitly specify name of command in flag or use function name as first argument (e.g. qunex<command_name> followed by flags) to run missing"; exit 1; fi
    if [ -z "$Scanner" ]; then reho "ERROR: Scanner manufacturer missing"; exit 1; fi
    if [ -z "$UseFieldmap" ]; then reho "ERROR: UseFieldmap yes/no specification missing"; exit 1; fi
    if [[ -z ${StudyFolder} ]]; then reho "ERROR: Study folder missing"; exit 1; fi
    if [[ -z ${SessionsFolder} ]]; then reho "ERROR: Sessions folder missing"; exit 1; fi
    if [[ -z ${CASES} ]]; then reho "ERROR: List of sessions missing"; exit 1; fi
    if [ -z "$DiffDataSuffix" ]; then reho "ERROR: Diffusion Data Suffix Name missing"; exit 1; fi

    if [ ${UseFieldmap} == "yes" ]; then
        if [ -z "$TE" ]; then reho "ERROR: TE value for Fieldmap missing"; exit 1; fi
    elif [ ${UseFieldmap} == "no" ]; then
        echo "NOTE: Processing without FieldMap (TE option not needed)"
    fi

    Cluster="$RunMethod"
    if [[ ${Cluster} == "2" ]]; then
            if [[ -z ${Scheduler} ]]; then reho "ERROR: Scheduler specification and options missing."; exit 1; fi
    fi

    # -- Report parameters
    echo ""
    echo "Running $CommandToRun with the following parameters:"
    echo "--------------------------------------------------------------"
    echo "   Study Folder: ${StudyFolder}"
    echo "   Sessions Folder: ${SessionsFolder}"
    echo "   Sessions: ${CASES}"
    echo "   Study Log Folder: ${LogFolder}"
    echo "   Scanner: ${Scanner}"
    echo "   Using FieldMap: ${UseFieldmap}"
    echo "   Echo Spacing: ${EchoSpacing}"
    echo "   Phase Encoding Direction: ${PEdir}"
    echo "   TE value for Fieldmap: ${TE}"
    echo "   EPI Unwarp Direction: ${UnwarpDir}"
    echo "   Diffusion Data Suffix Name: ${DiffDataSuffix}"
    echo "   Overwrite prior run: ${Overwrite}"
    echo ""

    # -- Loop through all the cases
    for CASE in ${CASES}; do ${CommandToRun} ${CASE}; done
fi

# ------------------------------------------------------------------------------
# -- parcellate_anat
# ------------------------------------------------------------------------------

if [ "$CommandToRun" == "parcellate_anat" ]; then
    # -- Check all the user-defined parameters:
    if [[ -z ${CommandToRun} ]]; then reho "ERROR: Explicitly specify name of command in flag or use function name as first argument (e.g. qunex<command_name> followed by flags) to run missing"; exit 1; fi
    if [[ -z ${StudyFolder} ]]; then reho "ERROR: Study folder missing"; exit 1; fi
    if [[ -z ${SessionsFolder} ]]; then reho "ERROR: Sessions folder missing"; exit 1; fi
    if [[ -z ${CASES} ]]; then reho "ERROR: List of sessions missing"; exit 1; fi
    if [ -z "$InputDataType" ]; then reho "ERROR: Input data type value missing"; exit 1; fi
    if [[ -z ${OutName} ]]; then reho "ERROR: Output file name value missing"; exit 1; fi
    if [ -z "$ParcellationFile" ]; then reho "ERROR: File to use for parcellation missing"; exit 1; fi
    Cluster="$RunMethod"
    if [[ ${Cluster} == "2" ]]; then
            if [[ -z ${Scheduler} ]]; then reho "ERROR: Scheduler specification and options missing."; exit 1; fi
    fi

    # -- Check optional parameters if not specified
    if [ -z "$ExtractData" ]; then ExtractData="no"; fi
    if [ -z "$Overwrite" ]; then Overwrite="no"; fi

    # -- Report parameters
    echo ""
    echo "Running $CommandToRun with the following parameters:"
    echo "--------------------------------------------------------------"
    echo "   Study Folder: ${StudyFolder}"
    echo "   Sessions Folder: ${SessionsFolder}"
    echo "   Sessions: ${CASES}"
    echo "   Study Log Folder: ${LogFolder}"
    echo "   ParcellationFile: ${ParcellationFile}"
    echo "   Parcellated Data Output Name: ${OutName}"
    echo "   Input Data Type: ${InputDataType}"
    echo "   Extract data in CSV format: ${ExtractData}"
    echo "   Overwrite prior run: ${Overwrite}"
    echo ""
    # -- Loop through all the cases
    for CASE in ${CASES}; do ${CommandToRun} ${CASE}; done
fi

# ------------------------------------------------------------------------------
# -- fc_compute_wrapper
# ------------------------------------------------------------------------------

if [ "$CommandToRun" == "compute_bold_fc" ] || [ "$CommandToRun" == "fc_compute_wrapper" ]; then
    CommandToRun="compute_bold_fc"
    # -- Check all the user-defined parameters:
    if [[ -z ${CommandToRun} ]]; then reho "ERROR: Explicitly specify name of command in flag or use function name as first argument (e.g. qunex<command_name> followed by flags) to run missing"; exit 1; fi
    if [[ -z ${Calculation} ]]; then reho "ERROR: Type of calculation to run (gbc or seed) missing"; exit 1; fi
    if [[ -z ${RunType} ]] && [[ ${Calculation} != "dense" ]]; then reho "ERROR: Type of run (group or individual) missing"; exit 1; fi

    if [[ ${RunType} == "list" ]]; then
        if [ -z "$FileList" ]; then reho "ERROR: Group file list missing"; exit 1; fi
    fi

    if [[ ${RunType} == "individual" ]] || [[ ${RunType} == "group" ]]; then
        if [[ -z ${StudyFolder} ]]; then reho "ERROR: Study folder missing"; exit 1; fi
        if [[ -z ${SessionsFolder} ]]; then reho "ERROR: Sessions folder missing"; exit 1; fi
        if [[ -z ${CASES} ]]; then reho "ERROR: List of sessions missing"; exit 1; fi
        if [ -z "$InputFiles" ]; then reho "ERROR: Input file(s) value missing"; exit 1; fi
        if [[ -z ${OutName} ]]; then reho "ERROR: Output file name value missing"; exit 1; fi
        if [[ ${RunType} == "individual" ]]; then
            if [ -z "$InputPath" ]; then echo ""; echo "WARNING: Input path value missing. Assuming individual folder structure for output"; fi
            if [ -z "$OutPathFC" ]; then echo ""; echo "WARNING: Output path value missing. Assuming individual folder structure for output"; fi
        fi
        if [[ ${RunType} == "group" ]]; then
            if [ -z "$OutPathFC" ]; then reho "ERROR: Output path value missing and is needed for a group run."; exit 1; fi
        fi
    fi

    if [[ ${Calculation} == "gbc" ]]; then
        if [ -z "$TargetROI" ]; then TargetROI="[]"; fi
        if [ -z "$RadiusSmooth" ]; then RadiusSmooth="0"; fi
        if [ -z "$RadiusDilate" ]; then RadiusDilate="0"; fi
        if [ -z "$GBCCommand" ]; then GBCCommand="mFz:"; fi
        if [ -z "$Verbose" ]; then Verbose="true"; fi
        if [ -z "$ComputeTime" ]; then ComputeTime="true"; fi
        if [ -z "$VoxelStep" ]; then VoxelStep="1200"; fi
    fi

    if [[ ${Calculation} == "seed" ]]; then
        if [ -z "$ROIInfo" ]; then reho "ERROR: ROI seed file not specified"; exit 1; fi
        if [ -z "$FCCommand" ]; then FCCommand=""; fi
        if [ -z "$Method" ]; then Method="mean"; fi
    fi

    Cluster="$RunMethod"
    if [[ ${Cluster} == "2" ]]; then
            if [[ -z ${Scheduler} ]]; then reho "ERROR: Scheduler specification and options missing."; exit 1; fi
    fi

    # -- Check optional parameters if not specified
    if [ -z "$IgnoreFrames" ]; then IgnoreFrames=""; fi
    if [ -z "$MaskFrames" ]; then MaskFrames=""; fi
    if [ -z "$Covariance" ]; then Covariance=""; fi
    if [ -z "$ExtractData" ]; then ExtractData="no"; fi
    
    if [[ ${Calculation} == "dense" ]]; then 
        RunType="individual"; 
        if [ -z ${MemLimit} ]; then MemLimit="4"; echo "WARNING: MemLimit value missing. Setting to $MemLimit"; fi
    fi

    # -- Report parameters
    echo ""
    echo "Running $CommandToRun with the following parameters:"
    echo "--------------------------------------------------------------"
    echo "   Study Log Folder: ${LogFolder}"
    echo "   Output Path: ${OutPathFC}"
    echo "   Extract data in CSV format: ${ExtractData}"
    echo "   Type of fc calculation: ${Calculation}"
    echo "   Type of run: ${RunType}"
    echo "   Calculate Covariance: ${Covariance}"

    if [[ ${Calculation} != "dense" ]]; then
        echo "   Ignore frames: ${IgnoreFrames}"
        echo "   Mask out frames: ${MaskFrames}"
    else
        echo "   Memory Limit: ${MemLimit}"
    fi

    if [[ ${RunType} == "list" ]]; then
        echo "   FileList: ${FileList}"
    fi

    if [[ ${RunType} == "individual" ]] || [[ ${RunType} == "group" ]]; then
        echo "   Study Folder: ${StudyFolder}"
        echo "   Sessions Folder: ${SessionsFolder}"
        echo "   Sessions: ${CASES}"
        echo "   Input Files: ${InputFiles}"
        echo "   Input Path for Data: ${SessionsFolder}/<session_id>/${InputPath}"
        echo "   Output Name: ${OutName}"
    fi

    if [[ ${Calculation} == "gbc" ]]; then
        echo "   Target ROI for GBC: ${TargetROI}"
        echo "   Radius Smooth for GBC: ${RadiusSmooth}"
        echo "   Radius Dilate for GBC: ${RadiusDilate}"
        echo "   GBC Commands to run: ${GBCCommand}"
        echo "   Verbose outout: ${Verbose}"
        echo "   Print Compute Time: ${ComputeTime}"
        echo "   Voxel Steps to use: ${VoxelStep}"
    fi

    if [[ ${Calculation} == "seed" ]]; then
        echo "   ROI Information for seed fc: ${ROIInfo}"
        echo "   FC Commands to run: ${FCCommand}"
        echo "   Method to compute fc: ${Method}"
    fi

    echo ""

    if [[ ${RunType} == "individual" ]]; then
        for CASE in ${CASES}; do
            ${CommandToRun} ${CASE}
        done
    fi

    if [[ ${RunType} == "group" ]]; then
        CASE=`echo "$CASES" | sed 's/ /,/g'`
        echo $CASE
        ${CommandToRun} ${CASE}
    fi

    if [[ ${RunType} == "list" ]]; then
        ${CommandToRun}
    fi
fi

# ------------------------------------------------------------------------------
# -- parcellate_bold
# ------------------------------------------------------------------------------

if [ "$CommandToRun" == "bold_parcellation" ] || [ "$CommandToRun" == "parcellate_bold" ]; then
    CommandToRun="bold_parcellation"

    # -- Check all the user-defined parameters:
    if [[ -z ${CommandToRun} ]]; then reho "ERROR: Explicitly specify name of command in flag or use function name as first argument (e.g. qunex<command_name> followed by flags) to run missing"; exit 1; fi
    if [ -z "$InputPath" ]; then reho "ERROR: Input path value missing"; exit 1; fi
    if [ -z "$InputDataType" ]; then reho "ERROR: Input data type value missing"; exit 1; fi
    if [ -z "$OutPath" ]; then reho "ERROR: Output path value missing"; exit 1; fi
    if [[ -z ${OutName} ]]; then reho "ERROR: Output file name value missing"; exit 1; fi
    if [ -z "$ParcellationFile" ]; then reho "ERROR: File to use for parcellation missing"; exit 1; fi
    Cluster="$RunMethod"
    if [[ ${Cluster} == "2" ]]; then
            if [[ -z ${Scheduler} ]]; then reho "ERROR: Scheduler specification and options missing."; exit 1; fi
    fi

    # -- Check optional parameters if not specified
    if [ -z ${UseWeights} ]; then
        UseWeights="no"
        WeightsFile="no"
        echo "NOTE: Weights file not used."
    fi
    if [ -z ${WeightsFile} ]; then
        UseWeights="no"
        WeightsFile="no"
        echo "NOTE: Weights file not used."
    fi
    if [ -z "$ComputePConn" ]; then ComputePConn="no"; fi
    if [ -z "$WeightsFile" ]; then WeightsFile="no"; fi
    if [ -z "$ExtractData" ]; then ExtractData="no"; fi
    if [[ -z ${SingleInputFile} ]]; then SingleInputFile="";
        if [[ -z ${StudyFolder} ]]; then reho "ERROR: Study folder missing"; exit 1; fi
        if [[ -z ${SessionsFolder} ]]; then reho "ERROR: Sessions folder missing"; exit 1; fi
        if [[ -z ${CASES} ]]; then reho "ERROR: List of sessions missing"; exit 1; fi
        if [ -z "$InputFile" ]; then reho "ERROR: Input file value missing"; exit 1; fi
    fi

    # -- Report parameters
    echo ""
    echo "Running $CommandToRun with the following parameters:"
    echo "--------------------------------------------------------------"
    echo "   Study Folder: ${StudyFolder}"
    echo "   Sessions Folder: ${SessionsFolder}"
    echo "   Sessions: ${CASES}"
    echo "   Study Log Folder: ${LogFolder}"
    echo "   Input File: ${InputFile}"
    echo "   Input Path: ${InputPath}"
    echo "   Single Input File: ${SingleInputFile}"
    echo "   ParcellationFile: ${ParcellationFile}"
    echo "   BOLD Parcellated Connectome Output Name: ${OutName}"
    echo "   BOLD Parcellated Connectome Output Path: ${OutPath}"
    echo "   Input Data Type: ${InputDataType}"
    echo "   Compute PConn File: ${ComputePConn}"
    echo "   Weights file specified to omit certain frames: ${UseWeights}"
    echo "   Weights file name: ${WeightsFile}"
    echo "   Extract data in CSV format: ${ExtractData}"
    echo "   Overwrite prior run: ${Overwrite}"
    echo ""

    if [[ -z ${SingleInputFile} ]]; then SingleInputFile="";
        # -- Loop through all the cases
        for CASE in ${CASES}; do ${CommandToRun} ${CASE}; done
    else
        # -- Execute on single case
        ${CommandToRun} ${CASE}
    fi
fi

# ------------------------------------------------------------------------------
# -- dwi_parcellate
# ------------------------------------------------------------------------------

if [ "$CommandToRun" == "dwi_parcellate" ]; then
    # -- Check all the user-defined parameters:
    if [[ -z ${CommandToRun} ]]; then reho "ERROR: Explicitly specify name of command in flag or use function name as first argument (e.g. qunex<command_name> followed by flags) to run missing"; exit 1; fi
    if [[ -z ${StudyFolder} ]]; then reho "ERROR: Study folder missing"; exit 1; fi
    if [[ -z ${SessionsFolder} ]]; then reho "ERROR: Sessions folder missing"; exit 1; fi
    if [[ -z ${CASES} ]]; then reho "ERROR: List of sessions missing"; exit 1; fi
    if [ -z "$MatrixVersion" ]; then reho "ERROR: Matrix version value missing"; exit 1; fi
    if [ -z "$ParcellationFile" ]; then reho "ERROR: File to use for parcellation missing"; exit 1; fi
    if [[ -z ${OutName} ]]; then reho "ERROR: Name of output pconn file missing"; exit 1; fi
    Cluster="$RunMethod"
    if [[ ${Cluster} == "2" ]]; then
            if [[ -z ${Scheduler} ]]; then reho "ERROR: Scheduler specification and options missing."; exit 1; fi
    fi
    if [ -z "$WayTotal" ]; then WayTotal="no"; echo "NOTE: --waytotal normalized data not specified. Assuming default [no]"; fi
    if [ -z "$Lengths" ]; then Lengths="no"; echo "NOTE --lengths not specified. Assuming default [no]"; fi

    # -- Report parameters
    echo ""
    echo "Running $CommandToRun with the following parameters:"
    echo "--------------------------------------------------------------"
    echo "   Study Folder: ${StudyFolder}"
    echo "   Sessions Folder: ${SessionsFolder}"
    echo "   Sessions: ${CASES}"
    echo "   Study Log Folder: ${LogFolder}"
    echo "   Matrix version used for input: ${MatrixVersion}"
    echo "   File to use for parcellation: ${ParcellationFile}"
    echo "   Dense DWI Parcellated Connectome Output Name: ${OutName}"
    echo "   Waytotal normalization: ${WayTotal}"
    echo "   Streamline Lengths: ${Lengths}"
    echo "   Overwrite prior run: ${Overwrite}"
    echo ""

    # -- Loop through all the cases
    for CASE in ${CASES}; do ${CommandToRun} ${CASE}; done
fi

# ------------------------------------------------------------------------------
# -- extract_roi
# ------------------------------------------------------------------------------

if [ "$CommandToRun" == "extract_roi" ]; then
    # -- Check all the user-defined parameters:
    if [[ -z ${CommandToRun} ]]; then reho "ERROR: Explicitly specify name of command in flag or use function name as first argument (e.g. qunex<command_name> followed by flags) to run missing"; exit 1; fi
    if [ -z "$OutPath" ]; then reho "ERROR: Output path value missing"; exit 1; fi
    if [[ -z ${OutName} ]]; then reho "ERROR: Output file name value missing"; exit 1; fi
    if [ -z "$ROIFile" ]; then reho "ERROR: File to use for ROI extraction missing"; exit 1; fi
    Cluster="$RunMethod"
    if [[ ${Cluster} == "2" ]]; then
            if [[ -z ${Scheduler} ]]; then reho "ERROR: Scheduler specification and options missing."; exit 1; fi
    fi
    # -- Check optional parameters if not specified
    if [ -z "$ROIFileSessionSpecific" ]; then ROIFileSessionSpecific="no"; fi
    if [ -z "$Overwrite" ]; then Overwrite="no"; fi
    if [[ -z ${SingleInputFile} ]]; then SingleInputFile="";
        if [ -z "$InputFile" ]; then reho "ERROR: Input file path value missing"; exit 1; fi
        if [[ -z ${StudyFolder} ]]; then reho "ERROR: Study folder missing"; exit 1; fi
        if [[ -z ${SessionsFolder} ]]; then reho "ERROR: Sessions folder missing"; exit 1; fi
        if [[ -z ${CASES} ]]; then reho "ERROR: List of sessions missing"; exit 1; fi
    fi

    # -- Report parameters
    echo ""
    echo "Running $CommandToRun with the following parameters:"
    echo "--------------------------------------------------------------"
    echo "   Study Folder: ${StudyFolder}"
    echo "   Sessions Folder: ${SessionsFolder}"
    echo "   Sessions: ${CASES}"
    echo "   Study Log Folder: ${LogFolder}"
    echo "   Input File: ${InputFile}"
    echo "   Output File Name: ${OutName}"
    echo "   Single Input File: ${SingleInputFile}"
    echo "   ROI File: ${ROIFile}"
    echo "   Session specific ROI file set: ${ROIFileSessionSpecific}"
    echo "   Overwrite prior run: ${Overwrite}"
    echo ""

    if [[ -z ${SingleInputFile} ]]; then SingleInputFile="";
        # -- Loop through all the cases
        for CASE in ${CASES}; do ${CommandToRun} ${CASE}; done
    else
        # -- Execute on single input file
        ${CommandToRun}
    fi
fi

# ------------------------------------------------------------------------------
# -- dwi_seed_tractography_dense
# ------------------------------------------------------------------------------

if [ "$CommandToRun" == "dwi_seed_tractography_dense" ]; then
    # -- Check all the user-defined parameters:
    if [[ -z ${CommandToRun} ]]; then reho "ERROR: Explicitly specify name of command in flag or use function name as first argument (e.g. qunex<command_name> followed by flags) to run missing"; exit 1; fi
    if [[ -z ${StudyFolder} ]]; then reho "ERROR: Study folder missing"; exit 1; fi
    if [[ -z ${SessionsFolder} ]]; then reho "ERROR: Sessions folder missing"; exit 1; fi
    if [[ -z ${CASES} ]]; then reho "ERROR: List of sessions missing"; exit 1; fi
    if [ -z "$MatrixVersion" ]; then reho "ERROR: Matrix version value missing"; exit 1; fi
    if [ -z "$SeedFile" ]; then reho "ERROR: File to use for seed reduction missing"; exit 1; fi
    if [[ -z ${OutName} ]]; then reho "ERROR: Name of output pconn file missing"; exit 1; fi
    Cluster="$RunMethod"
    if [[ ${Cluster} == "2" ]]; then
            if [[ -z ${Scheduler} ]]; then reho "ERROR: Scheduler specification and options missing."; exit 1; fi
    fi
    if [ -z "$WayTotal" ]; then WayTotal="no"; echo "NOTE: --waytotal normalized data not specified. Assuming default [no]"; fi

    # -- Report parameters
    echo ""
    echo "Running $CommandToRun with the following parameters:"
    echo "--------------------------------------------------------------"
    echo "   Study Folder: ${StudyFolder}"
    echo "   Sessions Folder: ${SessionsFolder}"
    echo "   Sessions: ${CASES}"
    echo "   Study Log Folder: ${LogFolder}"
    echo "   Matrix version used for input: ${MatrixVersion}"
    echo "   Dense dconn seed reduction: ${SeedFile}"
    echo "   Dense DWI Parcellated Connectome Output Name: ${OutName}"
    echo "   Waytotal normalization: ${WayTotal}"
    echo "   Overwrite prior run: ${Overwrite}"
    echo ""

    # -- Loop through all the cases
    for CASE in ${CASES}; do ${CommandToRun} ${CASE}; done
fi

# ------------------------------------------------------------------------------
# -- auto_ptx
# ------------------------------------------------------------------------------

if [ "$CommandToRun" == "auto_ptx" ]; then
    # -- Check all the user-defined parameters:
    if [[ -z ${CommandToRun} ]]; then reho "ERROR: Explicitly specify name of command in flag or use function name as first argument (e.g. qunex<command_name> followed by flags) to run missing"; exit 1; fi
    if [[ -z ${StudyFolder} ]]; then reho "ERROR: Study folder missing"; exit 1; fi
    if [[ -z ${SessionsFolder} ]]; then reho "ERROR: Sessions folder missing"; exit 1; fi
    if [[ -z ${CASES} ]]; then reho "ERROR: List of sessions missing"; exit 1; fi
    Cluster="$RunMethod"
    if [[ ${Cluster} == "2" ]]; then
        if [[ -z ${Scheduler} ]]; then reho "ERROR: Scheduler specification and options missing."; exit 1; fi
    fi
    if [[ -z ${BedPostXFolder} ]]; then BedPostXFolder=${SessionsFolder}/${CASE}/hcp/${CASE}/T1w/Diffusion.bedpostX; fi

    # -- Report parameters
    echo ""
    echo "Running $CommandToRun with the following parameters:"
    echo "--------------------------------------------------------------"
    echo "   Study Folder: ${StudyFolder}"
    echo "   Sessions Folder: ${SessionsFolder}"
    echo "   Sessions: ${CASES}"
    echo "   Study Log Folder: ${LogFolder}"
    echo "   BedpostX Folder: ${BedPostXFolder} "
    echo ""
    for CASE in ${CASES}; do ${CommandToRun} ${CASE}; done
fi

# ------------------------------------------------------------------------------
# -- dwi_pre_tractography
# ------------------------------------------------------------------------------

if [ "$CommandToRun" == "dwi_pre_tractography" ]; then
    # -- Check all the user-defined parameters:
    if [[ -z ${CommandToRun} ]]; then reho "ERROR: Explicitly specify name of command in flag or use function name as first argument (e.g. qunex<command_name> followed by flags) to run missing"; exit 1; fi
    if [[ -z ${StudyFolder} ]]; then reho "ERROR: Study folder missing"; exit 1; fi
    if [[ -z ${SessionsFolder} ]]; then reho "ERROR: Sessions folder missing"; exit 1; fi
    if [[ -z ${CASES} ]]; then reho "ERROR: List of sessions missing"; exit 1; fi
    Cluster="$RunMethod"
    if [[ ${Cluster} == "2" ]]; then
        if [[ -z ${Scheduler} ]]; then reho "ERROR: Scheduler specification and options missing."; exit 1; fi
    fi

    # -- Report parameters
    echo ""
    echo "Running $CommandToRun with the following parameters:"
    echo "--------------------------------------------------------------"
    echo "   Study Folder: ${StudyFolder}"
    echo "   Sessions Folder: ${SessionsFolder}"
    echo "   Sessions: ${CASES}"
    echo "   Study Log Folder: ${LogFolder}"
    echo ""
    for CASE in ${CASES}; do ${CommandToRun} ${CASE}; done
fi

# ------------------------------------------------------------------------------
# -- dwi_probtrackx_dense_gpu
# ------------------------------------------------------------------------------

if [ "$CommandToRun" == "dwi_probtrackx_dense_gpu" ]; then
    # Check all the user-defined parameters: 1.QUEUE, 2. Scheduler, 3. Matrix1, 4. Matrix3
    if [[ -z ${CommandToRun} ]]; then reho "ERROR: Explicitly specify name of command in flag or use function name as first argument (e.g. qunex<command_name> followed by flags) to run missing"; exit 1; fi
    if [[ -z ${StudyFolder} ]]; then reho "ERROR: Study folder missing"; exit 1; fi
    if [[ -z ${SessionsFolder} ]]; then reho "ERROR: Sessions folder missing"; exit 1; fi
    if [[ -z ${CASES} ]]; then reho "ERROR: List of sessions missing"; exit 1; fi
    if [ -z "$MatrixOne" ] && [ -z "$MatrixThree" ]; then reho "ERROR: Matrix option missing. You need to specify at least one. [e.g. --omatrix1='yes' and/or --omatrix2='yes']"; exit 1; fi
    if [ -z "$MatrixOne" ]; then MatrixOne="no"; fi
    if [ -z "$MatrixThree" ]; then MatrixThree="no"; fi
    if [ -z "$NsamplesMatrixOne" ]; then NsamplesMatrixOne=10000; fi
    if [ -z "$NsamplesMatrixThree" ]; then NsamplesMatrixThree=3000; fi
    Cluster="$RunMethod"
    if [[ ${Cluster} == "2" ]]; then
        if [[ -z ${Scheduler} ]]; then reho "ERROR: Scheduler specification and options missing."; exit 1; fi
    fi

    # -- Optional parameters
    if [ -z ${ScriptsFolder} ]; then ScriptsFolder="${HCPPIPEDIR_dMRITractFull}/tractography_gpu_scripts"; fi
    minimumfilesize="100000000"
    # -- In and out folders for reporting
    if [[ -z ${OutFolder} ]]; then
        OutFolderReport="${SessionsFolder}/<session>/hcp/<session>/MNINonLinear/Results/Tractography";
    else
        OutFolderReport=${OutFolder}
    fi

    # -- distance correction flag
    if [ "$distance_correction" == "yes" ] || [ "$distance_correction" == "YES" ]; then
        distance_correction="yes"
    else
        distance_correction="no"
    fi

    # -- store streamlines length flag
    if [ "$store_streamlines_length" == "yes" ] || [ "$store_streamlines_length" == "YES" ]; then
        store_streamlines_length="yes"
    else
        store_streamlines_length="no"
    fi

    # -- Report parameters
    echo ""
    echo "Running $CommandToRun with the following parameters:"
    echo "--------------------------------------------------------------"
    echo "   Study Folder: ${StudyFolder}"
    echo "   Sessions Folder: ${SessionsFolder}"
    echo "   Sessions: ${CASES}"
    echo "   Study Log Folder: ${LogFolder}"
    echo "   Scheduler: ${Scheduler}"
    echo "   probtraxkX GPU scripts Folder: ${ScriptsFolder}"
    echo "   Compute Matrix1: ${MatrixOne}"
    echo "   Compute Matrix3: ${MatrixThree}"
    echo "   Number of samples for Matrix1: ${NsamplesMatrixOne}"
    echo "   Number of samples for Matrix3: ${NsamplesMatrixThree}"
    echo "   Distance correction: ${distance_correction}"
    echo "   Store streamlines length: ${store_streamlines_length}"
    echo "   Overwrite prior run: ${Overwrite}"
    echo ""

    # -- Execute
    for CASE in ${CASES}; do ${CommandToRun} ${CASE}; done
fi
