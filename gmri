#!/usr/bin/env python
# encoding: utf-8

import niutilities as niu
import niutilities.g_process as gp
import niutilities.g_matlab as gm
import niutilities.g_core as gc
import glob
import os.path
import sys
import datetime

# --- Get current MNAP Suite version and prepend to help calls

tools = os.environ['TOOLS']
mnaprepo = os.environ['MNAPREPO']
version = 'VERSION.md'
mnapver = os.path.join(tools,mnaprepo,version)
with open(mnapver,'r') as f: # 'with' will automatically close file for you,
    for line in f: # Do something with the file
        print "\nMultimodal Neuroimaging Analysis Platform (MNAP) Suite Version",line

help = '''
================================================================================

General magnetic resonance Imaging (gmri) utilities for processing and analysis.

usage: gmri <command> [option=value] [option=value] ...
       gmri -h         (prints this help)
       gmri -l         (list available commands)
       gmri -c         (list available processing commands)
       gmri -o         (list available processing options)
       gmri ?<command> (print help for a given command)

       -------------------------------------------------------------------------
       Note the following conventions used in help and documentation:

       * Square brackets [] denote an option or argument that is optional. The
         value listed in the brackets is the default value used, if the argument
         is not explicitly specified
       * Angle brackets <> describe the value that should be provided
       * Dashes or "flags" (-) in the documentation define input variables.
       * Commands, arguments, and option names are either in small or "camel"
         case.
       * Use descriptions are in regular "sentence" case.
       * Option values are usually specified in capital case (e.g. YES/NO).
       -------------------------------------------------------------------------
'''

comlist = '''
================================================================================

General magnetic resonance Imaging (gmri) utilities for processing and analysis.

use: gmri <command> [option=value] [option=value] ...

--------------------------------------------------------------------------------
Note the following conventions used in help and documentation:

* Square brackets [] denote an option or argument that is optional. The
  value listed in the brackets is the default value used, if the argument
  is not explicitly specified
* Angle brackets <> describe the value that should be provided
* Dashes or "flags" (-) in the documentation define input variables.
* Commands, arguments, and option names are either in small or "camel" case.
* Use descriptions are in regular "sentence" case.
* Option values are usually specified in capital case (e.g. YES/NO).
--------------------------------------------------------------------------------

dicom utilities
---------------
listDicom    [folder=.]
splitDicom   [folder=.]
sortDicom    [folder=.]
dicom2nii    [folder=.] [clean=ask] [unzip=ask] [gzip=ask] [verbose=True] [cores=1]
dicom2niix   [folder=.] [clean=ask] [unzip=ask] [gzip=ask] [subjectid=None] [verbose=True] [cores=1]
processInbox [subjectsfolder=.] [inbox=<subjectsfolder>/inbox/MR] [check=yes] [pattern=".*?(OP[0-9.-]+).*\.zip"] [cores=1] [logfile=""] [archive=move] [verbose=yes]
getDICOMInfo dicomfile=<dicom_file> [scanner=siemens]


WUSTL NIL pipeline utilities
----------------------------
runNIL       [folder=.] [overwrite=no] [sfile=subject.txt]
runNILFolder [folder=.] [pattern=OP*] [overwrite=no] [sfile=subject.txt]


General image file utilities
----------------------------
sliceImage    sfile=<source image> tfile=<target image> [frames=1]


NIfTI file conversions
----------------------
fz2zf         inf=<input_image> [outf=<output_image>]
reorder       inf=<input_image> [outf=<output_image>]
reslice       inf=<input_image> slices=<slices_per_volume> [outf=<output_image>]
printniftihdr <image_filename>
modniftihdr   <image_filename> <modification string>
nifti24dfp    inf=<input_filename> [outf=<output_filename>]


HCP setup commands
------------------
getHCPReady    subjects=<subjects specification> [subjectsfolder=.] [sfile=subject.txt] [tfile=subject_hcp.txt] [mapping=specs/hcp_mapping.txt] [sfilter=None] [overwrite=no]
setupHCP       [sfolder=.] [tfolder=hcp] [sfile=subject_hcp.txt]
setupHCPFolder [subjectsfolder=.] [tfolder=hcp] [sfile=subject_hcp.txt] [check=interactive]


Miscellaneous file utilities
----------------------------
createStudy  studyfolder=<path to study base folder>
compileBatch [subjectsfolder=.] [sfile=subject_hcp.txt] [tfile=processing/batch.txt] [subjects=None] [sfilter=None] [overwrite=ask] [paramfile=<subjectsfolder>/specs/batch_parameters.txt]
createList   [subjectsfolder=.] [subjects=None] [sfilter=None] [listfile=None] [bolds=None] [conc=None] [fidl=None] [glm=None] [roi=None] [boldname="bold"] [boldtail=".nii.gz"] [overwrite="no"] [check="yes"]
createConc   [subjectsfolder=.] [subjects=None] [sfilter=None] [concfolder=None] [concname=""] [bolds=None] [boldname="bold"] [boldtail=".nii.gz"] [overwrite="no"] [check="yes"]

Fidl file utilities
-------------------
joinFidl       concfile=<reference_conc_file> fidlroot=<fidl_files_root_pattern>
joinFidlFolder concfolder=<folder_with_conc_files> [fidlfolder=<folder_with_fidl_files>] [outfolder=<folder in which to save joint files>]
splitFidl      concfile=<reference_conc_file> fidlfile=<fidl_file_to_split> [outfolder=<folder_to_save_results>]
checkFidl      [fidlfile=] [fidlfolder=.] [plotfile=] [allcodes=false]


Caret & Workbench surface mapping utilities
-------------------------------------------
map2PALS volume=<volume file> metric=<metric file> [atlas=711-2C] [method=interpolated] [mapping=afm]
map2HCP volume=<volume file> [method=trilinear]
maskMap image=<image file> masks=<list of masks to use> [output=<output image name>] [minv=<list of thresholds>] [maxv=<list of thresholds>] [join=<OR or AND>]
joinMaps images=<image file list> output=<output file name> [names=<volume names list>] [originals=<remove or keep>]


PALM utilities
--------------
createWSPALMDesign factors=<factor string> nsubjects=<number of subjects> root=<design root name>
runPALM image=<image file> [design=<design string>] [args=<arguments string>] [root=<root name for the output>] [cores=<number of cores to use in parallel>] [overwrite=no]


Scheduling utilities
--------------------
schedule [command=<command string>] [script=<path to script>] \
         settings=<settings string> \
         [replace=<"key:value|key:value" string>] \
         [workdir=<path to working directory>] \
         [environment=<path to environment setup script>] \
         [output=<string specifying how to process output>]


Processing commands
===================
In contrast to utilities listed above, processing commands can be submitted to
run on a computer cluster using either a PBS or LSF scheduling. The commands
operate on a list of subjects specified in a `batch.txt` file that provides
information about each subject and his or her images and other information.
Options for the processing command can be specified either in the `batch.txt`
file or on the command line, the latter having priority if a parameter is
specified at both levels. No options need to be set for any of the commands
listed below. The key parameters with their default values are:

    subjects=batch.txt   ... the path to the batch.txt file
    subjectsfolder=.     ... the path to the study subjects folder
    overwrite=no         ... whether to overwrite existing results
    cores=1              ... how many cores to utilize for those
                             commands that can be parallelized
    nprocess=0           ... how many subjects to process (0=all)
    log=remove           ... whether to remove logs of commands that have
                             ran and finished successfully
    run=run              ... whether to run (run) the listed command or
                             test (test) if all the data is ready for the
                             specific command to run successfully

HCP preprocessing commands
--------------------------
hcp_PreFS        [preprocessing options] [preprocessing options] ...
hcp_FS           [preprocessing options] [preprocessing options] ...
hcp_PostFS       [preprocessing options] [preprocessing options] ...
hcp_fMRIVolume   [preprocessing options] [preprocessing options] ...
hcp_fMRISurface  [preprocessing options] [preprocessing options] ...
hcp_Diffusion    [preprocessing options] [preprocessing options] ...
hcp_DTIFit       [preprocessing options] [preprocessing options] ...
hcp_Bedpostx     [preprocessing options] [preprocessing options] ...


Functional connectivity preprocessing commands
----------------------------------------------
mapHCPData              [preprocessing options] [preprocessing options] ...
createBOLDBrainMasks    [preprocessing options] [preprocessing options] ...
computeBOLDStats        [preprocessing options] [preprocessing options] ...
createStatsReport       [preprocessing options] [preprocessing options] ...
extractNuisanceSignal   [preprocessing options] [preprocessing options] ...
preprocessBold          [preprocessing options] [preprocessing options] ...
preprocessConc          [preprocessing options] [preprocessing options] ...


Matlab functions
================
A number of Matlab functions provided as part of MNAP/matlab package can be run.
A list of functions available is provided below. For more information on each
function run `gmri ?<function name>`. Arguments can be specified in any order.
Arguments that are not provided will be passed as empty strings / vectors to be
processed with default values. Take care to embed vectors in square brackets
(e.g. "[1 8 6 12]") and cell arrays in curly braces (e.g. "{'DLPFC', 'ACC',
'FEF'}"). In addition, 'saveOutput' argument can be specified to redirect Matlab
output to a file (e.g. "both:command.log" or "stdout:ok.log|stderr:error.log").

An example call of a Matlab function:

gmri g_FindPeaks fin='map_zstat.dscalar.nii' fout='map_peaks.dscalar.nii' \\
     mins="[50 50]" maxs="[300 350]" val=n t=3.5 projection=midthickness

List of available functions:
'''

for mcom in gm.functionList:
    comlist += "\n" + mcom

commands = {'listDicom'            : {'com': niu.g_dicom.listDicom,              'args': ('folder', )},
            'splitDicom'           : {'com': niu.g_dicom.splitDicom,             'args': ('folder', )},
            'sortDicom'            : {'com': niu.g_dicom.sortDicom,              'args': ('folder', 'out_dir', 'files', 'copy')},
            'dicom2nii'            : {'com': niu.g_dicom.dicom2nii,              'args': ('folder', 'clean', 'unzip', 'gzip', 'verbose', 'cores', 'debug')},
            'dicom2niix'           : {'com': niu.g_dicom.dicom2niix,             'args': ('folder', 'clean', 'unzip', 'gzip', 'subjectid', 'verbose', 'cores', 'debug')},
            'processPhilips'       : {'com': niu.g_dicom.processPhilips,         'args': ('folder', 'check', 'pattern')},
            'processInbox'         : {'com': niu.g_dicom.processInbox,           'args': ('subjectsfolder', 'inbox', 'check', 'pattern', 'cores', 'logfile', 'archive', 'verbose')},
            'getDICOMInfo'         : {'com': niu.g_dicom.getDICOMInfo,           'args': ('dicomfile', 'scanner')},
            'runNILFolder'         : {'com': niu.g_4dfp.runNILFolder,            'args': ('folder', 'pattern', 'overwite', 'sfile')},
            'runNIL'               : {'com': niu.g_4dfp.runNIL,                  'args': ('folder', 'overwite', 'sfile')},
            'fz2zf'                : {'com': niu.g_NIfTI.fz2zf,                  'args': ('inf', 'outf')},
            'reorder'              : {'com': niu.g_NIfTI.reorder,                'args': ('inf', 'outf')},
            'reslice'              : {'com': niu.g_NIfTI.reslice,                'args': ('inf', 'slices', 'outf')},
            'sliceImage'           : {'com': niu.g_img.sliceImage,               'args': ('sfile', 'tfile', 'frames')},
            'nifti24dfp'           : {'com': niu.g_NIfTI.nifti24dfp,             'args': ('inf', 'outf')},
            'setupHCP'             : {'com': niu.g_HCP.setupHCP,                 'args': ('sfolder', 'tfolder', 'sfile', 'check', 'existing')},
            'setupHCPFolder'       : {'com': niu.g_HCP.setupHCPFolder,           'args': ('subjectsfolder', 'tfolder', 'sfile', 'check')},
            'getHCPReady'          : {'com': niu.g_HCP.getHCPReady,              'args': ('subjects', 'subjectsfolder', 'sfile', 'tfile', 'mapping', 'sfilter', 'overwrite')},
            'printniftihdr'        : {'com': niu.g_img.printniftihdr,            'args': ('filename', )},
            'modniftihdr'          : {'com': niu.g_gimg.modniftihdr,             'args': ('filename', 's')},
            'compileBatch'         : {'com': niu.g_utilities.compileBatch,       'args': ('subjectsfolder', 'sfile', 'tfile', 'subjects', 'sfilter', 'overwrite', 'paramfile')},
            'createStudy'          : {'com': niu.g_utilities.createStudy,        'args': ('studyfolder', )},
            'createList'           : {'com': niu.g_utilities.createList,         'args': ('subjectsfolder', 'subjects', 'sfilter', 'listfile', 'bolds', 'conc', 'fidl', 'glm', 'roi', 'boldname', 'boldtail', 'overwrite', 'check')},
            'createConc'           : {'com': niu.g_utilities.createConc,         'args': ('subjectsfolder', 'subjects', 'sfilter', 'concfolder', 'concname', 'bolds', 'boldname', 'boldtail', 'overwrite', 'check')},
            'joinFidl'             : {'com': niu.g_fidl.joinFidl,                'args': ('concfile', 'fidlroot', 'outfolder')},
            'joinFidlFolder'       : {'com': niu.g_fidl.joinFidlFolder,          'args': ('concfolder', 'fidlfolder', 'outfolder')},
            'splitFidl'            : {'com': niu.g_fidl.splitFidl,               'args': ('concfile', 'fidlfile', 'outfolder')},
            'checkFidl'            : {'com': niu.g_fidl.checkFidl,               'args': ('fidlfile', 'fidlfolder', 'plotfile', 'allcodes')},
            'map2PALS'             : {'com': niu.g_4dfp.map2PALS,                'args': ('volume', 'metric', 'atlas', 'method', 'mapping')},
            'map2HCP'              : {'com': niu.g_4dfp.map2HCP,                 'args': ('volume', 'method')},
            'maskMap'              : {'com': niu.g_palm.maskMap,                 'args': ('image', 'masks', 'output', 'minv', 'maxv', 'join')},
            'joinMaps'             : {'com': niu.g_palm.joinMaps,                'args': ('images', 'output', 'names', 'originals')},
            'runPALM'              : {'com': niu.g_palm.runPALM,                 'args': ('image', 'design', 'args', 'root', 'cores', 'overwrite')},
            'createWSPALMDesign'   : {'com': niu.g_palm.createWSPALMDesign,      'args': ('factors', 'nsubjects', 'root')},
            'schedule'             : {'com': niu.g_scheduler.schedule,           'args': ('command', 'script', 'settings', 'replace', 'workdir', 'environment', 'output')}
            }


def runCommand(command, args):

    folders = gc.deduceFolders(args)

    # --- sort commands by type

    if command in commands:
        pass
    elif command in gp.pactions or command in gp.sactions:
        gp.run(command, args)
        return
    elif command in gm.functions:
        if 'scheduler' in args:
            niu.g_scheduler.runThroughScheduler(command, subjects=None, args=args, cores=1, logfolder=folders['logfolder'])
        else:
            gm.run(command, args)
        return
    else:
        print "ERROR: Command %s not recognized. Please run gmri -l to see list of valid commands." % (command)
        sys.exit(1)

    # --- process commands

    # -- sort arguments

    bargs = {}
    eargs = {}
    for k, v in args.items():
        if k in commands[command]['args']:
            bargs[k] = v
        else:
            eargs[k] = v

    # -- check extra arguments

    if eargs:
        argsok = True
        for k, v in eargs.items():
            if k not in ['subjects', 'filter', 'subjid', 'scheduler', 'cores', 'scheduler_environment', 'scheduler_workdir', 'scheduler_sleep', 'nprocess', 'logfolder', 'basefolder']:
                print "ERROR: Extra argument %s is not valid! Please check your command!" % (k)
                argsok = False
        if not argsok:
            sys.exit(1)

    # -- process extra arguments

    subjects = None
    if 'subjects' in eargs:
        if not any([e in commands[command]['args'] for e in ['sfolder', 'folder']]):
            print "ERROR: Command %s can not be run on multiple subjects!" % (command)
            sys.exit(1)
        if folders['subjectsfolder'] is None:
            folders['subjectsfolder'] = "."
        subjects, gopts = gc.getSubjectList(eargs['subjects'], sfilter=eargs.get('filter'), subjid=eargs.get('subjid'), subjectsfolder=folders['subjectsfolder'], verbose=False)

    logname = eargs.get('logname')

    cores = int(eargs.get('cores', '1'))

    # -- are we using a scheduler

    if 'scheduler' in eargs:
        niu.g_scheduler.runThroughScheduler(command, subjects=subjects, args=args, cores=cores, logfolder=folders['logfolder'], logname=logname)

    # -- a basic call

    elif subjects is None:
        commands[command]['com'](**args)

    # -- subjects loop

    else:
        print "\n===> Running %s through a list of subjects using %d cores" % (command, cores)

        calls = []
        for subject in subjects:
            targs   = dict(bargs)
            name    = command + ": " + subject['id']
            sfolder = os.path.join(folders['subjectsfolder'], subject['id'])
            if folders['logfolder']:
                logfile = os.path.join(folders['logfolder'], 'comlogs', "%s_%s.log" % (command, subject['id']))
            for targ in ['sfolder', 'folder']:
                if targ in commands[command]['args']:
                    targs[targ] = sfolder
            calls.append({'name': name, 'function': commands[command]['com'], 'args': targs, 'logfile': logfile})

        results = gc.runInParallel(calls, cores=cores, prepend="     ... ")

        print "\n===> Summary Report"
        results.sort(key=lambda x: x[0])
        for name, result, targetLog, prepend in results:
            if not result:
                result = 'failed'
            print "%s %s %s [log: %s]" % (prepend, name, result, targetLog)



def printHelp(com):

    # --- print list of gmri local commands
    if com == 'l':
        print comlist

    # --- print list of gmri local commands
    elif com == 'available':
        # -> gmri commands
        for c, v in commands.iteritems():
            print c
        # -> complex processing commands
        for l in gp.calist:
            if len(l):
                print l[0]
                print l[1]
        # -> simple processing commands
        for l in gp.salist:
            if len(l):
                print l[0]
                print l[1]
        # -> matlab wrapped commands
        for l in gm.functions.keys():
            print l

    # --- print list of processing options and flags
    elif com in ['o']:
        print "================================================================================"
        print ""
        print "General magnetic resonance Imaging (gmri) utilities for processing and analysis."
        print "\nuse: gmri <command> [option=value] [option=value] ..."
        print "\nList of processing options"
        for line in gp.arglist:
            if len(line) == 4:
                print "  --%-24s %s [%s]" % (line[0], line[3], line[1])
            elif len(line) > 0:
                print "\n\n" + line[0] + '\n'
            else:
                print
        print "\nList of processing flags"
        for line in gp.flaglist:
            if len(line) == 4:
                print "  --%-24s %s" % (line[0], line[3])
            elif len(line) > 0:
                print "\n\n" + line[0] + '\n'
            else:
                print
        print

    # --- print list of processing options and flags
    elif com in ['c']:
        print "================================================================================"
        print ""
        print "General magnetic resonance Imaging (gmri) utilities for processing and analysis."
        print "\nuse: gmri <command> [option=value] [option=value] ..."
        print "\nList of processing commands \n"
        for line in gp.calist + [[]] + gp.salist:
            if len(line) == 4:
                print "   %-6s %-24s %s" % (line[0], line[1], line[3])
            elif len(line) > 0:
                print "\n\n" + line[0] + '\n'
            else:
                print
        print

    # --- print help for gmri local commands
    elif com in commands:
        print "\ngmri", commands[com]['com'].__doc__.strip(), "\n"

    # --- print help for processing paralelised actions
    elif com in gp.pactions:
        print "\ngmri", gp.pactions[com].__doc__.strip(), "\n"

    # --- print help for processing serial actions
    elif com in gp.sactions:
        print "\ngmri", gp.sactions[com].__doc__.strip(), "\n"

    # --- print help for matlab functions
    elif com in gm.functions:
        gm.help(com)

    # --- print general command list
    else:
        print comlist


def main(args=None):
    if args is None:
        args = sys.argv[1:]

    if len(args) == 0:
        print help
        sys.exit(0)

    comm = args[0]
    opts = dict()

     # --- check if help arguments are specified and strip all flags (? or -)
    if comm[0] in ['?', '-']:
        comm = comm.strip('-')
        comm = comm.strip('?')
        try:
            printHelp(comm[0:])
        except:
            print "ERROR: '%s' is not a recognized command!\n-----------------------" % (comm[1:])
            print help
            raise
        sys.exit(0)

    try:
        for n in range(1, len(args)):
            if "=" in args[n]:
                k, v = args[n].split("=", 1)
                k = k.strip('-')
                opts[k] = v
            elif comm in commands:
                k = commands[comm]['args'][n - 1]
                opts[k] = args[n]
            else:
                k = args[n].strip('-')
                opts[k] = True
        runCommand(comm, opts)

    except ValueError as e:
        print "\n--------------------==== gmri failed! ====--------------------\nERROR: Execution of gmri command %s failed!" % (comm)
        print e
        print "\nThe call received was: \n\ngmri %s " % (" \\\n    ".join(args))
        print "--------------------------------------------------------------"
        sys.exit(1)
    except SystemExit as e:
        sys.exit(e)
    except:
        print "\n--------------------==== gmri failed! ====--------------------\n\nERROR: Execution of command `%s` failed!" % (comm)
        print "       Please check documentation for the command (`gmri ?%s`)!" % (comm)
        print "\nThe call received was: \n\ngmri %s " % (" \\\n    ".join(args))
        print "\n--------------------------------------------------------------\nHere's the error as caught by python:\n"
        raise
        print "\n--------------------------------------------------------------\n"
        sys.exit(1)


if __name__ == "__main__":
    main()
