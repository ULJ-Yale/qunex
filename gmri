#!/usr/bin/env python2.7
# encoding: utf-8

import niutilities as niu
import niutilities.g_process as gp
import niutilities.g_nitools as gn
import niutilities.g_core as gc
import niutilities.g_exceptions as ge
import niutilities.g_commands as gcom
import os.path
import sys
import copy

# --- Get current Qu|Nex Suite version and prepend to help calls

tools     = os.environ['TOOLS']
qunexrepo = os.environ['QUNEXREPO']
with open(os.path.join(tools, qunexrepo, 'VERSION.md'), "r") as f:
    version  = f.read().strip()
print "Quantitative Neuroimaging Environment & Toolbox (Qu|Nex) Suite Version", version
print 

help = '''
================================================================================

Neuro Imaging utilities (niutilities) for processing and analysis.

usage: qunex <command> [option=value] [option=value] ...
       qunex            (prints this help)
       qunex ?<command> (print help for a given command)

       -------------------------------------------------------------------------
       Note the following conventions used in help and documentation:

       * Square brackets [] denote an option or argument that is optional. The
         value listed in the brackets is the default value used, if the argument
         is not explicitly specified
       * Angle brackets <> describe the value that should be provided
       * Dashes or "flags" (-) in the documentation define input variables.
       * Commands, arguments, and option names are either in small or "camel"
         case.
       * Use descriptions are in regular "sentence" case.
       * Option values are usually specified in capital case (e.g. YES/NO).
       -------------------------------------------------------------------------
'''

#
# Took out these two functions until fully integrated to avoid documentation confusion w/connector
# Also these should not be referenced as 'hcp' functions as they are not
#
# hcpdf hcp_DTIFit       Run FSL DTI fit.
# hcpdb hcp_Bedpostx     Run FSL Bedpostx GPU.

comlist = '''
================================================================================

General magnetic resonance Imaging (Qu|Nex) utilities for processing and analysis.

use: qunex <command> [option=value] [option=value] ...

--------------------------------------------------------------------------------

Note the following conventions used in help and documentation:

* Square brackets [] denote an option or argument that is optional. The
  value listed in the brackets is the default value used, if the argument
  is not explicitly specified.
* Angle brackets <> describe the value that should be provided.
* Dashes or "flags" (-) in the documentation define input variables.
* Commands, arguments, and option names are either in small or "camel" case.
* Use descriptions are in regular "sentence" case.
* Option values are usually specified in capital case (e.g. YES/NO).

--------------------------------------------------------------------------------

dicom utilities
---------------
listDicom    [folder=.]
splitDicom   [folder=.]
sortDicom    [folder=.]
dicom2nii    [folder=.] [clean=ask] [unzip=ask] [gzip=ask] [verbose=True] [cores=1]
dicom2niix   [folder=.] [clean=ask] [unzip=ask] [gzip=ask] [subjectid=None] [verbose=True] [cores=1] [tool=auto]
processInbox [subjectsfolder=.] [inbox=<subjectsfolder>/inbox/MR] [check=yes] [pattern=".*?(OP[0-9.-]+).*\.zip"] [tool=auto] [cores=1] [logfile=""] [archive=move] [verbose=yes]
getDICOMInfo dicomfile=<dicom_file> [scanner=siemens]

import utilities
----------------
BIDSImport   [subjectsfolder=.] [inbox=<subjectsfolder>/inbox/BIDS] [action=link] [overwrite=no] [archive=move] [bidsname=<inbox folder name>]
mapBIDS2nii  [sfolder='.'] [overwrite='no']
HCPLSImport  [subjectsfolder=.] [inbox=<subjectsfolder>/inbox/HCPLS] [action=link] [overwrite=no] [archive=move] [hcplsname=<inbox folder name>]
mapHCPLS2nii [sfolder='.'] [overwrite='no']


WUSTL NIL pipeline utilities
----------------------------
runNIL       [folder=.] [overwrite=no] [sfile=subject.txt]
runNILFolder [folder=.] [pattern=OP*] [overwrite=no] [sfile=subject.txt]


General image file utilities
----------------------------
sliceImage    sfile=<source image> tfile=<target image> [frames=1]


NIfTI file conversions
----------------------
fz2zf         inf=<input_image> [outf=<output_image>]
reorder       inf=<input_image> [outf=<output_image>]
reslice       inf=<input_image> slices=<slices_per_volume> [outf=<output_image>]
printniftihdr <image_filename>
modniftihdr   <image_filename> <modification string>
nifti24dfp    inf=<input_filename> [outf=<output_filename>]


HCP setup commands
------------------
getHCPReady    sessions=<sessions specification> [subjectsfolder=.] [sfile=subject.txt] [tfile=subject_hcp.txt] [mapping=specs/hcp_mapping.txt] [sfilter=None] [overwrite=no]
setupHCP       [sfolder=.] [tfolder=hcp] [sfile=subject_hcp.txt]
setupHCPFolder [subjectsfolder=.] [tfolder=hcp] [sfile=subject_hcp.txt] [check=interactive]


Miscellaneous file utilities
----------------------------
createStudy  studyfolder=<path to study base folder>
createBatch  [subjectsfolder=.] [sfile=subject_hcp.txt] [tfile=processing/batch.txt] [sessions=None] [sfilter=None] [overwrite=ask] [paramfile=<subjectsfolder>/specs/batch_parameters.txt]
createList  [subjectsfolder=.] [sessions=None] [sfilter=None] [listfile=None] [bolds=None] [conc=None] [fidl=None] [glm=None] [roi=None] [boldname="bold"] [boldtail=".nii.gz"] [overwrite="no"] [check="yes"]
createConc  [subjectsfolder=.] [sessions=None] [sfilter=None] [concfolder=None] [concname=""] [bolds=None] [boldname="bold"] [boldtail=".nii.gz"] [overwrite="no"] [check="yes"]
runlist  listfile=<path to runlist file> runlists=<name(s) of the list(s) to run> [logfolder=None]


Fidl file utilities
-------------------
joinFidl       concfile=<reference_conc_file> fidlroot=<fidl_files_root_pattern> [fidlname=<optional fidlname to append>]
joinFidlFolder concfolder=<folder_with_conc_files> [fidlfolder=<folder_with_fidl_files>] [outfolder=<folder in which to save joint files>] [fidlname=<optional fidl name to append>]
splitFidl      concfile=<reference_conc_file> fidlfile=<fidl_file_to_split> [outfolder=<folder_to_save_results>]
checkFidl      [fidlfile=] [fidlfolder=.] [plotfile=] [allcodes=false]


Caret & Workbench surface mapping utilities
-------------------------------------------
map2PALS volume=<volume file> metric=<metric file> [atlas=711-2C] [method=interpolated] [mapping=afm]
map2HCP volume=<volume file> [method=trilinear]
maskMap image=<image file> masks=<list of masks to use> [output=<output image name>] [minv=<list of thresholds>] [maxv=<list of thresholds>] [join=<OR or AND>]
joinMaps images=<image file list> output=<output file name> [names=<volume names list>] [originals=<remove or keep>]


PALM utilities
--------------
createWSPALMDesign factors=<factor string> nsubjects=<number of subjects> root=<design root name>
runPALM image=<image file(s)> [design=<design string>] [args=<arguments string>] [root=<root name for the output>] [options=<options string>] [cores=<number of cores to use in parallel>]  [overwite=no]

Scheduling utilities
--------------------
schedule [command=<command string>] [script=<path to script>] \
         settings=<settings string> \
         [replace=<"key:value|key:value" string>] \
         [workdir=<path to working directory>] \
         [environment=<path to environment setup script>] \
         [output=<string specifying how to process output>]


Processing commands
===================
In contrast to utilities listed above, processing commands can be submitted to
run on a computer cluster using either a PBS or LSF scheduling. The commands
operate on a list of sessions specified in a `batch.txt` file that provides
information about each session and his or her images and other information.
Options for the processing command can be specified either in the `batch.txt`
file or on the command line, the latter having priority if a parameter is
specified at both levels. No options need to be set for any of the commands
listed below. The key parameters with their default values are:

    sessions=batch.txt   ... the path to the batch.txt file
    subjectsfolder=.     ... the path to the study subjects folder
    overwrite=no         ... whether to overwrite existing results
    cores=1              ... how many cores to utilize for those
                             commands that can be parallelized
    nprocess=0           ... how many sessions to process (0=all)
    log=remove           ... whether to remove logs of commands that have
                             ran and finished successfully
    run=run              ... whether to run (run) the listed command or
                             test (test) if all the data is ready for the
                             specific command to run successfully

Please note that each of the commands can be run by specifying its short 
(listed first) or full (listed second) name followed by specfication of
processing options. 

HCP preprocessing commands
--------------------------
hcp1  hcp_PreFS        Run HCP Pre FreeSurfer pipeline.
hcp2  hcp_FS           Run HCP FreeSurfer pipeline.
hcp3  hcp_PostFS       Run HCP Post FreeSurfer pipeline.
hcp4  hcp_fMRIVolume   Run HCP fMRI Volume pipeline.
hcp5  hcp_fMRISurface  Run HCP fMRI Surface pipeline.
hcp6  hcp_ICAFix       Run HCP ICAFix pipeline.
hcpd  hcp_Diffusion    Run HCP DWI pipeline.

Functional connectivity preprocessing commands
----------------------------------------------
mhd  mapHCPData              Map HCP preprocessed data to sessions' image folder.
bbm  createBOLDBrainMasks    Create brain masks for BOLD runs.
cbs  computeBOLDStats        Compute BOLD movement and signal statistics.
csr  createStatsReport       Create BOLD movement statistic reports and plots.
ens  extractNuisanceSignal   Extract nuisance signal from BOLD images.
bpp  preprocessBold          Preprocess single BOLD images.
cpp  preprocessConc          Preprocess conc bundles of BOLD images.


General purpose commands
------------------------

rsc  runShellScript   Runs the specified script.


Legacy commands
---------------

seg    runBasicSegmentation     Run basic structural image segmentation using BET and FAST.
gfs    getFSData                Copy existing FreeSurfer data to sessions' images folder.
fss    runSubcorticalFS         Run subcortical freesurfer segmentation.
fsf    runFullFS                Run full freesurfer segmentation


NiTools functions
================
A number of Matlab functions provided as part of Qu|Nex/nitools package can be run.
A list of functions available is provided below. For more information on each
function run `qunex ?<function name>`. Arguments can be specified in any order.
Arguments that are not provided will be passed as empty strings / vectors to be
processed with default values. Take care to embed vectors in square brackets
(e.g. "[1 8 6 12]") and cell arrays in curly braces (e.g. "{'DLPFC', 'ACC',
'FEF'}"). In addition, 'saveOutput' argument can be specified to redirect Matlab
output to a file (e.g. "both:command.log" or "stdout:ok.log|stderr:error.log").

An example call of a Matlab function:

$ qunex g_FindPeaks fin='map_zstat.dscalar.nii' fout='map_peaks.dscalar.nii' \\
     mins="[50 50]" maxs="[300 350]" val=n t=3.5 projection=midthickness

List of available functions:
'''

for mcom in gn.functionList:
    comlist += "\n" + mcom

def runCommand(command, args):

    folders = gc.deduceFolders(args)

    if folders['basefolder']:
        niu.g_utilities.checkStudy(folders['basefolder'])

    # --- sort commands by type

    if command in gcom.commands:
        pass
    elif command in gp.allactions:
        gp.run(command, args)
        return
    elif command in gn.functions:
        if 'scheduler' in args:
            niu.g_scheduler.runThroughScheduler(command, sessions=None, args=args, cores=1, logfolder=folders['logfolder'])
        else:
            gn.run(command, args)
        return
    else:
        print "ERROR: Command %s not recognized. Please run gmri -l to see list of valid commands." % (command)
        sys.exit(1)

    # --- process commands

    # -- sort arguments

    bargs = {}
    eargs = {}
    for k, v in args.items():
        if k in gcom.commands[command]['args']:
            bargs[k] = v
        else:
            eargs[k] = v

    # -- check extra arguments

    if eargs:
        bad = []
        for k, v in eargs.items():
            if k not in gcom.extraParameters:
                bad.append(k)
                print "ERROR: Extra argument %s is not valid! Please check your command!" % (k)
        if bad:
            raise ge.CommandError("gmri", "Invalid arguments", "The extra argument(s) provided is/are not valid! [%s]" % (", ".join(bad)))

    # -- process extra arguments

    sessions = None
    if 'sessions' in eargs:
        if command != "runList" and not any([e in gcom.commands[command]['args'] for e in ['sfolder', 'folder']]):
            raise ge.CommandError("gmri", "Incompatible command", "Command %s can not be run on multiple sessions!" % (command))
        if folders['subjectsfolder'] is None:
            folders['subjectsfolder'] = "."
        sessions, gopts = gc.getSubjectList(eargs['sessions'], sfilter=eargs.get('filter'), subjid=eargs.get('subjid'), subjectsfolder=folders['subjectsfolder'], verbose=False)

    logname = eargs.get('logname')

    calls = []

    # -- runList specifics

    if command == "runList":
        if sessions and 'sperlist' in eargs:

            if 'scheduler' in eargs:

                # -- define number of sessions to run in each runList
                cores = int(eargs['sperlist'])
                args['cores'] = eargs['sperlist']
                if 'ignore' in args:
                    args['ignore'] += 'scheduler'
                else:
                    args['ignore'] = 'scheduler'
                del args['sperlist']

                niu.g_scheduler.runThroughScheduler(command, sessions=sessions, args=args, cores=cores, logfolder=folders['logfolder'], logname=logname)
            
            else:

                # -- define number of sessions to run in each runList
                sperlist = args['sperlist']                
                del args['sperlist']

                # -- define number of runLists to run in parallel
                cores = eargs.get('runinpar', 1)
                args['cores'] = cores
                if 'runinpar' in args:
                    del args['runinpar']

                c = 0
                while sessions:
                    c += 1
                    largs = args.copy()

                    # -- set up a list of sessions to run in each runList

                    slist = [sessions.pop(0)['id'] for e in range(sperlist) if sessions]
                    largs['subjid'] = "|".join(slist)

                    calls.append({'name': 'runList_%d' % (c), 'function': gcom.commands[command]['com'], 'args': largs, 'logfile': None})

        else:
            bargs['eargs'] = eargs
            gcom.commands[command]['com'](**bargs)
            print "\n===> Successful completion of task"

    # -- all other commands    
    else:

        cores = int(eargs.get('cores', '1'))

        # -- are we using a scheduler

        if 'scheduler' in eargs:
            niu.g_scheduler.runThroughScheduler(command, sessions=sessions, args=args, cores=cores, logfolder=folders['logfolder'], logname=logname)

        # -- a basic call

        elif sessions is None:
            gcom.commands[command]['com'](**args)
            print "\n===> Successful completion of task"

        # -- sessions loop

        else:

            for session in sessions:
                targs   = dict(bargs)
                name    = command + ": " + session['id']
                sfolder = os.path.join(folders['subjectsfolder'], session['id'])
                if folders['logfolder']:
                    logfile = os.path.join(folders['logfolder'], 'comlogs', "%s_%s.log" % (command, session['id']))
                for targ in ['sfolder', 'folder']:
                    if targ in gcom.commands[command]['args']:
                        targs[targ] = sfolder

                calls.append({'name': name, 'function': gcom.commands[command]['com'], 'args': targs, 'logfile': logfile})

    # -- Have we set up calls to run in parallel?
    if calls:

        callInfo = "Running %s" % (command)
        callInfo += "\n" + "".join(['=' for e in range(len(callInfo))])
        print callInfo
        
        print "\n===> Running %s through a list of sessions using %d cores" % (command, cores)

        results = gc.runInParallel(calls, cores=cores, prepend="     ... ")

        ok = True
        print "\n===> Final report for command", command
        results.sort(key=lambda x: x[0])
        for name, result, targetLog, prepend in results:
            if result:                
                ok = False
            else:
                result = 'completed'
            print "%s %s %s [log: %s]" % (prepend, name, result, targetLog)
        if ok:
            print "\n===> Successful completion of task"


def printHelp(com):

    # --- print list of gmri local commands
    if com == 'l':
        print comlist

    # --- print list of gmri local commands
    elif com == 'available':
        # -> gmri commands
        for c, v in gcom.commands.iteritems():
            print c
        # -> complex processing commands
        for l in gp.calist:
            if len(l):
                print l[0]
                print l[1]
        # -> longitudinal processing commands
        for l in gp.lalist:
            if len(l):
                print l[0]
                print l[1]
        # -> simple processing commands
        for l in gp.salist:
            if len(l):
                print l[0]
                print l[1]
        # -> matlab wrapped commands
        for l in gn.functions.keys():
            print l

    # --- print list of processing options and flags
    elif com in ['o']:
        print "================================================================="
        print ""
        print "Neuro Imaging utilities (niutilities) for processing and analysis"
        print "\nuse: qunex <command> [option=value] [option=value] ..."
        print "\nList of processing options"
        for line in gp.arglist:
            if len(line) == 4:
                print "  --%-24s %s [%s]" % (line[0], line[3], line[1])
            elif len(line) > 0:
                print "\n\n" + line[0] + '\n'
            else:
                print
        print "\nList of processing flags"
        for line in gp.flaglist:
            if len(line) == 4:
                print "  --%-24s %s" % (line[0], line[3])
            elif len(line) > 0:
                print "\n\n" + line[0] + '\n'
            else:
                print
        print

    # --- print help for gmri local commands
    elif com in gcom.commands:
        print "\nqunex", gcom.commands[com]['com'].__doc__.strip(), "\n"

    # --- print help for processing actions
    elif com in gp.allactions:
        print "\nqunex", gp.allactions[com].__doc__.strip(), "\n"

    # --- print help for matlab functions
    elif com in gn.functions:
        gn.help(com)

    # --- print general command list
    else:
        print comlist


def main(args=None):
    if args is None:
        args = sys.argv[1:]

    oargs = copy.deepcopy(args)

    if len(args) == 0:
        print help
        sys.exit(0)

    comm = args[0]
    opts = dict()

     # --- check if help arguments are specified and strip all flags (? or -)
    if comm[0] in ['?', '-']:
        comm = comm.strip('-')
        comm = comm.strip('?')
        try:
            printHelp(comm[0:])
        except:
            print "ERROR: '%s' is not a recognized command!\n-----------------------" % (comm[1:])
            print help
            raise
        sys.exit(0)

    try:
        for n in range(1, len(args)):
            if "=" in args[n]:
                k, v = args[n].split("=", 1)
                k = k.strip('-')
                opts[k] = v
            elif comm in gcom.commands:
                k = gcom.commands[comm]['args'][n - 1]
                opts[k] = args[n]
            else:
                k = args[n].strip('-')
                opts[k] = True
        runCommand(comm, opts)


    except ge.CommandNull as e:
        print ge.reportCommandNull(comm, e)
        print
        sys.exit(0)
    except ge.CommandFailed as e:
        print ge.reportCommandFailed(comm, e)
        print
        sys.exit(1)
    except ge.CommandError as e:
        print ge.reportCommandError(comm, e)
        print "\nThe call received was: \n(please note that when run through scheduler, all possible parameters, \neven non relevant ones are passed) \n\nqunex %s " % (" \\\n    ".join(oargs))
        print "\nPlease run `qunex ?%s` to get help for the failed command.\n" % (comm)
        sys.exit(1)
    except ValueError as e:
        print "\n--------------------==== Qu|Nex failed! ====--------------------\nERROR: Execution of qunex command %s failed!" % (comm)
        print e
        print "\nThe call received was: \n(please note that when run through scheduler, all possible parameters, \neven non relevant ones are passed) \n\nqunex %s " % (" \\\n    ".join(oargs))
        raise
        print "--------------------------------------------------------------"
        sys.exit(1)
    except SystemExit as e:
        sys.exit(e)
    except:
        print "\n--------------------==== Qu|Nex failed! ====--------------------\n\nERROR: Execution of command `%s` failed!" % (comm)
        print "       Please check documentation for the command (`qunex ?%s`)!" % (comm)
        print "\nThe call received was: \n(please note that when run through scheduler, all possible parameters, \neven non relevant ones are passed) \n\nqunex %s " % (" \\\n    ".join(oargs))
        print "\n--------------------------------------------------------------\nHere's the error as caught by python:\n"
        raise
        print "\n--------------------------------------------------------------\n"
        sys.exit(1)


if __name__ == "__main__":
    main()
