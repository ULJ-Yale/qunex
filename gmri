#!/usr/bin/env python
# encoding: utf-8

import niutilities as niu
import niutilities.g_process as gp
import niutilities.g_matlab as gm
import sys

help = '''
gmri utility for MRI processing and analysis.

usage: gmri <command> [option=value] [option=value] ...
       gmri -h         (prints this help)
       gmri -l         (list available commands)
       gmri -c         (list available processing commands)
       gmri -o         (list available processing options)
       gmri ?<command> (print help for a given command)

       -------------------------------------------------------------------------
       Note the following conventions used in help and documentation:

       * Square brackets [] denote an option or argument that is optional. The
         value listed in the brackets is the default value used, if the argument
         is not explicitly specified
       * Angle brackets <> describe the value that should be provided
       * Dashes or "flags" (-) in the documentation define input variables.
       * Commands, arguments, and option names are either in small or "camel"
         case.
       * Use descriptions are in regular "sentence" case.
       * Option values are usually specified in capital case (e.g. YES/NO).
       -------------------------------------------------------------------------
'''

comlist = '''
================================================================================
gmri utility for MRI processing and analysis.

use: gmri <command> [option=value] [option=value] ...

--------------------------------------------------------------------------------
Note the following conventions used in help and documentation:

* Square brackets [] denote an option or argument that is optional. The
  value listed in the brackets is the default value used, if the argument
  is not explicitly specified
* Angle brackets <> describe the value that should be provided
* Dashes or "flags" (-) in the documentation define input variables.
* Commands, arguments, and option names are either in small or "camel" case.
* Use descriptions are in regular "sentence" case.
* Option values are usually specified in capital case (e.g. YES/NO).
--------------------------------------------------------------------------------

dicom utilities
---------------
listDicom    [folder=.]
splitDicom   [folder=.]
sortDicom    [folder=.]
dicom2nii    [folder=.] [clean=ask] [unzip=ask] [gzip=ask] [verbose=True] [cores=1]
dicom2niix   [folder=.] [clean=ask] [unzip=ask] [gzip=ask] [verbose=True] [cores=1]
processInbox [folder=.] [check=yes] [pattern=".*?(OP[0-9.-]+).*\.zip"] [cores=1]
getDICOMInfo dfile=<dicom_file> [scanner=siemens]


WUSTL NIL pipeline utilities
----------------------------
runNIL       [folder=.] [overwrite=no] [subjf=subject.txt]
runNILFolder [folder=.] [pattern=OP*] [overwrite=no] [subjf=subject.txt]


General image file utilities
----------------------------
sliceImage sfile=<source image> tfile=<target image> [frames=1]


NIfTI file conversions
----------------------
fz2zf         inf=<input_image> [outf=<output_image>]
reorder       inf=<input_image> [outf=<output_image>]
reslice       inf=<input_image> slices=<slices_per_volume> [outf=<output_image>]
printniftihdr <image_filename>
modniftihdr   <image_filename> <modification string>
nifti24dfp    inf=<input_filename> [outf=<output_filename>]


HCP setup commands
------------------
getHCPReady    [folder=.] [sfile=subject.txt] [tfile=subject_hcp.txt] [pattern="*"] [mapping=specs/hcpmap.txt]
setupHCP       [folder=.] [tfolder=hcp] [sbjf=subject_hcp.txt]
setupHCPFolder [folder=.] [tfolder=hcp] [sbjf=subject_hcp.txt] [check=interactive]


Miscellaneous file utilities
----------------------------
createStudy        studyFolder=<path to study base folder>
compileSubjectsTxt [subjectsFolder=.] [sourceFiles=subject_hcp.txt] [targetFile=processing/subjects.txt] [overwrite=ask]


Fidl file utilities
-------------------
joinFidl       concfile=<reference_conc_file> fidlroot=<fidl_files_root_pattern>
joinFidlFolder concfolder=<folder_with_conc_files> [fidlfolder=<folder_with_fidl_files>] [outfolder=<folder in which to save joint files>]
splitFidl      concfile=<reference_conc_file> fidlfile=<fidl_file_to_split> [outfolder=<folder_to_save_results>]
checkFidl      [fidlfile=] [fidlfolder=.] [plotfile=] [allcodes=false]


Caret & Workbench surface mapping utilities
-------------------------------------------
map2PALS volume=<volume file> metric=<metric file> [atlas=711-2C] [method=interpolated] [mapping=afm]
map2HCP volume=<volume file> [method=trilinear]
maskMap image=<image file> masks=<list of masks to use> [output=<output image name>] [minv=<list of thresholds>] [maxv=<list of thresholds>] [join=<OR or AND>]
joinMaps images=<image file list> output=<output file name> [names=<volume names list>] [originals=<remove or keep>]


PALM utilities
--------------
createWSPALMDesign factors=<factor string> nsubjects=<number of subjects> root=<design root name>
runPALM image=<image file> [design=<design string>] [args=<arguments string>] [root=<root name for the output>] [cores=<number of cores to use in parallel>] [overwrite=no]


Scheduling utilities
--------------------
schedule [command=<command string>] [script=<path to script>] \
         settings=<settings string> \
         [replace=<"key:value|key:value" string>] \
         [workdir=<path to working directory>] \
         [environment=<path to environment setup script>] \
         [output=<string specifying how to process output>]


Processing commands
===================
In contrast to utilities listed above, processing commands can be submitted to
run on a computer cluster using either a PBS or LSF scheduling. The commands
operate on a list of subjects specified in a `subjects.txt` file that provides
information about each subject and his or her images and other information.
Options for the processing command can be specified either in the `subjects.txt`
file or on the command line, the latter having priority if a parameter is
specified at both levels. No options need to be set for any of the commands
listed below. The key parameters with their default values are:

    subjects=subjects.txt   ... the path to the subjects.txt file
    basefolder=.            ... the path to the study base folder
    overwrite=no            ... whether to overwrite existing results
    cores=1                 ... how many cores to utilize for those
                                commands that can be parallelized
    nprocess=0              ... how many subjects to process (0=all)
    log=remove              ... whether to remove logs of commands that have
                                ran and finished successfully
    run=run                 ... whether to run (run) the listed command or
                                test (test) if all the data is ready for the
                                specific command to run successfully

HCP preprocessing commands
--------------------------
hcp_PreFS        [preprocessing options] [preprocessing options] ...
hcp_FS           [preprocessing options] [preprocessing options] ...
hcp_PostFS       [preprocessing options] [preprocessing options] ...
hcp_fMRIVolume   [preprocessing options] [preprocessing options] ...
hcp_fMRISurface  [preprocessing options] [preprocessing options] ...
hcp_Diffusion    [preprocessing options] [preprocessing options] ...
hcp_DTIFit       [preprocessing options] [preprocessing options] ...
hcp_Bedpostx     [preprocessing options] [preprocessing options] ...


Functional connectivity preprocessing commands
----------------------------------------------
mapHCPData              [preprocessing options] [preprocessing options] ...
createBOLDBrainMasks    [preprocessing options] [preprocessing options] ...
computeBOLDStats        [preprocessing options] [preprocessing options] ...
createStatsReport       [preprocessing options] [preprocessing options] ...
extractNuisanceSignal   [preprocessing options] [preprocessing options] ...
preprocessBold          [preprocessing options] [preprocessing options] ...
preprocessConc          [preprocessing options] [preprocessing options] ...


Matlab functions
================
A number of Matlab functions provided as part of MNAP/matlab package can be run.
A list of functions available is provided below. For more information on each
function run `gmri ?<function name>`. Arguments can be specified in any order.
Arguments that are not provided will be passed as empty strings / vectors to be
processed with default values. Take care to embed vectors in square brackets
(e.g. "[1 8 6 12]") and cell arrays in curly braces (e.g. "{'DLPFC', 'ACC',
'FEF'}"). In addition, 'saveOutput' argument can be specified to redirect Matlab
output to a file (e.g. "both:command.log" or "stdout:ok.log|stderr:error.log").

An example call of a Matlab function:

gmri g_FindPeaks fin='map_zstat.dscalar.nii' fout='map_peaks.dscalar.nii' \\
     mins="[50 50]" maxs="[300 350]" val=n t=3.5 projection=midthickness

List of available functions:
'''

for mcom in gm.functionList:
    comlist += "\n" + mcom

commands = {'listDicom'            : {'com': niu.g_dicom.listDicom,              'args': ('folder', )},
            'splitDicom'           : {'com': niu.g_dicom.splitDicom,             'args': ('folder', )},
            'sortDicom'            : {'com': niu.g_dicom.sortDicom,              'args': ('folder', )},
            'dicom2nii'            : {'com': niu.g_dicom.dicom2nii,              'args': ('folder', 'clean', 'unzip', 'gzip', 'verbose', 'cores')},
            'dicom2niix'           : {'com': niu.g_dicom.dicom2niix,             'args': ('folder', 'clean', 'unzip', 'gzip', 'verbose', 'cores')},
            'processPhilips'       : {'com': niu.g_dicom.processPhilips,         'args': ('folder', 'check', 'pattern')},
            'processInbox'         : {'com': niu.g_dicom.processInbox,           'args': ('folder', 'inbox', 'check', 'pattern', 'cores')},
            'getDICOMInfo'         : {'com': niu.g_dicom.getDICOMInfo,           'args': ('dfile', 'scanner')},
            'runNILFolder'         : {'com': niu.g_4dfp.runNILFolder,            'args': ('folder', 'pattern', 'overwite', 'subjf')},
            'runNIL'               : {'com': niu.g_4dfp.runNIL,                  'args': ('folder', 'overwite', 'subjf')},
            'fz2zf'                : {'com': niu.g_NIfTI.fz2zf,                  'args': ('inf', 'outf')},
            'reorder'              : {'com': niu.g_NIfTI.reorder,                'args': ('inf', 'outf')},
            'reslice'              : {'com': niu.g_NIfTI.reslice,                'args': ('inf', 'slices', 'outf')},
            'sliceImage'           : {'com': niu.g_img.sliceImage,               'args': ('sfile', 'tfile', 'frames')},
            'nifti24dfp'           : {'com': niu.g_NIfTI.nifti24dfp,             'args': ('inf', 'outf')},
            'setupHCP'             : {'com': niu.g_HCP.setupHCP,                 'args': ('folder', 'tfolder', 'subjf')},
            'setupHCPFolder'       : {'com': niu.g_HCP.setupHCPFolder,           'args': ('folder', 'tfolder', 'subjf', 'check')},
            'getHCPReady'          : {'com': niu.g_HCP.getHCPReady,              'args': ('folder', 'sfile', 'tfile', 'pattern', 'mapping')},
            'printniftihdr'        : {'com': niu.g_img.printniftihdr,            'args': ('filename', )},
            'modniftihdr'          : {'com': niu.g_gimg.modniftihdr,             'args': ('filename', 's')},
            'compileSubjectsTxt'   : {'com': niu.g_utilities.compileSubjectsTxt, 'args': ('subjectsFolder', 'sourceFiles', 'targetFile', 'overwrite', 'paramFile')},
            'createStudy'          : {'com': niu.g_utilities.createStudy,        'args': ('studyFolder', )},
            'joinFidl'             : {'com': niu.g_fidl.joinFidl,                'args': ('concfile', 'fidlroot', 'outfolder')},
            'joinFidlFolder'       : {'com': niu.g_fidl.joinFidlFolder,          'args': ('concfolder', 'fidlfolder', 'outfolder')},
            'splitFidl'            : {'com': niu.g_fidl.splitFidl,               'args': ('concfile', 'fidlfile', 'outfolder')},
            'checkFidl'            : {'com': niu.g_fidl.checkFidl,               'args': ('fidlfile', 'fidlfolder', 'plotfile', 'allcodes')},
            'map2PALS'             : {'com': niu.g_4dfp.map2PALS,                'args': ('volume', 'metric', 'atlas', 'method', 'mapping')},
            'map2HCP'              : {'com': niu.g_4dfp.map2HCP,                 'args': ('volume', 'method')},
            'maskMap'              : {'com': niu.g_palm.maskMap,                 'args': ('image', 'masks', 'output', 'minv', 'maxv')},
            'joinMaps'             : {'com': niu.g_palm.joinMaps,                'args': ('images', 'output', 'names', 'originals', 'join')},
            'runPALM'              : {'com': niu.g_palm.runPALM,                 'args': ('image', 'design', 'args', 'root', 'cores', 'overwrite')},
            'createWSPALMDesign'   : {'com': niu.g_palm.createWSPALMDesign,      'args': ('factors', 'nsubjects', 'root')},
            'schedule'             : {'com': niu.g_scheduler.schedule,           'args': ('command', 'script', 'settings', 'replace', 'workdir', 'environment', 'output')}
            }


def runCommand(command, args):
    if command in commands:
        commands[command]['com'](**args)
    elif command in gp.pactions or command in gp.sactions:
        gp.run(command, args)
    elif command in gm.functions:
        gm.run(command, args)
    else:
        print "ERROR: Command %s not recognized. Please run gmri -l to see list of valid commands." % (command)
        # print help
        sys.exit(1)


def printHelp(com):

    # --- print list of gmri local commands
    if com == 'l':
        print comlist

    # --- print list of gmri local commands
    elif com == 'available':
        # -> gmri commands
        for c, v in commands.iteritems():
            print c
        # -> complex processing commands
        for l in gp.calist:
            if len(l):
                print l[0]
                print l[1]
        # -> simple processing commands
        for l in gp.salist:
            if len(l):
                print l[0]
                print l[1]
        # -> matlab wrapped commands
        for l in gm.functions.keys():
            print l

    # --- print list of processing options and flags
    elif com in ['o']:
        print "================================================================================"
        print "gmri utility for MRI processing and analysis."
        print "\nuse: gmri <command> [option=value] [option=value] ..."
        print "\nList of processing options"
        for line in gp.arglist:
            if len(line) == 4:
                print "  --%-24s %s [%s]" % (line[0], line[3], line[1])
            elif len(line) > 0:
                print "\n\n" + line[0] + '\n'
            else:
                print
        print "\nList of processing flags"
        for line in gp.flaglist:
            if len(line) == 4:
                print "  --%-24s %s" % (line[0], line[3])
            elif len(line) > 0:
                print "\n\n" + line[0] + '\n'
            else:
                print
        print

    # --- print list of processing options and flags
    elif com in ['c']:
        print "================================================================================"
        print "gmri utility for MRI processing and analysis."
        print "\nuse: gmri <command> [option=value] [option=value] ..."
        print "\nList of processing commands \n"
        for line in gp.calist + [[]] + gp.salist:
            if len(line) == 4:
                print "   %-6s %-24s %s" % (line[0], line[1], line[3])
            elif len(line) > 0:
                print "\n\n" + line[0] + '\n'
            else:
                print
        print

    # --- print help for gmri local commands
    elif com in commands:
        print "\ngmri", commands[com]['com'].__doc__.strip(), "\n"

    # --- print help for processing paralelised actions
    elif com in gp.pactions:
        print "\ngmri", gp.pactions[com].__doc__.strip(), "\n"

    # --- print help for processing serial actions
    elif com in gp.sactions:
        print "\ngmri", gp.sactions[com].__doc__.strip(), "\n"

    # --- print help for matlab functions
    elif com in gm.functions:
        gm.help(com)

    # --- print general command list
    else:
        print comlist


def main(args=None):
    if args is None:
        args = sys.argv[1:]

    if len(args) == 0:
        print help
        sys.exit(0)

    comm = args[0]
    opts = dict()

    if comm[0] in ['?', '-']:
        try:
            printHelp(comm[1:])
        except:
            print "ERROR: '%s' is not a recognized command!\n-----------------------" % (comm[1:])
            print help
            raise
        sys.exit(0)

    try:
        for n in range(1, len(args)):
            if "=" in args[n]:
                k, v = args[n].split("=", 1)
                k = k.strip('-')
                opts[k] = v
            elif comm in commands:
                k = commands[comm]['args'][n - 1]
                opts[k] = args[n]
            else:
                k = args[n].strip('-')
                opts[k] = True

        runCommand(comm, opts)
    except ValueError as e:
        print "\n--------------------==== gmri failed! ====--------------------\nERROR: Execution of gmri command %s failed!" % (comm)
        print e
        print "\nThe call received was: \n\ngmri %s " % (" \\\n    ".join(args))
        print "--------------------------------------------------------------"
        sys.exit(1)
    except SystemExit as e:
        sys.exit(e)
    except:
        print "\n--------------------==== gmri failed! ====--------------------\n\nERROR: Execution of command `%s` failed!" % (comm)
        print "       Please check documentation for the command (`gmri ?%s`)!" % (comm)
        print "\nThe call received was: \n\ngmri %s " % (" \\\n    ".join(args))
        print "\n--------------------------------------------------------------\nHere's the error as caught by python:\n"
        raise
        print "\n--------------------------------------------------------------\n"
        sys.exit(1)


if __name__ == "__main__":
    main()
