#!/usr/bin/env python
# encoding: utf-8

# SPDX-FileCopyrightText: 2021 QuNex development team <https://qunex.yale.edu/>
#
# SPDX-License-Identifier: GPL-3.0-or-later

"""
``core.py``

This file holds code for core support functions used by other code for
preprocessing and analysis. The functions are for internal use
and can not be called externally.
"""

import inspect
import re
import os.path
import os
import shutil
import subprocess
import time
import multiprocessing
import glob
import sys
import types
import traceback
import gzip
from datetime import datetime
from concurrent.futures import ProcessPoolExecutor

import general.filelock as fl
import general.exceptions as ge
import general.commands_support as gcs


def print_qunex_header(timestamp=None, file=None):
    """
    ``print_qunex_header(timestamp=None, file=None)``

    Prepares and returns a standard "Generated by QuNex" string. If file
    is not None, it prints it to the specified file. If timestamp is not
    none, it uses the specified timestamp, which can be either a string
    or a datetime object.
    """
    if timestamp is None:
        timestamp = datetime.now().strftime("%Y-%m-%d_%H.%M.%S.%f")
    elif type(timestamp) is datetime:
        timestamp = timestamp.strftime("%Y-%m-%d_%H.%M.%S.%f")

    header = f"# Generated by QuNex {get_qunex_version()} on {timestamp}"
    if file:
        print(header, file=file)

    return header


def read_session_data(filename, verbose=False):
    """
    ``read_session_data(filename, verbose=False)``

    Reads a `batch.txt` file.

    USE
    ===

    An internal function for reading `batch.txt` and `session.txt` files. It
    reads the file and returns a list of sessions with the information on images
    and the additional parameters specified in the header.

    """

    if not os.path.exists(filename):
        print(
            "\n\n=====================================================\nERROR: Source file does not exist [%s]"
            % (filename)
        )
        raise ValueError("ERROR: Batch file not found: %s" % (filename))

    file = open(filename, "r")
    s = file.read()
    s = s.replace("\r", "\n")
    s = s.replace("\n\n", "\n")
    s = re.sub("^#.*?\n", "", s)

    s = s.split("\n---")
    s = [e for e in s if len(e) > 10]

    nsearch = re.compile(r"(.*?)\((.*)\)")
    csearch = re.compile(r"c([0-9]+)$")

    slist = []
    gpref = {}

    c = 0
    # first "session" is the parameters block
    first = True
    try:
        for sub in s:
            sub = sub.split("\n")
            sub = [e.strip() for e in sub]
            sub = [e.split("#")[0].strip() for e in sub]
            sub = [e for e in sub if len(e) > 0]

            dic = {}
            for line in sub:
                c += 1

                # --- read preferences / settings
                if line.startswith("--"):
                    pkey, pvalue = [e.strip() for e in line.split(":", 1)]
                    if first:
                        gpref[pkey[2:]] = pvalue
                    else:
                        dic[pkey] = pvalue
                    continue

                elif line.startswith("_") or line.startswith("-"):
                    pkey, pvalue = [e.strip() for e in line.split(":", 1)]
                    if first:
                        gpref[pkey[1:]] = pvalue
                    else:
                        dic[pkey] = pvalue
                    continue

                # --- split line
                line = line.split(":")
                line = [e.strip() for e in line]
                if len(line) < 2:
                    continue

                # --- read ima data
                if line[0].isdigit():
                    image = {}
                    image["ima"] = line[0]
                    remove = []
                    for e in line:
                        m = nsearch.match(e)
                        if m:
                            image[m.group(1).strip()] = m.group(2).strip()
                            remove.append(e)

                    for e in remove:
                        line.remove(e)

                    ni = len(line)
                    if ni > 1:
                        image["name"] = line[1]
                    if ni > 2 and ("bold" in image["name"]) or ("DWI" in image["name"]):
                        image["task"] = line[2]
                    if ni > 3:
                        image["ext"] = line[3]

                    dic[line[0]] = image

                # --- read conc data
                elif csearch.match(line[0]):
                    conc = {}
                    conc["cnum"] = line[0]
                    for e in line:
                        m = nsearch.match(e)
                        if m:
                            conc[m.group(1).strip()] = m.group(2).strip()
                            line.remove(e)

                    ni = len(line)
                    if ni < 3:
                        print("Missing data for conc entry!")
                        raise AssertionError(
                            "Not enough values in conc definition line!"
                        )

                    conc["label"] = line[1]
                    conc["conc"] = line[2]
                    conc["fidl"] = line[3]
                    dic[line[0]] = conc

                # --- read rest of the data
                else:
                    dic[line[0]] = ":".join(line[1:])

            if len(dic) > 0:
                if ("id" not in dic) and ("session" not in dic):
                    if verbose:
                        print(
                            "WARNING: There is a record missing an id field and is being omitted from processing."
                        )
                else:
                    if "id" in dic and "session" not in dic:
                        dic["session"] = dic["id"]
                    elif "session" in dic and "id" not in dic:
                        dic["id"] = dic["session"]
                    slist.append(dic)

            # check paths
            for field in ["dicom", "raw_data", "data", "hpc"]:
                if field in dic:
                    if not os.path.exists(dic[field]) and verbose:
                        print(
                            "WARNING: session %s - folder %s: %s specified in %s does not exist! Check your paths!"
                            % (dic["id"], field, dic[field], os.path.basename(filename))
                        )

            # done with the parameters block
            first = False

    except:
        print(
            "\n\n=====================================================\nERROR: There was an error with the batch.txt file in line %d:\n---> %s\n\n--------\nError raised:\n"
            % (c, line)
        )
        raise

    return slist, gpref


def read_list(filename, verbose=False):
    """
    ``read_list(filename, verbose=False)``

    An internal function for reading list files. It reads the file and
    returns a list of sessions each with the provided list of files.
    """

    slist = []
    session = {}

    with open(filename) as f:
        for line in f:
            if line.strip()[:1] == "#":
                continue

            line = [e.strip() for e in line.split(":")]

            if len(line) == 2:
                if line[0] == "session id":
                    if session != {}:
                        slist.append(session.copy())
                    session = {}
                    session["id"] = line[1]

                else:
                    if line[0] in session:
                        session[line[0]].append(line[1])
                    else:
                        session[line[0]] = [line[1]]
        slist.append(session)
    return slist


def get_sessions_list(
    listString, filter=None, sessionids=None, sessionsfolder=None, verbose=False
):
    """
    ``get_sessions_list(listString, filter=None, sessionids=None, sessionsfolder=None, verbose=False)``

    Gets a list of sessions as an array of dictionaries.

    USE
    ===

    An internal function for getting a list of sessions as an array of
    dictionaries in the form::

        [{'id': <session id>, [... other keys]}, {'id': <session id>, [... other keys]}]

    The provided listString can be:

    - a comma, space or pipe separated list of session id codes,
    - a path to a batch file (identified by .txt extension),
    - a path to a `*.list` file (identified by .list extension).

    In the first cases, the dictionary will include only session ids, in the
    second all the other information present in the batch file, in the third
    lists of specified files, e.g.::

        [{'id': <session id>, 'file': [<first file>, <second file>], 'roi': [<first file>], ...}, ...]

    If filter is provided (not None), only sessions that match the filter will
    be returned. If sessionids is provided (not None), only sessions with
    matching id will be returned. If sessionsfolder is provided (not None),
    sessions from a listString will be treated as glob patterns and all folders
    that match the pattern in the sessionsfolder will be returned as session
    ids.
    """

    gpref = {}

    listString = listString.strip()

    if re.match(r".*\.list$", listString):
        slist = read_list(listString, verbose=verbose)

    elif os.path.isfile(listString):
        slist, gpref = read_session_data(listString, verbose=verbose)

    elif (
        re.match(r".*\.txt$", listString) or "/" in listString
    ) and sessionids is None:
        raise ValueError(
            f"ERROR: The specified session file is not found and sessionids are not provided! [{listString}]!"
        )

    else:
        if (
            re.match(r".*\.txt$", listString)
            or "/" in listString
            and sessionids is not None
        ):
            listString = sessionids

        slist = [e.strip() for e in re.split(r" +|,|\|", listString)]

        if sessionsfolder is None:
            slist = [{"id": e} for e in slist]

        else:
            nlist = []
            for s in slist:
                nlist += glob.glob(os.path.join(sessionsfolder, s))
            slist = [{"id": os.path.basename(e)} for e in nlist]

    # filter with sessionids
    if sessionids is not None and sessionids.strip() != "":
        sessionids = re.split(r" +|,|\|", sessionids)
        filtered_slist = []
        for s in slist:
            if "id" in s and s["id"] in sessionids:
                filtered_slist.append(s)
            elif "session" in s and s["session"] in sessionids:
                filtered_slist.append(s)

        slist = filtered_slist

    # filter with filter
    if filter is not None and filter.strip() != "":
        try:
            filters = [[f.strip() for f in e.split(":")] for e in filter.split("|")]
        except:
            raise ge.CommandFailed(
                "get_sessions_list",
                "Invalid filter parameter",
                "The provided filter parameter is invalid: '%s'" % (filter),
                "The parameter should be a '|' separated  string of <key>:<value> pairs!",
                "Please adjust the parameter!",
            )

        if any([len(e) != 2 for e in filters]):
            raise ge.CommandFailed(
                "get_sessions_list",
                "Invalid filter parameter",
                "The provided filter parameter is invalid: '%s'" % (filter),
                "The parameter should be a '|' separated  string of <key>:<value> pairs!",
                "Please adjust the parameter!",
            )

        filtered_slist = []
        for s in slist:
            for key, value in filters:
                if key in s and (s[key] == value or re.match(value, s[key])):
                    filtered_slist.append(s)
                    break

        slist = filtered_slist

    # are we inside a SLURM job array?
    if "SLURM_ARRAY_TASK_ID" in os.environ:
        # get ID for this job
        slurm_array_ix = int(os.environ["SLURM_ARRAY_TASK_ID"])

        # get size of job array
        slurm_array_size = int(os.environ["SLURM_ARRAY_TASK_MAX"]) + 1

        # get the chunk
        slist = slist[slurm_array_ix::slurm_array_size]

    return slist, gpref


def deduceFolders(args):
    """
    ``deduceFolders(args)``

    Tries to deduce the location of study specific folders based on the provided
    arguments. For internal use only.
    """

    reference = args.get("reference")
    logfolder = args.get("logfolder")
    basefolder = args.get("basefolder")
    if not basefolder:
        basefolder = args.get("studyfolder")
    sessionsfolder = args.get("sessionsfolder")
    sourcefolder = args.get("sourcefolder")
    folder = args.get("folder")

    if sessionsfolder:
        sessionsfolder = os.path.abspath(sessionsfolder)

    if basefolder is None:
        if sessionsfolder:
            basefolder = os.path.dirname(sessionsfolder)
        else:
            for f in [
                os.path.abspath(e)
                for e in [logfolder, sourcefolder, folder, reference, "."]
                if e
            ]:
                if f and not basefolder:
                    while os.path.dirname(f) and os.path.dirname(f) != "/":
                        f = os.path.dirname(f)
                        if os.path.exists(os.path.join(f, ".qunexstudy")):
                            basefolder = f
                            break
                        elif os.path.exists(os.path.join(f, ".mnapstudy")):
                            basefolder = f
                            break

    if logfolder is None:
        logfolder = os.path.abspath(".")
        if basefolder:
            logfolder = os.path.join(basefolder, "processing", "logs")

    return {
        "basefolder": basefolder,
        "sessionsfolder": sessionsfolder,
        "logfolder": logfolder,
    }


def runExternalParallel(calls, cores=None, prepend=""):
    """
    ``runExternalParallel(calls, cores=None, prepend='')``

    Runs external commands specified in 'calls' in parallel utilizing all the
    available or the number of cores specified in 'cores'.

    Parameters:
        --calls (list):
            A list of dictionaries that specifies the commands to run. It should
            consists of:

            - 'name' ... the name of the command to run
            - 'args' ... the actual command provided as a list of arguments
            - 'sout' ... the name of the log file to which to direct the
              standard output from the command ran.

        --cores (int | str, default 'all'):
            Number of elements to run in parallel for grayordinate
            decomposition. If specified as None or 'all', all available elements
            (3 max for left surface, right surface and volume files) will be
            used. One element per CPU core is processed at a time.

        --prepend (str):
            The string to prepend to each line of progress report.

    Examples:
        ::

            runExternalParallel({'name': 'List all zip files', 'args': ['ls' '-l' '*.zip'], 'sout': 'zips.log'}, \\
            cores=1, prepend=' ... ')
    """

    if cores is None or cores in ["all", "All", "ALL"]:
        try:
            cores = len(os.sched_getaffinity(0))
        except:
            cores = multiprocessing.cpu_count()
    else:
        try:
            cores = int(cores)
        except:
            cores = 1

    running = []
    completed = []

    while True:
        # --- check if we can add a process to run
        if len(running) < cores:
            if calls:
                call = calls.pop(0)
                if call["sout"]:
                    if os.path.exists(call["sout"]):
                        sout = open(call["sout"], "a", 1)
                    else:
                        sout = open(call["sout"], "w", 1)
                else:
                    sout = open(os.devnull, "w")

                print(
                    "Starting log for %s at %s\nThe command being run: \n>> %s\n"
                    % (
                        call["name"],
                        str(datetime.now()).split(".")[0],
                        " ".join(call["args"]),
                    ),
                    file=sout,
                )

                try:
                    if "shell" in call and call["shell"]:
                        running.append(
                            {
                                "call": call,
                                "sout": sout,
                                "p": subprocess.Popen(
                                    call["args"],
                                    stdout=sout,
                                    stderr=sout,
                                    bufsize=0,
                                    shell=True,
                                ),
                            }
                        )
                    else:
                        running.append(
                            {
                                "call": call,
                                "sout": sout,
                                "p": subprocess.Popen(
                                    call["args"], stdout=sout, stderr=sout, bufsize=0
                                ),
                            }
                        )

                    if call["sout"]:
                        print(
                            prepend
                            + "started running %s at %s, track progress in %s"
                            % (
                                call["name"],
                                str(datetime.now()).split(".")[0],
                                call["sout"],
                            )
                        )
                    else:
                        print(
                            prepend
                            + "started running %s at %s"
                            % (call["name"], str(datetime.now()).split(".")[0])
                        )
                except:
                    print(
                        prepend
                        + "ERROR: failed to start running %s. Please check your environment!"
                        % (call["name"])
                    )
                    completed.append(
                        {
                            "exit": -9,
                            "name": call["name"],
                            "log": call["sout"],
                            "args": call["args"],
                        }
                    )
                continue

        # --- check if a process finished
        done = []
        for n in range(len(running)):
            running[n]["sout"].flush()

            if running[n]["p"].poll() is not None:
                running[n]["sout"].close()
                if running[n]["call"]["sout"]:
                    print(
                        prepend
                        + "finished running %s (exit code: %d), log in %s"
                        % (
                            running[n]["call"]["name"],
                            running[n]["p"].poll(),
                            running[n]["call"]["sout"],
                        )
                    )
                else:
                    print(
                        prepend
                        + "finished running %s (exit code: %d)"
                        % (running[n]["call"]["name"], running[n]["p"].poll())
                    )
                completed.append(
                    {
                        "exit": running[n]["p"].poll(),
                        "name": running[n]["call"]["name"],
                        "log": running[n]["call"]["sout"],
                        "args": running[n]["call"]["args"],
                    }
                )
                done.append(n)
        if done:
            while done:
                running.pop(done.pop())
            continue

        # --- check if we are done:
        if not calls and not running:
            print(prepend + "DONE")
            break

        # --- wait a bit
        time.sleep(1)

    return completed


results = []
lock = multiprocessing.Lock()


def record(response):
    """
    ``record(response)``

    Appends response from a completed function.

    For internal use only.
    """

    global results

    results.append(response)

    with lock:
        name, result, targetLog, prepend = response
        if targetLog:
            see = " [log: %s]." % (targetLog)
        else:
            see = "."

        if result:
            print("%s%s failed%s" % (prepend, name, see))
        else:
            print("%s%s finished successfully%s" % (prepend, name, see))


def record_future(future):
    if future.exception() is not None:
        print("Unhandled exception")
        print(future.exception())
    else:
        record(future.result())


# Logger class that prints both to stdour and to console
class Logger(object):
    def __init__(self, logfile):
        self.terminal = sys.stdout
        self.log = open(logfile, "a")

    def write(self, message):
        self.terminal.write(message)
        self.log.write(message)

    def close(self):
        self.log.close()

    def flush(self):
        # this flush method is needed for python 3 compatibility.
        # this handles the flush command by doing nothing.
        # you might want to specify some extra behavior here.
        pass


def runWithLog(function, args=None, logfile=None, name=None, prepend=""):
    """
    ``runWithLog(function, args=None, logfile=None, name=None)``

    Runs a function with the arguments by redirecting standard output and
    standard error to the specified log file.

    For internal use only.
    """

    timestamp = datetime.now().strftime("%Y-%m-%d_%H.%M.%S.%f")

    if name is None:
        name = function.__name__

    if logfile:
        logfolder, logname = os.path.split(logfile)

        base_logname, ext_logname = os.path.splitext(logname)
        logname = base_logname + "_" + timestamp + ext_logname

        # truncate too long lognames
        max_log_length = 150
        if len(logname) > max_log_length:
            logname = logname[:max_log_length] + "(...).log"

        tlogfile = os.path.join(logfolder, "tmp_" + logname)

        if not os.path.exists(logfolder):
            os.makedirs(logfolder)
        with lock:
            # header
            with open(tlogfile, "w") as f:
                print_qunex_header(timestamp=timestamp, file=f)
                print("#", file=f)
            print(
                prepend
                + "started running %s at %s, track progress in %s"
                % (name, str(datetime.now()).split(".")[0], tlogfile)
            )

        sysstdout = sys.stdout
        sysstderr = sys.stderr
        sys.stdout = Logger(tlogfile)
        sys.stderr = sys.stdout
    else:
        with lock:
            print(print_qunex_header(timestamp=timestamp))
            print("#")
            print(
                prepend
                + "started running %s at %s" % (name, str(datetime.now()).split(".")[0])
            )

    with lock:
        print(
            "call: gmri %s %s\n-----------------------------------------"
            % (
                function.__name__,
                " ".join(['%s="%s"' % (k, v) for (k, v) in args.items()]),
            )
        )

    try:
        # remove logfolder from args if it is not in function's footprint
        if (
            "logfolder" in args
            and "logfolder" not in inspect.signature(function).parameters
        ):
            del args["logfolder"]
        result = function(**args)
    except ge.CommandNull as e:
        with lock:
            print(ge.reportCommandNull(name, e))
            print
        result = e
    except ge.CommandFailed as e:
        with lock:
            print(ge.reportCommandFailed(name, e))
            print
        result = e
    except Exception as e:
        with lock:
            print("\n\nERROR")
            print(traceback.format_exc())
        result = e

    with lock:
        print(
            "\n-----------------------------------------\nFinished at %s"
            % (datetime.now().strftime("%Y-%m-%d %H:%M:%S"))
        )

    # schedule command fix
    if name == "schedule":
        result = False

    if not result:
        print("\n---> Successful completion of task")

    if logfile:
        sys.stdout.close()
        sys.stdout = sysstdout
        sys.stderr = sysstderr

        # log prefix
        log_prefix = "done_"
        if result:
            log_prefix = "error_"
        comlogname = os.path.join(logfolder, log_prefix + logname)

        os.rename(os.path.join(logfolder, "tmp_" + logname), comlogname)

        # create runlog
        if "comlog" in logfolder:
            logfolder = logfolder.replace("comlog", "runlog")

            if not os.path.exists(logfolder):
                try:
                    os.makedirs(logfolder)
                except:
                    r = "\n\nERROR: Could not create folder for logfile [%s]!" % (
                        logfolder
                    )
                    print(r)
                    raise ge.CommandFailed(function="runWithLog", error=r)

        # runlog file
        runlogname = "Log-" + logname

        # print to runlog file and close
        logfile = os.path.join(logfolder, runlogname)
        lf = open(logfile, "a")

        # header
        lf.write("%s\n" % (print_qunex_header(timestamp=timestamp)))
        lf.write("#\n")

        # split name to command name and session
        split = name.split(": ")

        # print session if exists
        if len(split) > 1:
            print("session: %s\n" % split[1])

        # print command name
        lf.write("qunex %s\n" % split[0])
        for k, v in args.items():
            lf.write('  --%s="%s"\n' % (k, v))

        # print final status
        if result:
            lf.write("\nERROR running %s\n" % name)
        else:
            lf.write("\n---> Successful completion of task\n")

        lf.close()
    else:
        comlogname = None

    return name, result, comlogname, prepend


def runInParallel(calls, cores=None, prepend=""):
    """
    ``runInParallel(calls, cores=None, prepend="")``

    Runs functions specified in 'calls' in parallel utilizing all the available
    or the number of cores specified in 'cores'.

    INPUTS
    ======

    --calls        A list of dictionaries that specifies the commands to run.
                   It should consists of:

                   - name (the name of the command to run)
                   - function (the function to be run)
                   - args (the arguments to be passed to the function)
                   - logfile (the path to the log file to which to direct the
                     standard output from the command ran)

    --cores        The number of cores to utilize. If specified as None or
                   'all', all available cores will be utilized.
    --prepend      The string to prepend to each line of progress report.

    EXAMPLE USE
    ===========

    ::

        runInParallel({'name': 'Sort dicom files', 'function': dicom.sort_dicom, 'args': {'folder': '.'}, 'sout': 'sort_dicom.log'}, cores=1, prepend=' ... ')
    """

    global results

    if cores is None or cores in ["all", "All", "ALL"]:
        cores = len(os.sched_getaffinity(0))
    else:
        try:
            cores = int(cores)
        except:
            cores = 1

    results = []
    with ProcessPoolExecutor(max_workers=cores) as executor:
        for call in calls:
            future = executor.submit(
                runWithLog,
                call["function"],
                call["args"],
                call["logfile"],
                call["name"],
                prepend,
            )
            future.add_done_callback(record_future)

    return results


def checkFiles(testFolder, specFile, fields=None, report=None, append=False):
    """
    ``checkFiles(testFolder, specFile, fields=None, report=None, append=False)``

    Check the testFolder for presence of files as specified in specFile, which
    lists files one per line with space delimited paths. Additionally an array
    of key-value pairs can be provided. If present every instance of {<key>}
    will be replaced by <value>. If report is specified, a report will be
    written to that file. Where there might be two alternative options of results
    e.g. difference because of AP/PA direction, then the alternative is to
    be provided in the same line separated by a pipe '|'
    """

    # --- open the report if needed:

    if report:
        if type(report) is types.FileType:
            rout = report
            fileClose = False
        else:
            fileClose = True
            try:
                if append:
                    rout = open(report, "a")
                else:
                    rout = open(report, "w")
            except:
                raise ge.CommandFailed(
                    "checkFiles",
                    "Report file could not be opened",
                    "Failed to open a report file for writing: %s" % (report),
                    "Please check your settings and paths!",
                )
        print(
            "\n#-----------------------------------------\n# Full file check report\n# . denotes file present\n# X denotes file absent\n",
            file=rout,
        )

    # --- initial tests

    if not os.path.exists(testFolder):
        print(
            "The folder to be tested does not exist: %s \nPlease check your settings and paths!"
            % (testFolder),
            file=rout,
        )
        print(
            "\n#-----------------=== End Full File Report ===----------------------",
            file=rout,
        )
        if fileClose:
            rout.close()
        raise ge.CommandFailed(
            "checkFiles",
            "Folder to test does not exist",
            "The folder to be tested does not exist: %s" % (testFolder),
            "Please check your settings and paths!",
        )

    if not os.path.exists(specFile):
        print(
            "The specification file to test folder against does not exist: %s\nPlease check your settings and paths!"
            % (specFile),
            file=rout,
        )
        print(
            "\n#-----------------=== End Full File Report ===----------------------",
            file=rout,
        )
        if fileClose:
            rout.close()
        raise ge.CommandFailed(
            "checkFiles",
            "Specification file does not exist",
            "The specification file to test folder against does not exist: %s"
            % (specFile),
            "Please check your settings and paths!",
        )

    # --- read the spec

    files = open(specFile, "r").read()

    if fields:
        for key, value in fields:
            files = files.replace("{%s}" % (key), value)

    files = [
        [f.strip().split() for f in e.split("|")]
        for e in files.split("\n")
        if len(e) and not e.startswith("#")
    ]

    # --- test the files

    present = []
    missing = []
    for testfiles in files:
        fileMissing = True
        for testfile in testfiles:
            test = [testFolder] + testfile
            tfile = os.path.join(*test)
            if os.path.exists(tfile):
                present.append(tfile)
                fileMissing = False
                if report:
                    print(". " + tfile, file=rout)
                break
        if fileMissing:
            missing.append(tfile)
            if report:
                print("X " + tfile, file=rout)

    if report:
        print(
            "\n#-----------------=== End Full File Report ===----------------------",
            file=rout,
        )
        if fileClose:
            rout.close()

    status = len(missing) == 0

    return status, present, missing


def printAndLog(*args, **kwargs):
    """
    ``printAndLog(*args, **kwargs)``

    Prints all that is given as nonpositional argument to the standard output.

    INPUTS
    ======

    --file         Prints to the file.
    --write        Creates a file and writes to it.
    --append       Opens a file and appends to it.
    --silent       Whether to not print to stdout.
    --end          How to end ['\n'].
    """

    silent = kwargs.get("silent", False)
    file = kwargs.get("file", None)
    write = kwargs.get("write", None)
    append = kwargs.get("append", None)
    end = kwargs.get("end", "\n")

    if write:
        write = open(write, "w")
    if append:
        append = open(append, "a")

    for element in args + (end,):
        if not silent:
            print(element, end=" ")
        for out in [append, write, file]:
            if out:
                print(element, end=" ", file=out)

    for toclose in [append, write]:
        if toclose:
            toclose.close()


def getLogFile(folders=None, tags=None):
    """
    ``getLogFile(folders=None, tags=None)``

    Creates a log file in the comlogs folder.

    INPUTS
    ======

    --folders      A dictionary with the known paths.
    --tags         An array of strings to use to create the filename.

    OUTPUTS
    =======

    --filename         The path to the log file.
    --file handle      The file handle of the open file.

    USE
    ===

    Creates a log file in the comlogs folder and returns the name and the file
    handle. It tries to find the correct location for the log based on the
    provided folders.

    """

    folders = deduceFolders(folders)

    if "logfolder" not in folders:
        raise ge.CommandFailed(
            "getLogFile",
            "Logfolder not found",
            "Could not deduce the location of the log folder based on the provided information!",
        )

    basestring = (str, bytes)
    if isinstance(tags, basestring) or tags is None:
        tags = []

    logstamp = datetime.now().strftime("%Y-%m-%d_%H.%M.%S.%f")
    logname = tags + [logstamp]
    logname = [e for e in logname if e]
    logname = "_".join(logname)
    logname = os.path.join(folders["logfolder"], "comlogs", "tmp_%s.log" % (logname))
    logfile = open(logname, "w")

    return logname, logfile


def closeLogFile(logfile=None, logname=None, status="done"):
    """
    ``closeLogFile(logfile=None, logname=None, status="done")``

    Closes the logfile and swaps the 'tmp_', 'done_', 'error_', 'incomplete_' at
    the start of the logname to the provided status.
    """

    if logfile:
        logfile.close()

    if logname:
        logfolder, newname = os.path.split(logname)
        newname = re.sub("^(tmp_|done_|error_|incomplete_|)", status + "_", newname)
        newfile = os.path.join(logfolder, newname)
        os.rename(logname, newfile)

    return newfile


def underscore(s):
    s = s + "\n" + "".join(["=" for e in range(len(s))])
    return s


def plist(s):
    """
    plist(s)
    Processes the string, spliting it by the pipe "|" symbol, trimming
    any whitespace caracters from start or end of each resulting
    substring, and retuns an array of substrings of length more than 0.
    """
    s = s.split("|")
    s = [e.strip() for e in s]
    s = [e for e in s if len(e) > 0]
    return s


def pcslist(s):
    """
    pcslist(s)
    Processes the string, spliting it by the pipe "|", comma or space, trimming
    any whitespace caracters from start or end of each resulting substring, and
    retuns an array of substrings of length more than 0.
    """
    s = re.split(r" *, *| *\| *| +", s)
    s = [e.strip() for e in s]
    s = [e for e in s if len(e) > 0]
    return s


def link_or_copy(
    source, target, r=None, status=None, name=None, prefix=None, symlink=False
):
    """
    link_or_copy - documentation not yet available.
    """
    if status is None:
        status = True
    if name is None:
        name = "file"
    if prefix is None:
        prefix = "\n ... "
    if os.path.exists(source):
        try:
            if os.path.exists(target):
                if os.path.samefile(source, target):
                    if r is None:
                        return status and True
                    else:
                        return (
                            status and True,
                            "%s%s%s already mapped" % (r, prefix, name),
                        )
                else:
                    os.remove(target)

            # link
            if not symlink:
                os.link(source, target)
            else:
                os.symlink(source, target)

            if r is None:
                return status and True
            else:
                return (status and True, "%s%s%s mapped" % (r, prefix, name))

        except:
            try:
                shutil.copy2(source, target)
                if r is None:
                    return status and True
                else:
                    return (status and True, "%s%s%s copied" % (r, prefix, name))
            except:
                if r is None:
                    return False
                else:
                    return (
                        False,
                        "%s%sERROR: %s could not be copied, check permissions! "
                        % (r, prefix, name),
                    )
        return True
    else:
        if r is None:
            return False
        else:
            return (
                False,
                "%s%sERROR: %s could not be copied, source file does not exist [%s]! "
                % (r, prefix, name, source),
            )


def moveLinkOrCopy(
    source, target, action=None, r=None, status=None, name=None, prefix=None, lock=False
):
    """
    moveLinkOrCopy - documentation not yet available.
    """
    if action is None:
        action = "link"
    if status is None:
        status = True
    if name is None:
        name = source
    if prefix is None:
        prefix = ""

    def report(rstatus, msg):
        if lock:
            fl.unlock(target)
        if r is None:
            return rstatus
        else:
            return rstatus, r + prefix + msg

    if os.path.exists(source):
        targetfolder = os.path.dirname(target)
        if not os.path.exists(targetfolder):
            io = fl.makedirs(targetfolder)
            if io:
                if io != "File exists":
                    return report(
                        False,
                        "ERROR: %s could not be %sed, target folder could not be created, check permissions! "
                        % (name, action),
                    )

        if lock:
            fl.lock(target)

        if action == "link":
            io = fl.link(source, target)
            if not io:
                return report(status, "%s mapped" % (name))
            elif io == "File exists":
                if os.path.samefile(source, target):
                    return report(status, "%s already mapped [%s]" % (name, target))
                else:
                    io = fl.remove(target)
                    if io and io != "No such file or directory":
                        return report(
                            False,
                            "ERROR: %s could not be %sed, existing file could not be removed, check permissions! "
                            % (name, action),
                        )
                    io = fl.link(source, target)
                    if not io:
                        return report(status, "%s mapped" % (name))
                    else:
                        action = "copy"
            else:
                action = "copy"

        if action == "copy":
            try:
                shutil.copy2(source, target)
                return report(status, "%s copied" % (name))
            except:
                return report(
                    False, "ERROR: %s could not be copied, check permissions! " % (name)
                )

        if action == "move":
            try:
                shutil.move(source, target)
                return report(status, "%s moved" % (name))
            except:
                return report(
                    False, "ERROR: %s could not be moved, check permissions! " % (name)
                )

        if action == "gzip":
            try:
                with open(source, "rb") as f_in, gzip.open(target, "wb") as f_out:
                    shutil.copyfileobj(f_in, f_out)
                return report(status, "%s copied and gzipped" % (name))
            except:
                return report(
                    False,
                    "ERROR: %s could not be copied and gzipped, check permissions! "
                    % (name),
                )

    else:
        return report(
            False,
            "WARNING: %s could not be %sed, source file either does not exist or can not be accessed [%s]! "
            % (name, action, source),
        )


def createSessionFile(command, sfolder, session, subject, overwrite, prefix=""):
    """
    ``createSessionFile(command, sfolder, session, subject, overwrite, prefix)``

    Creates the generic, non pipeline specific, session file.
    """

    # open fifle
    sfile = os.path.join(sfolder, "session.txt")
    if os.path.exists(sfile):
        if overwrite == "yes" or overwrite is True:
            os.remove(sfile)
            print(prefix + "---> removed existing session.txt file")
        else:
            raise ge.CommandFailed(
                command,
                "session.txt file already present!",
                "A session.txt file alredy exists [%s]" % (sfile),
                "Please check or set parameter 'overwrite' to 'yes' to rebuild it!",
            )

    sout = open(sfile, "w")
    print_qunex_header(file=sout)
    print("#", file=sout)
    print("session:", session, file=sout)
    print("subject:", subject, file=sout)

    # bids
    bfolder = os.path.join(sfolder, "bids")
    if os.path.exists(bfolder):
        print("bids:", bfolder, file=sout)

    # nii
    nfolder = os.path.join(sfolder, "nii")
    if os.path.exists(bfolder):
        print("raw_data:", nfolder, file=sout)

    # hcp
    hfolder = os.path.join(sfolder, "hcp")
    print("hcp:", hfolder, file=sout)

    # empty line
    print(file=sout)

    # return
    return sout


def get_qunex_version():
    """
    Returns the version of currently used QuNex suite.
    """

    # open the version file and read its contents
    with open(
        os.path.join(os.environ["TOOLS"], os.environ["QUNEXREPO"], "VERSION.md"), "r"
    ) as f:
        version = f.read().strip()

    return version
